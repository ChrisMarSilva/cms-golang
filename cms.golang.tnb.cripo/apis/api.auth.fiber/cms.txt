


.
‚îú‚îÄ‚îÄ api            # Directory for exposing external API interfaces, typically containing proto files and generated *.pb.go files. The directory structure is typically in the form `api/xxx/v1`, where v1 indicates the version.
‚îú‚îÄ‚îÄ assets         # Store various static resources, such as images, markdown files, etc.
‚îú‚îÄ‚îÄ cmd            # Program entry directory
‚îÇ    ‚îî‚îÄ‚îÄ serviceName
‚îÇ         ‚îú‚îÄ‚îÄ initial     # Program initialization, consisting of three files: initApp initializes configurations, registerServers registers services (HTTP or grpc), and registerClose registers resource cleanup.
‚îÇ         ‚îî‚îÄ‚îÄ main.go     # Program entry file
‚îú‚îÄ‚îÄ configs        # Directory for configuration files
‚îú‚îÄ‚îÄ deployments    # Directory for deployment scripts, supporting Bare Metal, Docker and Kubernetes deployments.
‚îÇ   ‚îú‚îÄ binary
‚îÇ   ‚îú‚îÄ docker-compose
‚îÇ   ‚îî‚îÄ kubernetes
‚îú‚îÄ docs            # Directory for API interface Swagger documentation.
‚îú‚îÄ‚îÄ i(I)nternal       # Directory for business logic code, if the first letter is lowercase (internal), it means private code, if the first letter is capitalised (Internal), it means it can be reused by other code.
‚îÇ    ‚îú‚îÄ‚îÄ cache        # Cache directory wrapped around business logic.
‚îÇ    ‚îú‚îÄ‚îÄ config       # Directory for Go structure configuration files.
‚îÇ    ‚îú‚îÄ‚îÄ dao          # Data access directory.
‚îÇ    ‚îú‚îÄ‚îÄ ecode        # Directory for system error codes and custom business error codes.
‚îÇ    ‚îú‚îÄ‚îÄ handler      # Directory for implementing HTTP business functionality (specific to web services).
‚îÇ    ‚îú‚îÄ‚îÄ model        # Database model directory.
‚îÇ    ‚îú‚îÄ‚îÄ routers      # HTTP routing directory.
‚îÇ    ‚îú‚îÄ‚îÄ rpcclient    # Directory for client-side code that connects to grpc services.
‚îÇ    ‚îú‚îÄ‚îÄ server       # Directory for creating services, including HTTP and grpc.
‚îÇ    ‚îú‚îÄ‚îÄ service      # Directory for implementing grpc business functionality (specific to grpc services).
‚îÇ    ‚îî‚îÄ‚îÄ types        # Directory for defining request and response parameter structures for HTTP.
‚îú‚îÄ‚îÄ pkg            # Directory for shared libraries.
‚îú‚îÄ‚îÄ scripts        # Directory for scripts, including compilation, execution, code generation, and deployment scripts.
‚îú‚îÄ‚îÄ test           # Directory for scripts required for testing services  and test SQL.
‚îî‚îÄ‚îÄ third_party    # Directory for external helper programs, forked code, and other third-party tools.


https://dev.to/zhufuyi/gin-gorm-practical-guide-implementing-a-simple-qa-community-backend-service-in-one-hour-350c





 // PATH: go-auth/models/Claims.go

 package models

 import "github.com/dgrijalva/jwt-go"

 type Claims struct {
     Role string `json:"role"`
     jwt.StandardClaims
 }


// PATH: go-auth/models/index.go

package models

import (
    "fmt"

    "gorm.io/driver/postgres"
    "gorm.io/gorm"
)

type Config struct {
    Host     string
    Port     string
    User     string
    Password string
    DBName   string
    SSLMode  string
}

var DB *gorm.DB

func InitDB(cfg Config) {

    dsn := fmt.Sprintf("host=%s user=%s password=%s dbname=%s port=%s sslmode=%s", cfg.Host, cfg.User, cfg.Password, cfg.DBName, cfg.Port, cfg.SSLMode)

    db, err := gorm.Open(postgres.Open(dsn), &gorm.Config{})
    if err != nil {
        panic(err)
    }

    if err := db.AutoMigrate(&User{}); err != nil {
        panic(err)
    }

    fmt.Println("Migrated database")

    DB = db
}
Let's understand the above code in detail:

The Config struct holds the configuration values for the database connection, such as the host, port, user, password, database name, and SSL mode.

The DB variable is a global variable that will store the instance of the database connection.

The InitDB function is used to initialize the database connection using the values from the Config struct.

It generates the data source name (DSN) string from the configuration values.

It opens a connection to the PostgreSQL database using the GORM library and the generated DSN. If there is an error, it panics.

It automatically migrates the User model by calling AutoMigrate. This creates the necessary table in the database if it doesn't exist. If there is an error, it panics.

It sets the global DB variable to the instance of the database connection.

3Ô∏è‚É£ Creating Routes:
Now, let's define the routes for a web application using the Gin HTTP framework.


COPY

COPY
// PATH: go-auth/routes/auth.go

package routes

import (
    "go-auth/controllers"

    "github.com/gin-gonic/gin"
)

func AuthRoutes(r *gin.Engine) {
    r.POST("/login", controllers.Login)
    r.POST("/signup", controllers.Signup)
    r.GET("/home", controllers.Home)
    r.GET("/premium", controllers.Premium)
    r.GET("/logout", controllers.Logout)
}
This code defines the routes for the web application but does not handle the logic for each route. That logic is implemented in the controllers package.

Let's understand the above code in detail:

The AuthRoutes function takes a gin.Engine instance as an argument and sets up the routes for the application.

Using the r.POST method, a route for a login request is defined that maps to the Login function in the controllers package.

Similarly, using the r.POST method, a route for a signup request is defined that maps to the Signup function in the controllers package.

Using the r.GET method, a route for a home request is defined that maps to the Home function in the controllers package.

Using the r.GET method, a route for a premium request is defined that maps to the Premium function in the controllers package.

Using the r.GET method, a route for a logout request is defined that maps to the Logout function in the controllers package.

4Ô∏è‚É£ Defining main.go (The Driver Code):
This is the main driver code that will orchestrate the whole project.


COPY

COPY
// PATH: go-auth/main.go

package main

import (
    "go-auth/models"
    "go-auth/routes"
    "log"
    "os"

    "github.com/gin-gonic/gin"
    "github.com/joho/godotenv"
)

func main() {
    // Create a new gin instance
    r := gin.Default()

    // Load .env file and Create a new connection to the database
    err := godotenv.Load()
    if err != nil {
        log.Fatal("Error loading .env file")
    }
    config := models.Config{
        Host:     os.Getenv("DB_HOST"),
        Port:     os.Getenv("DB_PORT"),
        User:     os.Getenv("DB_USER"),
        Password: os.Getenv("DB_PASSWORD"),
        DBName:   os.Getenv("DB_NAME"),
        SSLMode:  os.Getenv("DB_SSLMODE"),
    }

    // Initialize DB
    models.InitDB(config)

    // Load the routes
    routes.AuthRoutes(r)

    // Run the server
    r.Run(":8080")
}
This is the main function of the application. It performs the following actions:

Creates a new instance of the Gin web framework.

Loads the environment variables from a .env file.

Initializes the database connection using the configurations obtained from the environment variables.

Calls the AuthRoutes function to define the routes for the application.

Starts the web server on port 8080.

Meme Time:
Tired? Refresh your mind with this Low Effort Meme:
*le gophers after reading this much.

Go pointers demystified

5Ô∏è‚É£ Defining Controllers:
This will contain all the logic for the authentication and authorization which was previously mapped in routes package.


COPY

COPY
// PATH: go-auth/controllers/auth.go

package controllers

import (
    "go-auth/models"
    "time"

    "go-auth/utils"

    "github.com/dgrijalva/jwt-go"
    "github.com/gin-gonic/gin"
)

// The string "my_secret_key" is just an example and should be replaced with a secret key of sufficient length and complexity in a real-world scenario.
var jwtKey = []byte("my_secret_key")
This code consists of several functions each handling different parts of the authentication process.

Login: Handles user login requests by receiving user credentials, verifying if the user exists, and checking if the provided password is correct. If everything is okay, it generates a JSON Web Token (JWT) and sets it as a cookie in the client's browser.


COPY

COPY
  // PATH: go-auth/controllers/auth.go

  func Login(c *gin.Context) {

      var user models.User

      if err := c.ShouldBindJSON(&user); err != nil {
          c.JSON(400, gin.H{"error": err.Error()})
          return
      }

      var existingUser models.User

      models.DB.Where("email = ?", user.Email).First(&existingUser)

      if existingUser.ID == 0 {
          c.JSON(400, gin.H{"error": "user does not exist"})
          return
      }

      errHash := utils.CompareHashPassword(user.Password, existingUser.Password)

      if !errHash {
          c.JSON(400, gin.H{"error": "invalid password"})
          return
      }

      expirationTime := time.Now().Add(5 * time.Minute)

      claims := &models.Claims{
          Role: existingUser.Role,
          StandardClaims: jwt.StandardClaims{
              Subject:   existingUser.Email,
              ExpiresAt: expirationTime.Unix(),
          },
      }

      token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)

      tokenString, err := token.SignedString(jwtKey)

      if err != nil {
          c.JSON(500, gin.H{"error": "could not generate token"})
          return
      }

      c.SetCookie("token", tokenString, int(expirationTime.Unix()), "/", "localhost", false, true)
      c.JSON(200, gin.H{"success": "user logged in"})
  }
Signup: Handles user signup requests by receiving user information, checking if the user already exists, hashing the password, and creating a new user in the database.


COPY

COPY
  // PATH: go-auth/controllers/auth.go

  func Signup(c *gin.Context) {
      var user models.User

      if err := c.ShouldBindJSON(&user); err != nil {
          c.JSON(400, gin.H{"error": err.Error()})
          return
      }

      var existingUser models.User

      models.DB.Where("email = ?", user.Email).First(&existingUser)

      if existingUser.ID != 0 {
          c.JSON(400, gin.H{"error": "user already exists"})
          return
      }

      var errHash error
      user.Password, errHash = utils.GenerateHashPassword(user.Password)

      if errHash != nil {
          c.JSON(500, gin.H{"error": "could not generate password hash"})
          return
      }

      models.DB.Create(&user)

      c.JSON(200, gin.H{"success": "user created"})
  }
Home: Handles requests to the home page by checking if the user is authorized to access it by looking for the JWT in the client's cookie and verifying it. If the user is authorized, the function returns the "home page" message along with the user's role.


COPY

COPY
  // PATH: go-auth/controllers/auth.go

  func Home(c *gin.Context) {

      cookie, err := c.Cookie("token")

      if err != nil {
          c.JSON(401, gin.H{"error": "unauthorized"})
          return
      }

      claims, err := utils.ParseToken(cookie)

      if err != nil {
          c.JSON(401, gin.H{"error": "unauthorized"})
          return
      }

      if claims.Role != "user" && claims.Role != "admin" {
          c.JSON(401, gin.H{"error": "unauthorized"})
          return
      }

      c.JSON(200, gin.H{"success": "home page", "role": claims.Role})
  }
Premium: Similar to the Home function but only returns the "premium page" message and the user's role if the user has an "admin" role.


COPY

COPY
  // PATH: go-auth/controllers/auth.go

  func Premium(c *gin.Context) {

      cookie, err := c.Cookie("token")

      if err != nil {
          c.JSON(401, gin.H{"error": "unauthorized"})
          return
      }

      claims, err := utils.ParseToken(cookie)

      if err != nil {
          c.JSON(401, gin.H{"error": "unauthorized"})
          return
      }

      if claims.Role != "admin" {
          c.JSON(401, gin.H{"error": "unauthorized"})
          return
      }

      c.JSON(200, gin.H{"success": "premium page", "role": claims.Role})
  }
Logout: Handles user logout requests by deleting the JWT cookie in the client's browser.


COPY

COPY
  // PATH: go-auth/controllers/auth.go

  func Logout(c *gin.Context) {
      c.SetCookie("token", "", -1, "/", "localhost", false, true)
      c.JSON(200, gin.H{"success": "user logged out"})
  }
The JWT is encrypted and signed using the HS256 algorithm and the secret key jwtKey.

REMEMBER: The string "my_secret_key" is just an example and should be replaced with a secret key of sufficient length and complexity in a real-world scenario.

6Ô∏è‚É£ Creating Utility Function:
We are going to need these 3 utility functions in our project.

GenerateHashPassword: This function takes a plain text password as input and returns a hash value generated from it using a one-way hashing algorithm. The purpose of this function is to store a user's password securely in the database. This way, even if the database is compromised, the attacker cannot retrieve the original password as it is encrypted.


COPY

COPY
 // PATH: go-auth/utils/GenerateHashPassword.go

 package utils

 import "golang.org/x/crypto/bcrypt"

 func GenerateHashPassword(password string) (string, error) {
     bytes, err := bcrypt.GenerateFromPassword([]byte(password), 14)
     return string(bytes), err
 }
CompareHashPassword: This function takes the user input password and the hashed password stored in the database and compares them. If the hashes match, it returns true. This function is used to verify if the user has entered the correct password during login.


COPY

COPY
 // PATH: go-auth/utils/CompareHashPassword.go

 package utils

 import "golang.org/x/crypto/bcrypt"

 func CompareHashPassword(password, hash string) bool {
     err := bcrypt.CompareHashAndPassword([]byte(hash), []byte(password))
     return err == nil
 }
ParseToken: This function takes a JWT token as input and returns the claims contained in it. Claims are a set of key-value pairs that represent the information being transmitted between parties. In this case, the claims may include the subject (email), role, and expiration time of the token. This function is used to validate if the token is legitimate and to retrieve information contained in it.


COPY

COPY
 // PATH: go-auth/utils/ParseToken.go

 package utils

 import (
     "go-auth/models"

     "github.com/dgrijalva/jwt-go"
 )

 func ParseToken(tokenString string) (claims *models.Claims, err error) {
     token, err := jwt.ParseWithClaims(tokenString, &models.Claims{}, func(token *jwt.Token) (interface{}, error) {
         return []byte("my_secret_key"), nil
     })

     if err != nil {
         return nil, err
     }

     claims, ok := token.Claims.(*models.Claims)

     if !ok {
         return nil, err
     }

     return claims, nil
 }
7Ô∏è‚É£ Creating Middlewares:
This is an example of middleware for authorization. You can use this to authorize any route you create.


COPY

COPY
// PATH: go-auth/middlewares/isAuthorized.go

package middlewares

import (
    "go-auth/utils"

    "github.com/gin-gonic/gin"
)

func IsAuthorized() gin.HandlerFunc {
    return func(c *gin.Context) {
        cookie, err := c.Cookie("token")

        if err != nil {
            c.JSON(401, gin.H{"error": "unauthorized"})
            c.Abort()
            return
        }

        claims, err := utils.ParseToken(cookie)

        if err != nil {
            c.JSON(401, gin.H{"error": "unauthorized"})
            c.Abort()
            return
        }

        c.Set("role", claims.Role)
        c.Next()
    }
}
The function IsAuthorized returns a Gin handler function, which is used to process HTTP requests and responses in a Gin web application.

The handler function retrieves the "token" cookie from the incoming HTTP request and tries to parse it using the ParseToken function from the utils package. If the cookie is missing or the parsing fails, the function returns a JSON response with a 401 Unauthorized HTTP status code and an error message, indicating that the user is not authorized to access the requested resource.

If the token parsing is successful, the function sets the "role" value in the context object (c) to the value of the "Role" claim in the parsed token, and calls the Next method to continue processing the request in the next middleware or handler in the middleware chain.

üòá Conclusion
In conclusion, implementing authentication and authorization in Golang is a straightforward process. By following the steps outlined in this article, you can create a secure and efficient authentication and authorization system for your Golang application. Whether you are building a simple web app or a complex enterprise system, Golang provides all the tools you need to ensure that your users' data is protected. By using JWT tokens and hashing techniques, you can ensure that your authentication and authorization system is reliable, scalable, and easy to maintain. With the right tools and knowledge, you can make your Golang application a secure and trusted platform for your users.

GitHub Repository of the Project: https://github.com/tanmayVaish/go-auth





// PATH: go-auth/routes/auth.go

package routes

import (
    "go-auth/controllers"

    "github.com/gin-gonic/gin"
)

func AuthRoutes(r *gin.Engine) {
    r.POST("/login", controllers.Login)
    r.POST("/signup", controllers.Signup)
    r.GET("/home", controllers.Home)
    r.GET("/premium", controllers.Premium)
    r.GET("/logout", controllers.Logout)
}


// PATH: go-auth/main.go

package main

import (
    "go-auth/models"
    "go-auth/routes"
    "log"
    "os"

    "github.com/gin-gonic/gin"
    "github.com/joho/godotenv"
)

func main() {
    // Create a new gin instance
    r := gin.Default()

    // Load .env file and Create a new connection to the database
    err := godotenv.Load()
    if err != nil {
        log.Fatal("Error loading .env file")
    }
    config := models.Config{
        Host:     os.Getenv("DB_HOST"),
        Port:     os.Getenv("DB_PORT"),
        User:     os.Getenv("DB_USER"),
        Password: os.Getenv("DB_PASSWORD"),
        DBName:   os.Getenv("DB_NAME"),
        SSLMode:  os.Getenv("DB_SSLMODE"),
    }

    // Initialize DB
    models.InitDB(config)

    // Load the routes
    routes.AuthRoutes(r)

    // Run the server
    r.Run(":8080")
}



// PATH: go-auth/controllers/auth.go

package controllers

import (
    "go-auth/models"
    "time"

    "go-auth/utils"

    "github.com/dgrijalva/jwt-go"
    "github.com/gin-gonic/gin"
)

// The string "my_secret_key" is just an example and should be replaced with a secret key of sufficient length and complexity in a real-world scenario.
var jwtKey = []byte("my_secret_key")


 // PATH: go-auth/controllers/auth.go

  func Login(c *gin.Context) {

      var user models.User

      if err := c.ShouldBindJSON(&user); err != nil {
          c.JSON(400, gin.H{"error": err.Error()})
          return
      }

      var existingUser models.User

      models.DB.Where("email = ?", user.Email).First(&existingUser)

      if existingUser.ID == 0 {
          c.JSON(400, gin.H{"error": "user does not exist"})
          return
      }

      errHash := utils.CompareHashPassword(user.Password, existingUser.Password)

      if !errHash {
          c.JSON(400, gin.H{"error": "invalid password"})
          return
      }

      expirationTime := time.Now().Add(5 * time.Minute)

      claims := &models.Claims{
          Role: existingUser.Role,
          StandardClaims: jwt.StandardClaims{
              Subject:   existingUser.Email,
              ExpiresAt: expirationTime.Unix(),
          },
      }

      token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)

      tokenString, err := token.SignedString(jwtKey)

      if err != nil {
          c.JSON(500, gin.H{"error": "could not generate token"})
          return
      }

      c.SetCookie("token", tokenString, int(expirationTime.Unix()), "/", "localhost", false, true)
      c.JSON(200, gin.H{"success": "user logged in"})
  }


// PATH: go-auth/controllers/auth.go

  func Signup(c *gin.Context) {
      var user models.User

      if err := c.ShouldBindJSON(&user); err != nil {
          c.JSON(400, gin.H{"error": err.Error()})
          return
      }

      var existingUser models.User

      models.DB.Where("email = ?", user.Email).First(&existingUser)

      if existingUser.ID != 0 {
          c.JSON(400, gin.H{"error": "user already exists"})
          return
      }

      var errHash error
      user.Password, errHash = utils.GenerateHashPassword(user.Password)

      if errHash != nil {
          c.JSON(500, gin.H{"error": "could not generate password hash"})
          return
      }

      models.DB.Create(&user)

      c.JSON(200, gin.H{"success": "user created"})
  }


// PATH: go-auth/controllers/auth.go

  func Home(c *gin.Context) {

      cookie, err := c.Cookie("token")

      if err != nil {
          c.JSON(401, gin.H{"error": "unauthorized"})
          return
      }

      claims, err := utils.ParseToken(cookie)

      if err != nil {
          c.JSON(401, gin.H{"error": "unauthorized"})
          return
      }

      if claims.Role != "user" && claims.Role != "admin" {
          c.JSON(401, gin.H{"error": "unauthorized"})
          return
      }

      c.JSON(200, gin.H{"success": "home page", "role": claims.Role})
  }


// PATH: go-auth/controllers/auth.go

  func Premium(c *gin.Context) {

      cookie, err := c.Cookie("token")

      if err != nil {
          c.JSON(401, gin.H{"error": "unauthorized"})
          return
      }

      claims, err := utils.ParseToken(cookie)

      if err != nil {
          c.JSON(401, gin.H{"error": "unauthorized"})
          return
      }

      if claims.Role != "admin" {
          c.JSON(401, gin.H{"error": "unauthorized"})
          return
      }

      c.JSON(200, gin.H{"success": "premium page", "role": claims.Role})
  }


// PATH: go-auth/controllers/auth.go

  func Logout(c *gin.Context) {
      c.SetCookie("token", "", -1, "/", "localhost", false, true)
      c.JSON(200, gin.H{"success": "user logged out"})
  }



 // PATH: go-auth/utils/GenerateHashPassword.go

 package utils

 import "golang.org/x/crypto/bcrypt"

 func GenerateHashPassword(password string) (string, error) {
     bytes, err := bcrypt.GenerateFromPassword([]byte(password), 14)
     return string(bytes), err
 }



 // PATH: go-auth/utils/CompareHashPassword.go

 package utils

 import "golang.org/x/crypto/bcrypt"

 func CompareHashPassword(password, hash string) bool {
     err := bcrypt.CompareHashAndPassword([]byte(hash), []byte(password))
     return err == nil
 }



// PATH: go-auth/utils/ParseToken.go

 package utils

 import (
     "go-auth/models"

     "github.com/dgrijalva/jwt-go"
 )

 func ParseToken(tokenString string) (claims *models.Claims, err error) {
     token, err := jwt.ParseWithClaims(tokenString, &models.Claims{}, func(token *jwt.Token) (interface{}, error) {
         return []byte("my_secret_key"), nil
     })

     if err != nil {
         return nil, err
     }

     claims, ok := token.Claims.(*models.Claims)

     if !ok {
         return nil, err
     }

     return claims, nil
 }



// PATH: go-auth/middlewares/isAuthorized.go

package middlewares

import (
    "go-auth/utils"

    "github.com/gin-gonic/gin"
)

func IsAuthorized() gin.HandlerFunc {
    return func(c *gin.Context) {
        cookie, err := c.Cookie("token")

        if err != nil {
            c.JSON(401, gin.H{"error": "unauthorized"})
            c.Abort()
            return
        }

        claims, err := utils.ParseToken(cookie)

        if err != nil {
            c.JSON(401, gin.H{"error": "unauthorized"})
            c.Abort()
            return
        }

        c.Set("role", claims.Role)
        c.Next()
    }
}


func main() {
    r := gin.Default()
    r.POST("/login", gin.BasicAuth(gin.Accounts{
        "admin": "secret",
    }), func(c *gin.Context) {
        token, _ := randomHex(20)
        tokens = append(tokens, token)

        c.JSON(http.StatusOK, gin.H{
            "token": token,
        })
    })
    r.GET("/resource", func(c *gin.Context) {
        bearerToken := c.Request.Header.Get("Authorization")
        reqToken := strings.Split(bearerToken, " ")[1]
        for _, token := range tokens {
            if token == reqToken {
                c.JSON(http.StatusOK, gin.H{
                    "data": "resource data",
                })
                return
            }
        }
        c.JSON(http.StatusUnauthorized, gin.H{
            "message": "unauthorized",
        })
    })
    r.Run() // Listen and serve on 0.0.0.0:8080 (for Windows "localhost:8080")
}


var jwtKey = []byte("my_secret_key")
var tokens []string

type Claims struct {
    Username string `json:"username"`
    jwt.RegisteredClaims
}



 r.GET("/resource", func(c *gin.Context) {
        bearerToken := c.Request.Header.Get("Authorization")
        reqToken := strings.Split(bearerToken, " ")[1]
        claims := &Claims{}
        tkn, err := jwt.ParseWithClaims(reqToken, claims, func(token *jwt.Token) (interface{}, error) {
            return jwtKey, nil
        })
        if err != nil {
            if err == jwt.ErrSignatureInvalid {
                c.JSON(http.StatusUnauthorized, gin.H{
                    "message": "unauthorized",
                })
                return
            }
            c.JSON(http.StatusBadRequest, gin.H{
                "message": "bad request",
            })
            return
        }
        if !tkn.Valid {
            c.JSON(http.StatusUnauthorized, gin.H{
                "message": "unauthorized",
            })
            return
        }

        c.JSON(http.StatusOK, gin.H{
            "data": "resource data",
        })
    })


func generateJWT() (string, error) {
    expirationTime := time.Now().Add(5 * time.Minute)
    claims := &Claims{
        Username: "username",
        RegisteredClaims: jwt.RegisteredClaims{
            ExpiresAt: jwt.NewNumericDate(expirationTime),
        },
    }

    token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)

    return token.SignedString(jwtKey)

}


cookie := new(http.Cookie)
	cookie.Name = "token"
	cookie.Value = tokenString
	cookie.Expires = expirationTime.Time
	c.SetCookie(cookie)


package auth

var allowList = map[string]bool{
	"/register": true,
	"/login":    true,
}

func TokenMiddleware(next echo.HandlerFunc) echo.HandlerFunc {
	jwtSecretKey := viper.GetString("ONLINE_TICKET_GO_JWTKEY")

	return func(c echo.Context) error {
		if _, ok := allowList[c.Request().RequestURI]; ok {
			return next(c)
		}

		cookie, err := c.Cookie("token")
		if err != nil {
			return c.String(http.StatusBadRequest, err.Error())
		}

		token := cookie.Value

		claim := Claims{}
		parsedTokenInfo, err := jwt.ParseWithClaims(token, &claim, func(token *jwt.Token) (interface{}, error) {
			return []byte(jwtSecretKey), nil
		})
		if err != nil {
			if errors.Is(err, jwt.ErrSignatureInvalid) {
				return c.String(http.StatusUnauthorized, "Please login again")
			}

			return c.String(http.StatusUnauthorized, "Please login again")
		}

		if !parsedTokenInfo.Valid {
			return c.String(http.StatusForbidden, "Invalid token")
		}

		c.Set("claim", claim)

		return next(c)
	}
}

func AdminMiddleware(next echo.HandlerFunc) echo.HandlerFunc {
	return func(c echo.Context) error {
		claim, _ := c.Get("claim").(Claims)

		if claim.IsNotAdmin() {
			return c.String(http.StatusForbidden, "You have no authority")
		}

		return next(c)
	}
}


Open the project in your IDE and edit the .env file as below
// replace values inside <<>> with your custom values
# Database credentials
DB_HOST="localhost"
DB_DRIVER=mysql
DB_USER="<<DB_USER>>"
DB_PASSWORD="<<DB_PASSWORD>>"
DB_NAME="jwt_go_rbac"
DB_PORT="3306"

# Default Admin User
ADMIN_USERNAME="<<ADMIN_USERNAME>>"
ADMIN_EMAIL="<<ADMIN_EMAIL>>"
ADMIN_PASSWORD="<<ADMIN_PASSWORD>>"

# Authentication credentials
TOKEN_TTL="1800"
JWT_PRIVATE_KEY="<<JWT_KEY>>"


$ go get github.com/joho/godotenv



package database

import (
	"fmt"
	"log"
	"os"

	"gorm.io/driver/mysql"
	"gorm.io/gorm"
)

var Db *gorm.DB

func InitDb() *gorm.DB {
	Db = connectDB()
	return Db
}

func connectDB() *gorm.DB {
	var err error
	host := os.Getenv("DB_HOST")
	username := os.Getenv("DB_USER")
	password := os.Getenv("DB_PASSWORD")
	dbname := os.Getenv("DB_NAME")
	port := os.Getenv("DB_PORT")

	dsn := fmt.Sprintf("%s:%s@tcp(%s:%s)/%s?charset=utf8&parseTime=True&loc=Local", username, password, host, port, dbname)
	//log.Println("dsn : ", dsn)
	db, err := gorm.Open(mysql.Open(dsn), &gorm.Config{})

	if err != nil {
		log.Fatal("Error connecting to database :", err)
		return nil
	}
	log.Println("`Successfully connected to the database")

	return db
}



package main

// load required packages
import (
	"bmacharia/jwt-go-rbac/database"
	"fmt"
	"log"

	"github.com/gin-gonic/gin"
	"github.com/joho/godotenv"
)

func main() {
	// load environment file
	loadEnv()
	// load database configuration and connection
	loadDatabase()
	// start the server
	serveApplication()
}

func loadEnv() {
	err := godotenv.Load(".env")
	if err != nil {
		log.Fatal("Error loading .env file")
	}
	log.Println(".env file loaded successfully")
}

func loadDatabase() {
	database.InitDb()
}

func serveApplication() {
	router := gin.Default()

	router.Run(":8000")
	fmt.Println("Server running on port 8000")
}


// Validate user password
func (user *User) ValidateUserPassword(password string) error {
	return bcrypt.CompareHashAndPassword([]byte(user.Password), []byte(password))
}



// Role model
type Role struct {
	gorm.Model
	ID          uint   `gorm:"primary_key"`
	Name        string `gorm:"size:50;not null;unique" json:"name"`
	Description string `gorm:"size:255;not null" json:"description"`
}




//edit main.go file to add automigration script
...
// run database migrations and add seed data
func loadDatabase() {
    database.InitDb()
    database.Db.AutoMigrate(&model.Role{})
    database.Db.AutoMigrate(&model.User{})
    seedData()
}

// load seed data into the database
func seedData() {
    var roles = []model.Role{{Name: "admin", Description: "Administrator role"}, {Name: "customer", Description: "Authenticated customer role"}, {Name: "anonymous", Description: "Unauthenticated customer role"}}
    var user = []model.User{{Username: os.Getenv("ADMIN_USERNAME"), Email: os.Getenv("ADMIN_EMAIL"), Password: os.Getenv("ADMIN_PASSWORD"), RoleID: 1}}
    database.Db.Save(&roles)
    database.Db.Save(&user)
}
// run migration
$ go run main.go



package model

type Register struct {
	Username string `json:"username" binding:"required"`
	Email    string `json:"email" binding:"required"`
	Password string `json:"password" binding:"required"`
}



id, _ := strconv.Atoi(c.Param("id"))



	"github.com/go-playground/validator/v10"


	if err := context.ShouldBindJSON(&input); err != nil {
		var errorMessage string
		var validationErrors validator.ValidationErrors
		if errors.As(err, &validationErrors) {
			validationError := validationErrors[0]
			if validationError.Tag() == "required" {
				errorMessage = fmt.Sprintf("%s not provided", validationError.Field())
			}
		}
		context.JSON(http.StatusBadRequest, gin.H{"error": errorMessage})
		return
	}



// edit main.go
func serveApplication() {
    router := gin.Default()
    authRoutes := router.Group("/auth/user")
        // registration route
    authRoutes.POST("/register", controller.Register)
        // login route
    authRoutes.POST("/login", controller.Login)

    router.Run(":8000")
    fmt.Println("Server running on port 8000")
}


// run the application
$ go run main.go
// register user
$ curl -X POST http://localhost:8000/auth/user/register \
     -H "Content-Type: application/json" \
     -H "Accept: application/json" \
     -d '{"username": "test","email":"test@bmacharia.com","password":"super^Secret!007"}'
// test user login
$ curl -X POST http://localhost:8000/auth/user/login \
     -H "Content-Type: application/json" \
     -H "Accept: application/json" \
     -d '{"username": "test","password":"super^Secret!007"}' 



jwt.go
package util

import (
	"bmacharia/jwt-go-rbac/model"
	"errors"
	"fmt"
	"os"
	"strconv"
	"strings"
	"time"

	"github.com/golang-jwt/jwt/v5"

	"github.com/gin-gonic/gin"
)

// retrieve JWT key from .env file
var privateKey = []byte(os.Getenv("JWT_PRIVATE_KEY"))

// generate JWT token
func GenerateJWT(user model.User) (string, error) {
	tokenTTL, _ := strconv.Atoi(os.Getenv("TOKEN_TTL"))
	token := jwt.NewWithClaims(jwt.SigningMethodHS256, jwt.MapClaims{
		"id":   user.ID,
		"role": user.RoleID,
		"iat":  time.Now().Unix(),
		"eat":  time.Now().Add(time.Second * time.Duration(tokenTTL)).Unix(),
	})
	return token.SignedString(privateKey)
}

// validate JWT token
func ValidateJWT(context *gin.Context) error {
	token, err := getToken(context)
	if err != nil {
		return err
	}
	_, ok := token.Claims.(jwt.MapClaims)
	if ok && token.Valid {
		return nil
	}
	return errors.New("invalid token provided")
}

// validate Admin role
func ValidateAdminRoleJWT(context *gin.Context) error {
	token, err := getToken(context)
	if err != nil {
		return err
	}
	claims, ok := token.Claims.(jwt.MapClaims)
	userRole := uint(claims["role"].(float64))
	if ok && token.Valid && userRole == 1 {
		return nil
	}
	return errors.New("invalid admin token provided")
}

// validate Customer role
func ValidateCustomerRoleJWT(context *gin.Context) error {
	token, err := getToken(context)
	if err != nil {
		return err
	}
	claims, ok := token.Claims.(jwt.MapClaims)
	userRole := uint(claims["role"].(float64))
	if ok && token.Valid && userRole == 2 || userRole == 1 {
		return nil
	}
	return errors.New("invalid author token provided")
}

// fetch user details from the token
func CurrentUser(context *gin.Context) model.User {
	err := ValidateJWT(context)
	if err != nil {
		return model.User{}
	}
	token, _ := getToken(context)
	claims, _ := token.Claims.(jwt.MapClaims)
	userId := uint(claims["id"].(float64))

	user, err := model.GetUserById(userId)
	if err != nil {
		return model.User{}
	}
	return user
}

// check token validity
func getToken(context *gin.Context) (*jwt.Token, error) {
	tokenString := getTokenFromRequest(context)
	token, err := jwt.Parse(tokenString, func(token *jwt.Token) (interface{}, error) {
		if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok {
			return nil, fmt.Errorf("unexpected signing method: %v", token.Header["alg"])
		}

		return privateKey, nil
	})
	return token, err
}

// extract token from request Authorization header
func getTokenFromRequest(context *gin.Context) string {
	bearerToken := context.Request.Header.Get("Authorization")
	splitToken := strings.Split(bearerToken, " ")
	if len(splitToken) == 2 {
		return splitToken[1]
	}
	return ""
}



wtAuth.go

package util

import (
	"net/http"

	"github.com/gin-gonic/gin"
)

// check for valid admin token
func JWTAuth() gin.HandlerFunc {
	return func(context *gin.Context) {
		err := ValidateJWT(context)
		if err != nil {
			context.JSON(http.StatusUnauthorized, gin.H{"error": "Authentication required"})
			context.Abort()
			return
		}
		error := ValidateAdminRoleJWT(context)
		if error != nil {
			context.JSON(http.StatusUnauthorized, gin.H{"error": "Only Administrator is allowed to perform this action"})
			context.Abort()
			return
		}
		context.Next()
	}
}

// check for valid customer token
func JWTAuthCustomer() gin.HandlerFunc {
	return func(context *gin.Context) {
		err := ValidateJWT(context)
		if err != nil {
			context.JSON(http.StatusUnauthorized, gin.H{"error": "Authentication required"})
			context.Abort()
			return
		}
		error := ValidateCustomerRoleJWT(context)
		if error != nil {
			context.JSON(http.StatusUnauthorized, gin.H{"error": "Only registered Customers are allowed to perform this action"})
			context.Abort()
			return
		}
		context.Next()
	}
}


// edit user controller and append 
func Login(context *gin.Context) {
     jwt, err := util.GenerateJWT(user)
     if err != nil {
        context.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
        return
    }

    context.JSON(http.StatusOK, gin.H{"token": jwt, "username": input.Username, "message": "Successfully logged in"})
}


// edit main.go
func serveApplication() {
        adminRoutes := router.Group("/admin")
    adminRoutes.Use(util.JWTAuth())
    adminRoutes.GET("/users", controller.GetUsers)
    adminRoutes.GET("/user/:id", controller.GetUser)
    adminRoutes.PUT("/user/:id", controller.UpdateUser)
    adminRoutes.POST("/user/role", controller.CreateRole)
    adminRoutes.GET("/user/roles", controller.GetRoles)
    adminRoutes.PUT("/user/role/:id", controller.UpdateRole)
}


Admin login
// admin user login
$ curl -X POST http://localhost:8000/auth/user/login \
     -H "Content-Type: application/json" \
     -H "Accept: application/json" \
     -d '{"username": "test","password":"super^Secret!007"}' 
Get All Users
// use admin token from login response
$ curl -X GET http://localhost:8000/admin/users \
     -H "Content-Type: application/json" \
     -H "Accept: application/json" \
     -H "Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJlYXQiOjE2ODQ0NDc1ODQsImlhdCI6MTY4NDQ0NTc4NCwiaWQiOjEsInJvbGUiOjF9.CKQf2GggCP1cnGqfTp_2R77Q7GsQBX_dxf5PSLEbTx8" \
     -d '{"username": "test","password":"super^Secret!007"}'
Get User by ID
$ curl -X GET http://localhost:8000/admin/user/1 \
     -H "Content-Type: application/json" \
     -H "Accept: application/json" \
     -H "Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJlYXQiOjE2ODQ0NDc1ODQsImlhdCI6MTY4NDQ0NTc4NCwiaWQiOjEsInJvbGUiOjF9.CKQf2GggCP1cnGqfTp_2R77Q7GsQBX_dxf5PSLEbTx8"
Update User
$ curl -X PUT http://localhost:8000/admin/user/2 \
     -H "Content-Type: application/json" \
     -H "Accept: application/json" \
     -H "Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJlYXQiOjE2ODQ0NDc1ODQsImlhdCI6MTY4NDQ0NTc4NCwiaWQiOjEsInJvbGUiOjF9.CKQf2GggCP1cnGqfTp_2R77Q7GsQBX_dxf5PSLEbTx8" \
     -d '{"username": "test","email":"test@gmail.com","role_id":"2"}'
Create Role
$ curl -X POST http://localhost:8000/admin/user/role \
     -H "Content-Type: application/json" \
     -H "Accept: application/json" \
     -H "Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJlYXQiOjE2ODQ0NDc1ODQsImlhdCI6MTY4NDQ0NTc4NCwiaWQiOjEsInJvbGUiOjF9.CKQf2GggCP1cnGqfTp_2R77Q7GsQBX_dxf5PSLEbTx8" \
     -d '{"name": "testing","description":"Test user role"}'
Get All Roles
$ curl -X GET http://localhost:8000/admin/user/roles \
     -H "Content-Type: application/json" \
     -H "Accept: application/json" \
     -H "Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJlYXQiOjE2ODQ0NDc1ODQsImlhdCI6MTY4NDQ0NTc4NCwiaWQiOjEsInJvbGUiOjF9.CKQf2GggCP1cnGqfTp_2R77Q7GsQBX_dxf5PSLEbTx8"
Update Role
$ curl -X PUT http://localhost:8000/admin/user/role/4 \
     -H "Content-Type: application/json" \
     -H "Accept: application/json" \
     -H "Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJlYXQiOjE2ODQ0NDc1ODQsImlhdCI6MTY4NDQ0NTc4NCwiaWQiOjEsInJvbGUiOjF9.CKQf2GggCP1cnGqfTp_2R77Q7GsQBX_dxf5PSLEbTx8" \
     -d '{"name":"accountant","description":"Accountant user role"}'
Add Room
$ curl -X POST http://localhost:8000/admin/room/add \
     -H "Content-Type: application/json" \
     -H "Accept: application/json" \
     -H "Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJlYXQiOjE2ODQ0NDc1ODQsImlhdCI6MTY4NDQ0NTc4NCwiaWQiOjEsInJvbGUiOjF9.CKQf2GggCP1cnGqfTp_2R77Q7GsQBX_dxf5PSLEbTx8" \
     -d '{"name": "Room 9","location":"Second Floor"}'
List all Rooms
$ curl -X GET http://localhost:8000/api/view/rooms \
     -H "Content-Type: application/json" \
     -H "Accept: application/json"
Get Room by ID
$ curl -X GET http://localhost:8000/api/view/room/3 \
     -H "Content-Type: application/json" \
     -H "Accept: application/json"
Step 8: Test the room booking service

Book a Room
$ curl -X POST http://localhost:8000/api/room/book \
     -H "Content-Type: application/json" \
     -H "Accept: application/json" \
     -H "Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJlYXQiOjE2ODUyMjk0MDEsImlhdCI6MTY4NTIyNzYwMSwiaWQiOjI0LCJyb2xlIjoyfQ.h8R51DA5N_xeCa8xR1HLeOo4JTmIGjUp3oMPJLuBv3g" \
     -d '{"room_id": 3}'
List all Bookings
$ curl -X GET http://localhost:8000/admin/room/bookings \
     -H "Content-Type: application/json" \
     -H "Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJlYXQiOjE2ODcyOTkyMTAsImlhdCI6MTY4NzI5NzQxMCwiaWQiOjEsInJvbGUiOjF9.3oztz8EgE-l3byKWzCI760FE-BmRY7B-BohnYydDElc" \
     -H "Accept: application/json"
List all User Bookings
$ curl -X GET http://localhost:8000/api/rooms/booked \
     -H "Content-Type: application/json" \
     -H "Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJlYXQiOjE2ODUyMjk0MDEsImlhdCI6MTY4NTIyNzYwMSwiaWQiOjI0LCJyb2xlIjoyfQ.h8R51DA5N_xeCa8xR1HLeOo4JTmIGjUp3oMPJLuBv3g" \
     -H "Accept: application/json"



package utils

import (
    "time"
    "github.com/dgrijalva/jwt-go"
)

var secretKey = []byte("secretpassword")

// GenerateToken generates a JWT token with the user ID as part of the claims
func GenerateToken(userID uint) (string, error) {
    claims := jwt.MapClaims{}
    claims["user_id"] = userID
    claims["exp"] = time.Now().Add(time.Hour * 1).Unix() // Token valid for 1 hour

    token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
    return token.SignedString(secretKey)
}

// VerifyToken verifies a token JWT validate 
func VerifyToken(tokenString string) (jwt.MapClaims, error) {
    // Parse the token
    token, err := jwt.Parse(tokenString, func(token *jwt.Token) (interface{}, error) {
        // Check the signing method
        if _, ok := token.Method.(*jwt.SigningMethodHS256); !ok {
            return nil, fmt.Errorf("Invalid signing method")
        }

        return secretKey, nil
    })

    // Check for errors
    if err != nil {
        return nil, err
    }

    // Validate the token
    if claims, ok := token.Claims.(jwt.MapClaims); ok && token.Valid {
        return claims, nil
    }

    return nil, fmt.Errorf("Invalid token")
}


package middleware

import (
    "net/http"
    "strings"
    "github.com/gin-gonic/gin"
    "authentication-api/utils"
)

// AuthenticationMiddleware checks if the user has a valid JWT token
func AuthenticationMiddleware() gin.HandlerFunc {
    return func(c *gin.Context) {
        tokenString := c.GetHeader("Authorization")
        if tokenString == "" {
            c.JSON(http.StatusUnauthorized, gin.H{"error": "Missing authentication token"})
            c.Abort()
            return
        }

        // The token should be prefixed with "Bearer "
        tokenParts := strings.Split(tokenString, " ")
        if len(tokenParts) != 2 || tokenParts[0] != "Bearer" {
            c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid authentication token"})
            c.Abort()
            return
        }

        tokenString = tokenParts[1]

        claims, err := utils.VerifyToken(tokenString)
        if err != nil {
            c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid authentication token"})
            c.Abort()
            return
        }

        c.Set("user_id", claims["user_id"])
        c.Next()
    }
}


package handlers

import (
    "net/http"
    "github.com/gin-gonic/gin"
    "authentication-api/models"
    "authentication-api/utils"
)

// Function for logging in
func Login(c *gin.Context) {
    var user models.User

    // Check user credentials and generate a JWT token
    if err := c.ShouldBindJSON(&user); err != nil {
        c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid data"})
        return
    }

    // Check if credentials are valid (replace this logic with real authentication)
    if user.Username == "user" && user.Password == "password" {
        // Generate a JWT token
        token, err := utils.GenerateToken(user.ID)
        if err != nil {
            c.JSON(http.StatusInternalServerError, gin.H{"error": "Error generating token"})
            return
        }

        c.JSON(http.StatusOK, gin.H{"token": token})
    } else {
        c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid credentials"})
    }
}

// Function for registering a new user (for demonstration purposes)
func Register(c *gin.Context) {
    var user models.User

    if err := c.ShouldBindJSON(&user); err != nil {
        c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid data"})
        return
    }

    // Remember to securely hash passwords before storing them
    user.ID = 1 // Just for demonstration purposes
    c.JSON(http.StatusCreated, gin.H{"message": "User registered successfully"})
}


/pkg/database
/init.go



package auth

import (
	"errors"
	"github.com/golang-jwt/jwt/v4"
	"github.com/labstack/echo/v4"
	"github.com/spf13/viper"
	"net/http"
)

var allowList = map[string]bool{
	"/register": true,
	"/login":    true,
}

func TokenMiddleware(next echo.HandlerFunc) echo.HandlerFunc {
	jwtSecretKey := viper.GetString("ONLINE_TICKET_GO_JWTKEY")

	return func(c echo.Context) error {
		if _, ok := allowList[c.Request().RequestURI]; ok {
			return next(c)
		}

		cookie, err := c.Cookie("token")
		if err != nil {
			return c.String(http.StatusBadRequest, err.Error())
		}

		token := cookie.Value

		claim := Claims{}
		parsedTokenInfo, err := jwt.ParseWithClaims(token, &claim, func(token *jwt.Token) (interface{}, error) {
			return []byte(jwtSecretKey), nil
		})
		if err != nil {
			if errors.Is(err, jwt.ErrSignatureInvalid) {
				return c.String(http.StatusUnauthorized, "Please login again")
			}

			return c.String(http.StatusUnauthorized, "Please login again")
		}

		if !parsedTokenInfo.Valid {
			return c.String(http.StatusForbidden, "Invalid token")
		}

		c.Set("claim", claim)

		return next(c)
	}
}

func AdminMiddleware(next echo.HandlerFunc) echo.HandlerFunc {
	return func(c echo.Context) error {
		claim, _ := c.Get("claim").(Claims)

		if claim.IsNotAdmin() {
			return c.String(http.StatusForbidden, "You have no authority")
		}

		return next(c)
	}
}


package auth

import (
	"github.com/golang-jwt/jwt/v4"
)

type UserType string

const (
	Admin          UserType = "admin"
	IndividualUser UserType = "individual"
	CorporateUser  UserType = "corporate"
)

type Claims struct {
	Username string   `json:"username"`
	UserType UserType `json:"user_type"`
	UserID   uint
	jwt.RegisteredClaims
}

func (c *Claims) IsIndividualUser() bool {
	return c.UserType == IndividualUser
}

func (c *Claims) IsCorporatedUser() bool {
	return c.UserType == CorporateUser
}

func (c *Claims) IsAdmin() bool {
	return c.UserType == Admin
}

func (c *Claims) IsNotAdmin() bool {
	return !c.IsAdmin()
}

func (c *Claims) IsUser() bool {
	return c.UserType == IndividualUser || c.UserType == CorporateUser
}

func (c *Claims) IsUserOrAdmin() bool {
	return c.IsAdmin() || c.IsUser()
}

func (c *Claims) IsUnknownTypeUser() bool {
	return !c.IsUserOrAdmin()
}


	timeoutCtx, cancel := context.WithTimeout(ctx, 3*time.Second)
	defer cancel()


var (
	ErrNoCapacity   = errors.New("capacity is full")
	ErrTripNotFound = errors.New("this trip does not exist")

	ErrExceedAllowedTicketToPurchase = func(limit int) error {
		return fmt.Errorf("exceed number of tickets allowed to be purchased(%d)", limit)
	}

	ErrExceedMaleTicketNumber = errors.New("exceed number of male ticket allowed to be purchased")
)


if err != nil {
			if errors.Is(err, trip.ErrTripNotFound) {
				return ErrTripNotFound
			}
			return err
		}


func (t *Ticket) CheckFieldsEmpty() bool {
	return t.isGenderEmpty() || t.isFullNameEmpty() || t.isEmailEmpty() || t.isPhoneEmpty()
}


b

func (t *Ticket) isTripIDEmpty() bool {
	return t.TripID == 0
}

func (p *Passenger) isGenderEmpty() bool {
	return p.Gender == ""
}



func (t *Ticket) CheckFieldsEmpty() bool {
	return t.isGenderEmpty() || t.isFullNameEmpty() || t.isEmailEmpty() || t.isPhoneEmpty()
}

func (t *Ticket) isTripIDEmpty() bool {
	return t.TripID == 0
}

func (p *Passenger) isGenderEmpty() bool {
	return p.Gender == ""
}



func (t *Ticket) CheckFieldsEmpty() bool {
	return t.isGenderEmpty() || t.isFullNameEmpty() || t.isEmailEmpty() || t.isPhoneEmpty()
}

func (t *Ticket) isTripIDEmpty() bool {
	return t.TripID == 0
}

func (p *Passenger) isGenderEmpty() bool {
	return p.Gender == ""
}




type Repository interface {
	Create(ctx context.Context, trip *Trip) error
	Delete(ctx context.Context, id int) error
	FindByFilter(ctx context.Context, trip *Filter) ([]Trip, error)
	FindByTripID(ctx context.Context, tripID int) (*Trip, error)
	GetSoldTicketNumber(ctx context.Context, tripID int) (int, error)
	UpdateAvailableSeat(ctx context.Context, tripID int, ticketNum int) error
}

type defaultRepository struct {
	database *gorm.DB
}

func NewTripRepository(database *gorm.DB) Repository {
	return &defaultRepository{database: database}
}

func (t *defaultRepository) Create(ctx context.Context, trip *Trip) error {
	timeoutCtx, cancel := context.WithTimeout(ctx, 3*time.Second)
	defer cancel()



type Repository interface {
	Create(ctx context.Context, user *User) error
	GetByUserName(ctx context.Context, username string) (*User, error)
}

type defaultRepository struct {
	database *gorm.DB
}

func NewRepository(database *gorm.DB) Repository {
	return &defaultRepository{
		database: database,
	}
}

func (r *defaultRepository) GetByUserName(ctx context.Context, username string) (*User, error) {
	user := User{}


func (u *User) IsUserTypeValid() bool {
	switch u.UserType {
	case auth.CorporateUser:
		fallthrough
	case auth.Admin:
		fallthrough
	case auth.IndividualUser:
		return true
	default:
		return false
	}
}


user, err := h.userService.Login(c.Request().Context(), credentials)
	if err != nil {
		switch {
		case errors.Is(err, ErrUsernameNotFound):
			return c.String(http.StatusNotFound, WarnWhenUsernameNotFound)
		case errors.Is(err, ErrUsernameOrPasswordInvalid):
			return c.String(http.StatusUnauthorized, WarnNonValidCredentials)
		default:
			return c.String(http.StatusInternalServerError, WarnInternalServerError)
		}
	}



func (h *handler) Logout(c echo.Context) error {
	cookie := new(http.Cookie)
	cookie.Name = "token"
	cookie.Value = ""
	cookie.MaxAge = 0
	c.SetCookie(cookie)
	return c.String(http.StatusOK, "You have successfully logout")
}


var mySigningKey = []byte(os.Getenv("SECRET_KEY"))


func GetJWT() (string, error) {
  token := jwt.New(jwt.SigningMethodHS256)

  claims := token.Claims.(jwt.MapClaims)

  claims["authorized"] = true
  claims["client"] = "Krissanawat"
  claims["aud"] = "billing.jwtgo.io"
  claims["iss"] = "jwtgo.io"
  claims["exp"] = time.Now().Add(time.Minute * 1).Unix()

  tokenString, err := token.SignedString(mySigningKey)

  if err != nil {
    fmt.Errorf("Something Went Wrong: %s", err.Error())
    return "", err
  }

  return tokenString, nil
}





func proxy(path, target string) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		targetURL := target + r.URL.Path
		req, err := http.NewRequest(r.Method, targetURL, r.Body)
		if err != nil {
			http.Error(w, err.Error(), http.StatusBadGateway)
			return
		}

		req.Header = r.Header

		client := &http.Client{}
		resp, err := client.Do(req)
		if err != nil {
			http.Error(w, err.Error(), http.StatusBadGateway)
			return
		}
		defer resp.Body.Close()

		for key, values := range resp.Header {
			for _, value := range values {
				w.Header().Add(key, value)
			}
		}

		w.WriteHeader(resp.StatusCode)

		// Copy the response body to the client
		_, err = io.Copy(w, resp.Body)
		if err != nil {
			http.Error(w, err.Error(), http.StatusBadGateway)
			return
		}
	}
}



newUser := models.User{
		Name:     payload.Name,
		Email:    strings.ToLower(payload.Email),
		Password: payload.Password,
	}

	result := ac.DB.Create(&newUser)

	if result.Error != nil && strings.Contains(result.Error.Error(), "duplicate key value violates unique") {
		ctx.JSON(http.StatusConflict, gin.H{"status": "fail", "message": "Email already exist, please use another email address"})
		return
	} else if result.Error != nil {
		ctx.JSON(http.StatusBadGateway, gin.H{"status": "error", "message": result.Error.Error()})
		return
	}



func (user *User) HashPassword(password string) error {
  bytes, err := bcrypt.GenerateFromPassword([]byte(password), 14)
  if err != nil {
    return err
  }
  user.Password = string(bytes)
  return nil
}
func (user *User) CheckPassword(providedPassword string) error {
  err := bcrypt.CompareHashAndPassword([]byte(user.Password), []byte(providedPassword))
  if err != nil {
    return err
  }
  return nil
}


package auth
import (
  "errors"
  "time"
  "github.com/dgrijalva/jwt-go"
)
var jwtKey = []byte("supersecretkey")
type JWTClaim struct {
  Username string `json:"username"`
  Email    string `json:"email"`
  jwt.StandardClaims
}
func GenerateJWT(email string, username string) (tokenString string, err error) {
  expirationTime := time.Now().Add(1 * time.Hour)
  claims:= &JWTClaim{
    Email: email,
    Username: username,
    StandardClaims: jwt.StandardClaims{
      ExpiresAt: expirationTime.Unix(),
    },
  }
  token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
  tokenString, err = token.SignedString(jwtKey)
  return
}
func ValidateToken(signedToken string) (err error) {
  token, err := jwt.ParseWithClaims(
    signedToken,
    &JWTClaim{},
    func(token *jwt.Token) (interface{}, error) {
      return []byte(jwtKey), nil
    },
  )
  if err != nil {
    return
  }
  claims, ok := token.Claims.(*JWTClaim)
  if !ok {
    err = errors.New("couldn't parse claims")
    return
  }
  if claims.ExpiresAt < time.Now().Local().Unix() {
    err = errors.New("token expired")
    return
  }
  return
}



package middlewares
import (
  "jwt-authentication-golang/auth"
  "github.com/gin-gonic/gin"
)
func Auth() gin.HandlerFunc{
  return func(context *gin.Context) {
    tokenString := context.GetHeader("Authorization")
    if tokenString == "" {
      context.JSON(401, gin.H{"error": "request does not contain an access token"})
      context.Abort()
      return
    }
    err:= auth.ValidateToken(tokenString)
    if err != nil {
      context.JSON(401, gin.H{"error": err.Error()})
      context.Abort()
      return
    }
    context.Next()
  }
}



package middleware

import (
	"context"
	"crypto/tls"
	"encoding/json"
	"fmt"
	"net/http"
	"time"

	oidc "github.com/coreos/go-oidc"
	"github.com/julienschmidt/httprouter"
)

type Res401Struct struct {
	Status   string `json:"status" example:"FAILED"`
	HTTPCode int    `json:"httpCode" example:"401"`
	Message  string `json:"message" example:"authorisation failed"`
}

//claims component of jwt contains mainy fields , we need only roles of DemoServiceClient
//"DemoServiceClient":{"DemoServiceClient":{"roles":["pets-admin","pet-details","pets-search"]}},
type Claims struct {
	ResourceAccess client `json:"resource_access,omitempty"`
	JTI            string `json:"jti,omitempty"`
}

type client struct {
	DemoServiceClient clientRoles `json:"DemoServiceClient,omitempty"`
}

type clientRoles struct {
	Roles []string `json:"roles,omitempty"`
}

var RealmConfigURL string = "http://10.66.29.167:9999/auth/realms/DEMOREALM"
var clientID string = "DemoServiceClient"

func IsAuthorizedJWT(h httprouter.Handle, role string) httprouter.Handle {
	return func(w http.ResponseWriter, r *http.Request, ps httprouter.Params) {

		rawAccessToken := r.Header.Get("Authorization")

		tr := &http.Transport{
			TLSClientConfig: &tls.Config{InsecureSkipVerify: true},
		}
		client := &http.Client{
			Timeout:   time.Duration(6000) * time.Second,
			Transport: tr,
		}
		ctx := oidc.ClientContext(context.Background(), client)
		provider, err := oidc.NewProvider(ctx, RealmConfigURL)
		if err != nil {
			authorisationFailed("authorisation failed while getting the provider: "+err.Error(), w, r)
			return
		}

		oidcConfig := &oidc.Config{
			ClientID: clientID,
		}
		verifier := provider.Verifier(oidcConfig)
		idToken, err := verifier.Verify(ctx, rawAccessToken)
		if err != nil {
			authorisationFailed("authorisation failed while verifying the token: "+err.Error(), w, r)
			return
		}

		var IDTokenClaims Claims // ID Token payload is just JSON.
		if err := idToken.Claims(&IDTokenClaims); err != nil {
			authorisationFailed("claims : "+err.Error(), w, r)
			return
		}
		fmt.Println(IDTokenClaims)
		//checking the roles
		user_access_roles := IDTokenClaims.ResourceAccess.DemoServiceClient.Roles
		for _, b := range user_access_roles {
			if b == role {
				h(w, r, ps)
				return
			}
		}

		authorisationFailed("user not allowed to access this api", w, r)
	}
}

func authorisationFailed(message string, w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(http.StatusUnauthorized)
	data := Res401Struct{
		Status:   "FAILED",
		HTTPCode: http.StatusUnauthorized,
		Message:  message,
	}
	res, _ := json.Marshal(data)
	w.Write(res)
}



package middleware

import (
    "net/http"
    "strings"
    "github.com/gin-gonic/gin"
    "authentication-api/utils"
)

// AuthenticationMiddleware checks if the user has a valid JWT token
func AuthenticationMiddleware() gin.HandlerFunc {
    return func(c *gin.Context) {
        tokenString := c.GetHeader("Authorization")
        if tokenString == "" {
            c.JSON(http.StatusUnauthorized, gin.H{"error": "Missing authentication token"})
            c.Abort()
            return
        }

        // The token should be prefixed with "Bearer "
        tokenParts := strings.Split(tokenString, " ")
        if len(tokenParts) != 2 || tokenParts[0] != "Bearer" {
            c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid authentication token"})
            c.Abort()
            return
        }

        tokenString = tokenParts[1]

        claims, err := utils.VerifyToken(tokenString)
        if err != nil {
            c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid authentication token"})
            c.Abort()
            return
        }

        c.Set("user_id", claims["user_id"])
        c.Next()
    }
}


package utils

import (
    "time"
    "github.com/dgrijalva/jwt-go"
)

var secretKey = []byte("secretpassword")

// GenerateToken generates a JWT token with the user ID as part of the claims
func GenerateToken(userID uint) (string, error) {
    claims := jwt.MapClaims{}
    claims["user_id"] = userID
    claims["exp"] = time.Now().Add(time.Hour * 1).Unix() // Token valid for 1 hour

    token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
    return token.SignedString(secretKey)
}

// VerifyToken verifies a token JWT validate 
func VerifyToken(tokenString string) (jwt.MapClaims, error) {
    // Parse the token
    token, err := jwt.Parse(tokenString, func(token *jwt.Token) (interface{}, error) {
        // Check the signing method
        if _, ok := token.Method.(*jwt.SigningMethodHS256); !ok {
            return nil, fmt.Errorf("Invalid signing method")
        }

        return secretKey, nil
    })

    // Check for errors
    if err != nil {
        return nil, err    }

    // Validate the token
    if claims, ok := token.Claims.(jwt.MapClaims); ok && token.Valid {
        return claims, nil
    }

    return nil, fmt.Errorf("Invalid token")
}



kong

version: '3.7'

volumes:
  kong_data: {}

networks:
  kong-net:
    external: true

services:
  kong-migrations:
    image: "kong:2.3.2-alpine"
    command: kong migrations bootstrap
    depends_on:
      - db
    environment:
      KONG_DATABASE: postgres
      KONG_PG_DATABASE: kong
      KONG_PG_HOST: db
      KONG_PG_USER: kong
      KONG_PG_PASSWORD: kong
    networks:
      - kong-net
    restart: on-failure
    deploy:
      restart_policy:
        condition: on-failure

  kong-migrations-up:
    image: "kong:2.3.2-alpine"
    command: kong migrations up && kong migrations finish
    depends_on:
      - db
    environment:
      KONG_DATABASE: postgres
      KONG_PG_DATABASE: kong
      KONG_PG_HOST: db
      KONG_PG_USER: kong
      KONG_PG_PASSWORD: kong
    networks:
      - kong-net
    restart: on-failure
    deploy:
      restart_policy:
        condition: on-failure

  kong:
    image: "kong:2.3.2-alpine"
    user: "kong"
    depends_on:
      - db
    environment:
      KONG_ADMIN_ACCESS_LOG: /dev/stdout
      KONG_ADMIN_ERROR_LOG: /dev/stderr
      KONG_ADMIN_LISTEN: '0.0.0.0:8001'
      KONG_CASSANDRA_CONTACT_POINTS: db
      KONG_DATABASE: postgres
      KONG_PG_DATABASE: kong
      KONG_PG_HOST: db
      KONG_PG_USER: kong
      KONG_PROXY_ACCESS_LOG: /dev/stdout
      KONG_PROXY_ERROR_LOG: /dev/stderr
      KONG_PG_PASSWORD: kong
    
    networks:
      - kong-net
    ports:
      - "8000:8000/tcp"
      - "127.0.0.1:8001:8001/tcp"
      - "8443:8443/tcp"
      - "127.0.0.1:8444:8444/tcp"
    healthcheck:
      test: ["CMD", "kong", "health"]
      interval: 10s
      timeout: 10s
      retries: 10
    restart: on-failure
    deploy:
      restart_policy:
        condition: on-failure
    
  db:
    image: postgres:9.5
    environment:
      POSTGRES_DB: kong
      POSTGRES_USER: kong
      POSTGRES_PASSWORD: kong
    
    healthcheck:
      test: ["CMD", "pg_isready", "-U", "kong"]
      interval: 30s
      timeout: 30s
      retries: 3
    restart: on-failure
    deploy:
      restart_policy:
        condition: on-failure
    stdin_open: true
    tty: true
    networks:
      - kong-net
    # volumes:
    #   - kong_data:/var/lib/postgresql/data

  konga-prepare:
    container_name: konga-prepare
    image: pantsel/konga:latest
    command: "-c prepare -a postgres -u postgresql://kong:kong@db:5432/konga_db"
    networks:
      - kong-net
    restart: on-failure
    depends_on:
      - db

  konga:
    container_name: konga
    image: pantsel/konga:latest
    restart: always
    networks:
      - kong-net
    environment:
      DB_ADAPTER: postgres
      DB_HOST: db
      DB_USER: kong
      DB_PASSWORD: kong
      TOKEN_SECRET: ahfdjgjgf79JKLFHJKh978953kgdfjkl
      DB_DATABASE: konga_db
      NODE_ENV: production
    depends_on:
      - db
    ports:
      - "1337:1337"



FROM golang:1.22 as builder

WORKDIR /go/src/
COPY . .
RUN GOOS=linux CGO_ENABLED=0 go build -o server main.go 

FROM scratch
WORKDIR /go/
COPY --from=builder /go/src/server /go
CMD ["/go/server"]



version: "3.7"

networks:
  kong-net:
    name: kong-net
    driver: bridge
   

services:

  servicea:
    image: thiagopereiracontas/kong-service:latest
    environment:
      PORT: ":8081"
      CONTENT: "<h1>Service A</h1>"
    networks:
      - kong-net
    ports:
      - 8081:8081

  serviceb:
    image: thiagopereiracontas/kong-service:latest
    environment:
      PORT: ":8082"
      CONTENT: "<h1>Service b</h1>"
    networks:
      - kong-net
    ports:
      - 8082:8082

  servicec:
    image: thiagopereiracontas/kong-service:latest
    environment:
      PORT: ":8083"
      CONTENT: "<h1>Service C</h1>"
    networks:
      - kong-net
    ports:
      - 8083:8083


api-gateway-go/pkg/logging
/logger.go


package logging

import (
	"go.uber.org/zap"
	"go.uber.org/zap/zapcore"
)

func NewLogger() (*zap.Logger, error) {
	config := zap.NewProductionConfig()
	config.EncoderConfig.EncodeTime = zapcore.ISO8601TimeEncoder
	logger, err := config.Build()
	if err != nil {
		return nil, err
	}
	return logger, nil
}


type Middleware struct {
	logger  *zap.Logger
	limiter *rate.Limiter
	routes  map[string]*config.Route
	db      *database.Database
}



type Handler struct {
	routes map[string]*config.Route
	logger *zap.Logger
	db     *database.Database
}

type RouteMetrics struct {
	CallCount     int           `json:"callCount"`
	TotalResponse time.Duration `json:"totalResponse"`
	ServiceURL    string        `json:"serviceURL"`
	Path          string        `json:"path"`
}

func NewHandler(db *database.Database, logger *zap.Logger) *Handler {
	routes, err := db.GetRoutes()
	if err != nil {
		logger.Error("Failed to load routes", zap.Error(err))
	}

	routeMap := make(map[string]*config.Route)
	for _, route := range routes {
		routeMap[route.Path] = route
	}

	return &Handler{routes: routeMap, logger: logger, db: db}
}




	r.Use(auth.IsAuthenticated())






package auth

import (
	"errors"
	"time"

	"github.com/dgrijalva/jwt-go"
)

var jwtKey = []byte("supersecretkey")

type JWTClaim struct {
	Username string `json:"username"`
	Email    string `json:"email"`
	jwt.StandardClaims
}

func GenerateJWT(email string, username string) (tokenString string, err error) {
	expirationTime := time.Now().Add(1 * time.Hour)
	claims:= &JWTClaim{
		Email: email,
		Username: username,
		StandardClaims: jwt.StandardClaims{
			ExpiresAt: expirationTime.Unix(),
		},
	}
	token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
	tokenString, err = token.SignedString(jwtKey)
	return
}

func ValidateToken(signedToken string) (err error) {
	token, err := jwt.ParseWithClaims(
		signedToken,
		&JWTClaim{},
		func(token *jwt.Token) (interface{}, error) {
			return []byte(jwtKey), nil
		},
	)

	if err != nil {
		return
	}

	claims, ok := token.Claims.(*JWTClaim)
	if !ok {
		err = errors.New("couldn't parse claims")a
		return
	}

	if claims.ExpiresAt < time.Now().Local().Unix() {
		err = errors.New("token expired")
		return
	}
	
	return

}


func restricted(c *fiber.Ctx) error {
	user := c.Locals("user").(*jwt.Token)
	claims := user.Claims.(jwt.MapClaims)
	name := claims["name"].(string)
	return c.SendString("Welcome " + name)
}


DATABASE_USER=user
DATABASE_PASS=password
DATABASE_HOST=127.0.0.1
DATABASE_PORT=27017
DATABASE_NAME=mydb
JWT_SECRET_KEY=secret



func init() {
	err := godotenv.Load()
	if err != nil {
		log.Panicln(err)
	}
}



ackage util

import "errors"

var (
	ErrInvalidEmail       = errors.New("invalid email")
	ErrEmailAlreadyExists = errors.New("email already exists")
	ErrEmptyPassword      = errors.New("password can't be empty")
	ErrInvalidAuthToken   = errors.New("invalid auth-token")
	ErrInvalidCredentials = errors.New("invalid credentials")
	ErrUnauthorized       = errors.New("Unauthorized")
)


func NormalizeEmail(email string) string {
	return strings.TrimSpace(strings.ToLower(email))
}


package security

import (
	"fmt"
	"go-fiber-auth-api/util"
	"os"
	"time"

	jwt "github.com/form3tech-oss/jwt-go"
)

var (
	JwtSecretKey     = []byte(os.Getenv("JWT_SECRET_KEY"))
	JwtSigningMethod = jwt.SigningMethodHS256.Name
)

func NewToken(userId string) (string, error) {
	claims := jwt.StandardClaims{
		Id:        userId,
		Issuer:    userId,
		IssuedAt:  time.Now().Unix(),
		ExpiresAt: time.Now().Add(time.Minute * 30).Unix(),
	}
	token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
	return token.SignedString(JwtSecretKey)
}

func validateSignedMethod(token *jwt.Token) (interface{}, error) {
	if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok {
		return nil, fmt.Errorf("Unexpected signing method: %v", token.Header["alg"])
	}
	return JwtSecretKey, nil
}

func ParseToken(tokenString string) (*jwt.StandardClaims, error) {
	claims := new(jwt.StandardClaims)
	token, err := jwt.ParseWithClaims(tokenString, claims, validateSignedMethod)
	if err != nil {
		return nil, err
	}
	var ok bool
	claims, ok = token.Claims.(*jwt.StandardClaims)
	if !ok || !token.Valid {
		return nil, util.ErrInvalidAuthToken
	}
	return claims, nil
}


/security
/password.go


package security

import "golang.org/x/crypto/bcrypt"

func EncryptPassword(password string) (string, error) {
	hashed, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
	if err != nil {
		return "", err
	}
	return string(hashed), nil
}

func VerifyPassword(hashed, password string) error {
	return bcrypt.CompareHashAndPassword([]byte(hashed), []byte(password))
}


security
/token_test.go


package security

import (
	"testing"
	"time"

	"github.com/stretchr/testify/assert"
	"gopkg.in/mgo.v2/bson"
)

func TestNewToken(t *testing.T) {
	id := bson.NewObjectId()
	token, err := NewToken(id.Hex())
	assert.NoError(t, err)
	assert.NotEmpty(t, token)
}

func TestParseToken(t *testing.T) {
	id := bson.NewObjectId()
	token, err := NewToken(id.Hex())
	assert.NoError(t, err)
	assert.NotEmpty(t, token)

	payload, err := ParseToken(token)
	assert.NoError(t, err)
	assert.Equal(t, id.Hex(), payload.Id)
	assert.Equal(t, id.Hex(), payload.Issuer)
	assert.Equal(t, time.Now().Year(), time.Unix(payload.IssuedAt, 0).Year())
	assert.Equal(t, time.Now().Month(), time.Unix(payload.IssuedAt, 0).Month())
	assert.Equal(t, time.Now().Day(), time.Unix(payload.IssuedAt, 0).Day())
}



type UsersRepository interface {
	Save(user *models.User) error
	Update(user *models.User) error
	GetById(id string) (user *models.User, err error)
	GetByEmail(email string) (user *models.User, err error)
	GetAll() (users []*models.User, err error)
	Delete(id string) error
}

type usersRepository struct {
	c *mgo.Collection
}

func NewUsersRepository(conn db.Connection) UsersRepository {
	return &usersRepository{conn.DB().C(UsersCollection)}
}


type AuthController interface {
	SignUp(ctx *fiber.Ctx) error
	SignIn(ctx *fiber.Ctx) error
	GetUser(ctx *fiber.Ctx) error
	GetUsers(ctx *fiber.Ctx) error
	PutUser(ctx *fiber.Ctx) error
	DeleteUser(ctx *fiber.Ctx) error
}

type authController struct {
	usersRepo repository.UsersRepository
}

func NewAuthController(usersRepo repository.UsersRepository) AuthController {
	return &authController{usersRepo}
}

func (c *authController) SignUp(ctx *fiber.Ctx) error {



    - authorization-service
  |- cmd
  |  |- main.go
  |
  |- configs
  |  |- config.go
  |
  |- internal
  |  |- auth
  |     |- handler.go
  |     |- model.go
  |     |- repository.go
  |     |- service.go
  |
  |- pkg
     |- database
     |  |- database.go
     |
     |- middleware
     |  |- auth.go
     |
     |- utils
        |- utils.go



        package configs

        import (
            "os"
        )
        
        type Config struct {
            DBHost     string
            DBPort     string
            DBUser     string
            DBPassword string
            DBName     string
            JWTSecret  string
        }
        
        func New() *Config {
            return &Config{
                DBHost:     os.Getenv("DB_HOST"),
                DBPort:     os.Getenv("DB_PORT"),
                DBUser:     os.Getenv("DB_USER"),
                DBPassword: os.Getenv("DB_PASSWORD"),
                DBName:     os.Getenv("DB_NAME"),
                JWTSecret:  os.Getenv("JWT_SECRET"),
            }
        }


        package database

        import (
            "fmt"
            "log"
        
            "github.com/jmoiron/sqlx"
            _ "github.com/lib/pq"
        
            "authorization-service/configs"
        )
        
        type Database struct {
            *sqlx.DB
        }
        
        func Connect() (*Database, error) {
            config := configs.New()
        
            dsn := fmt.Sprintf(
                "host=%s port=%s user=%s password=%s dbname=%s sslmode=disable",
                config.DBHost,
                config.DBPort,
                config.DBUser,
                config.DBPassword,
                config.DBName,
            )
        
            db, err := sqlx.Connect("postgres", dsn)
            if err != nil {
                log.Fatalln("error connecting to database:", err)
            }
        
            return &Database{db}, nil
        }

        internal/auth/service/service.go:



        package service

import (
	"errors"

	"github.com/dgrijalva/jwt-go"

	"authorization-service/internal/auth"
	"authorization-service/pkg/config"
	"authorization-service/pkg/repository"
)

type JWTClaims struct {
	jwt.StandardClaims
	Username string `json:"username"`
}

type AuthService struct {
	repo   auth.AuthRepository
	config *config.Config
}

func NewAuthService(repo auth.AuthRepository, config *config.Config) *AuthService {
	return &AuthService{repo, config}
}

func (s *AuthService) Authenticate(username, password string) (string, error) {
	user, err := s.repo.GetUserByUsername(username)
	if err != nil {
		return "", err
	}

	if user == nil || user.Password != password {
		return "", errors.New("invalid username or password")
	}

	claims := JWTClaims{
		jwt.StandardClaims{},
		user.Username,
	}
	token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
	tokenString, err := token.SignedString([]byte(s.config.JWTSecret))
	if err != nil {
		return "", err
	}
	return tokenString, nil
}

func (s *AuthService) Register(username, password string) error {
	user, err := s.repo.GetUserByUsername(username)
	if err != nil {
		return err
	}

	if user != nil {
		return errors.New("username already taken")
	}

	user = &auth.User{
		Username: username,
		Password: password,
	}

	err = s.repo.SaveUser(user)
	if err != nil {
		return err
	}

	return nil
}

package routes

import (
    "github.com/Siddheshk02/jwt-auth-api/controllers" // importing the routes package 
    "github.com/gofiber/fiber/v2"
)

func Setup(app *fiber.App) {
    api := app.Group("/user")

    api.Get("/get-user", controllers.User)

    api.Post("/register", controllers.Register)

    api.Post("/login", controllers.Login)

    api.Post("/logout", controllers.Logout)
}



package database

import (
    "fmt"
    "log"

    "github.com/Siddheshk02/jwt-auth-api/models" // this will be imported after you've created the User Model in the models.go file
    "gorm.io/driver/postgres"
    "gorm.io/gorm"
)

const (
    host     = "localhost"
    port     = 5432
    user     = "postgres"
    password = "<password>" //Enter your password for the DB
    dbname   = "jwt-auth-api"
)

var dsn string = fmt.Sprintf("host=%s port=%d user=%s "+
    "password=%s dbname=%s sslmode=disable TimeZone=Asia/Shanghai",
    host, port, user, password, dbname)

var DB *gorm.DB

func DBconn() {
    db, err := gorm.Open(postgres.Open(dsn), &gorm.Config{})
    if err != nil {
        log.Fatal(err)
    }
    DB = db

    db.AutoMigrate(&models.User{}) // we are going to create a models.go file for the User Model.
}


app.Use(cors.New(cors.Config{
    AllowCredentials: true, //Very important while using a HTTPonly Cookie, frontend can easily get and return back the cookie.
}))


const SecretKey = "secret"

func Login(c *fiber.Ctx) error {
    var data map[string]string

    if err := c.BodyParser(&data); err != nil {
        return err
    }

    var user models.User

    database.DB.Where("email = ?", data["email"]).First(&user) //Check the email is present in the DB

    if user.ID == 0 { //If the ID return is '0' then there is no such email present in the DB
        c.Status(fiber.StatusNotFound)
        return c.JSON(fiber.Map{
            "message": "user not found",
        })
    }

    if err := bcrypt.CompareHashAndPassword(user.Password, []byte(data["password"])); err != nil {
        c.Status(fiber.StatusBadRequest)
        return c.JSON(fiber.Map{
            "message": "incorrect password",
        })
    } // If the email is present in the DB then compare the Passwords and if incorrect password then return error.

    claims := jwt.NewWithClaims(jwt.SigningMethodHS256, jwt.StandardClaims{
        Issuer:    strconv.Itoa(int(user.ID)), //issuer contains the ID of the user.
        ExpiresAt: time.Now().Add(time.Hour * 24).Unix(), //Adds time to the token i.e. 24 hours.
    })

    token, err := claims.SignedString([]byte(SecretKey))

    if err != nil {
        c.Status(fiber.StatusInternalServerError)
        return c.JSON(fiber.Map{
            "message": "could not login",
        })
    }

    cookie := fiber.Cookie{
        Name:     "jwt",
        Value:    token,
        Expires:  time.Now().Add(time.Hour * 24),
        HTTPOnly: true,
    } //Creates the cookie to be passed.

    c.Cookie(&cookie)

    return c.JSON(fiber.Map{
        "message": "success",
    })
}


func User(c *fiber.Ctx) error {
    cookie := c.Cookies("jwt")

    token, err := jwt.ParseWithClaims(cookie, &jwt.StandardClaims{}, func(token *jwt.Token) (interface{}, error) {
        return []byte(SecretKey), nil //using the SecretKey which was generated in th Login function
    })

    if err != nil {
        c.Status(fiber.StatusUnauthorized)
        return c.JSON(fiber.Map{
            "message": "unauthenticated",
        })
    }

    claims := token.Claims.(*jwt.StandardClaims)

    var user models.User

    database.DB.Where("id = ?", claims.Issuer).First(&user)

    return c.JSON(user)

}


func Logout(c *fiber.Ctx) error {
    cookie := fiber.Cookie{
        Name:     "jwt",
        Value:    "",
        Expires:  time.Now().Add(-time.Hour), //Sets the expiry time an hour ago in the past.
        HTTPOnly: true,
    }

    c.Cookie(&cookie)

    return c.JSON(fiber.Map{
        "message": "success",
    })

}


package driver

import (
    "database/sql"

    _ "github.com/jackc/pgx/v5/stdlib"
)

type DB struct {
    SQL *sql.DB
}

var dbConn = &DB{}

func ConnectSQL(dsn string)(*DB, error){
    db, err := sql.Open("pgx", dsn)

    if err := db.Ping(); err != nil {
        panic(err)
    }

    dbConn.SQL = db

    return dbConn, err
}


package main

import (
    "fmt"
    "log"
    "net/http"

    "github.com/orololuwa/crispy-octo-guacamole/driver"
)
const portNumber = ":8080"

func main(){
    db, err := run()
    if (err != nil){
        log.Fatal(err)
    }
    defer db.SQL.Close()

    fmt.Println(fmt.Sprintf("Staring application on port %s", portNumber))


    srv := &http.Server{
        Addr: portNumber,
        Handler: nil,
    }

    err = srv.ListenAndServe()
    if err != nil {
        log.Fatal(err)
    }
}

func run()(*driver.DB, error){
    dbHost := "localhost"
    dbPort := "5432"
    dbName := "your_db_name"
    dbUser := "your_user"
    dbPassword := ""
    dbSSL := "disable"

    // Connecto to DB
    log.Println("Connecting to dabase")
    connectionString := fmt.Sprintf("host=%s port=%s dbname=%s user=%s password=%s sslmode=%s", dbHost, dbPort, dbName, dbUser, dbPassword, dbSSL)

    db, err := driver.ConnectSQL(connectionString)
    if err != nil {
        log.Fatal("Cannot conect to database: Dying!", err)
    }
    log.Println("Connected to database")

    return db, nil
}


package repository

import (
    "context"
    "database/sql"
)

type dbRepo struct {
    DB *sql.DB
}

func NewDBRepo(conn *sql.DB) DBRepo {
    return &dbRepo{
        DB: conn,
    }
}

func (m *dbRepo) Transaction(ctx context.Context, operation func(context.Context, *sql.Tx) error) error {
    tx, err := m.DB.BeginTx(ctx, nil)
    if err != nil {
        return err
    }

    defer func() error{
        if err != nil {
            tx.Rollback()
            return err
        }

        if err := tx.Commit(); err != nil {
            return err
        }

        return nil
    }()

    if err := operation(ctx, tx); err != nil {
        return err
    }

    return nil
}


package repository

import (
    "context"
    "database/sql"

    "github.com/orololuwa/crispy-octo-guacamole/models"
)

type UserRepo interface {
-   CreateAUser(user models.User) (int, error)
-   GetAUser(id int) (models.User, error)
-   GetAllUser() ([]models.User, error)
-   UpdateAUsersName(id int, firstName, lastName string)(error)
-   DeleteUserByID(id int) error
+   CreateAUser(ctx context.Context, tx *sql.Tx, user models.User) (int, error)
+   GetAUser(ctx context.Context, tx *sql.Tx, id int) (models.User, error)
+   GetAllUser(ctx context.Context, tx *sql.Tx) ([]models.User, error)
+   UpdateAUsersName(ctx context.Context, tx *sql.Tx, id int, firstName, lastName string)(error)
+   DeleteUserByID(ctx context.Context, tx *sql.Tx, id int) error
}

type DBRepo interface {
    Transaction(ctx context.Context, operation func(context.Context, *sql.Tx) error) error 
}


func (m *user) CreateAUser(user models.User) (int, error){
    -   ctx, cancel := context.WithTimeout(context.Background(), 3*time.Second)
    +func (m *user) CreateAUser(ctx context.Context, tx *sql.Tx, user models.User) (int, error){
    +   ctx, cancel := context.WithTimeout(ctx, 3*time.Second)
        defer cancel()
    
        var newId int
    
        query := `
                INSERT into users 
                    (first_name, last_name, email, password, created_at, updated_at)
                values 
                    ($1, $2, $3, $4, $5, $6)
                returning id`
    
    -   err := m.DB.QueryRowContext(ctx, query, 
    +   var err error;
    +   if tx != nil {
    +       err = tx.QueryRowContext(ctx, query, 
    +           user.FirstName, 
    +           user.LastName, 
    +           user.Email, 
    +           user.Password,
    +           time.Now(),
    +           time.Now(),
    +       ).Scan(&newId)
    +   }else{
            err = m.DB.QueryRowContext(ctx, query, 
                user.FirstName, 
                user.LastName, 
                user.Email, 
                user.Password,
                time.Now(),
                time.Now(),
            ).Scan(&newId)
    +   }


    package repository

import (
    "context"
    "database/sql"
    "time"

    "github.com/orololuwa/crispy-octo-guacamole/models"
)

type user struct {
    DB *sql.DB
}

func NewUserRepo(conn *sql.DB) UserRepo {
    return &user{
        DB: conn,
    }
}

func (m *user) CreateAUser(ctx context.Context, tx *sql.Tx, user models.User) (int, error){
    ctx, cancel := context.WithTimeout(ctx, 3*time.Second)
    defer cancel()

    var newId int

    query := `
            INSERT into users 
                (first_name, last_name, email, password, created_at, updated_at)
            values 
                ($1, $2, $3, $4, $5, $6)
            returning id`

    var err error;
    if tx != nil {
        err = tx.QueryRowContext(ctx, query, 
            user.FirstName, 
            user.LastName, 
            user.Email, 
            user.Password,
            time.Now(),
            time.Now(),
        ).Scan(&newId)
    }else{
        err = m.DB.QueryRowContext(ctx, query, 
            user.FirstName, 
            user.LastName, 
            user.Email, 
            user.Password,
            time.Now(),
            time.Now(),
        ).Scan(&newId)
    }

    if err != nil {
        return 0, err
    }

    return newId, nil
}

func (m *user) GetAUser(ctx context.Context, tx *sql.Tx, id int) (models.User, error){
    ctx, cancel := context.WithTimeout(ctx, 3*time.Second)
    defer cancel()

    var user models.User

    query := `
            SELECT (id, first_name, last_name, email, password, created_at, updated_at)
            from users
            WHERE
            id=$1
    `

    var err error
    if tx != nil {
        err = tx.QueryRowContext(ctx, query, id).Scan(
            &user.ID,
            &user.FirstName,
            &user.LastName,
            &user.Email,
            &user.Password,
            &user.CreatedAt,
            &user.UpdatedAt,
        )
    }else{
        err = m.DB.QueryRowContext(ctx, query, id).Scan(
            &user.ID,
            &user.FirstName,
            &user.LastName,
            &user.Email,
            &user.Password,
            &user.CreatedAt,
            &user.UpdatedAt,
        )
    }

    if err != nil {
        return user, err
    }

    return user, nil
}

func (m *user) GetAllUser(ctx context.Context, tx *sql.Tx) ([]models.User, error){
    ctx, cancel := context.WithTimeout(ctx, 3*time.Second)
    defer cancel()

    var users = make([]models.User, 0)

    query := `
        SELECT (id, first_name, last_name, email, password, created_at, updated_at)
        from users
    `

    var rows *sql.Rows
    var err error

    if tx != nil {
        rows, err = tx.QueryContext(ctx, query)
    }else{
        rows, err = m.DB.QueryContext(ctx, query)
    }
    if err != nil {
        return users, err
    }

    for rows.Next(){
        var user models.User
        err := rows.Scan(
            &user.ID,
            &user.FirstName,
            &user.LastName,
            &user.Email,
            &user.Password,
            &user.CreatedAt,
            &user.UpdatedAt,
        )
        if err != nil {
            return users, err
        }
        users = append(users, user)
    }

    if err = rows.Err(); err != nil {
        return users, err
    }

    return users, nil
}

func (m *user) UpdateAUsersName(ctx context.Context, tx *sql.Tx, id int, firstName, lastName string)(error){
    ctx, cancel := context.WithTimeout(ctx, 3*time.Second)
    defer cancel()

    query := `
        UPDATE 
            users set (first_name, last_name) = ($1, $2)
        WHERE
            id = $3
    `

    var err error
    if tx != nil{
        _, err = tx.ExecContext(ctx, query, firstName, lastName, id)
    }else{
        _, err = m.DB.ExecContext(ctx, query, firstName, lastName, id)
    }

    if err != nil{
        return  err
    }

    return nil
}

func (m *user) DeleteUserByID(ctx context.Context, tx *sql.Tx, id int) error {
    ctx, cancel := context.WithTimeout(ctx, 3*time.Second)
    defer cancel()

    query := "DELETE FROM users WHERE id = $1"

    var err error 

    if tx != nil {
        _, err = tx.ExecContext(ctx, query, id)
    }else{
        _, err = m.DB.ExecContext(ctx, query, id)
    }

    if err != nil {
        return err
    }

    return nil
}


user := models.User{
    FirstName: body.FirstName,
    LastName: body.LastName,
    Email: body.Email,
    Password: body.Password,
}

-       id, err := userRepo.CreateAUser(user)
+       ctx := context.Background()
+       var id int

+       err = dbRepo.Transaction(ctx, func(ctx context.Context, tx *sql.Tx) error {
+           id, err = userRepo.CreateAUser(ctx, tx, user)
+           if err != nil {
+               return err
+           }
+
+           userRepo.UpdateAUsersName(ctx, tx, id, body.FirstName, "test")
+           if err != nil {
+               return err
+           }
+
+           return nil
+       })
+       





https://github.com/zhufuyi/sponge


version: '3'

services:
  mysql-8.0:
    image: mysql:8.0.18
    container_name: mysql8
    restart: always
    command:
      - "--default-authentication-plugin=mysql_native_password"
    ports:
      - 3306:3306
    environment:
      MYSQL_ROOT_PASSWORD: 123456
    volumes:
      - $PWD/mysql-data:/var/lib/mysql
      - /etc/localtime:/etc/localtime
	  
	  
	  
version: '3'
services:
  jaeger-collector:
    image: jaegertracing/jaeger-collector:1.52
    container_name: jaeger-collector
    restart: always
    environment:
      - SPAN_STORAGE_TYPE=elasticsearch
      - ES_SERVER_URLS=${ES_URLS}
      - ES_USERNAME=${ES_USERNAME}
      - ES_PASSWORD=${ES_PASSWORD}
      - LOG_LEVEL=debug
    networks:
      - jaeger-net

  jaeger-agent:
    image: jaegertracing/jaeger-agent:1.52
    container_name: jaeger-agent
    restart: always
    command: "--reporter.grpc.host-port=jaeger-collector:14250"
    environment:
      - LOG_LEVEL=debug
    ports:
      - "5775:5775/udp"
      - "5778:5778"
      - "6831:6831/udp"
      - "6832:6832/udp"
    networks:
      - jaeger-net
    depends_on:
      - jaeger-collector

  jaeger-query:
    image: jaegertracing/jaeger-query:1.52
    container_name: jaeger-query
    restart: always
    environment:
      - SPAN_STORAGE_TYPE=elasticsearch
      - ES_SERVER_URLS=${ES_URLS}
      - ES_USERNAME=${ES_USERNAME}
      - ES_PASSWORD=${ES_PASSWORD}
      - LOG_LEVEL=debug
    ports:
      - 16686:16686
    networks:
      - jaeger-net

networks: 
  jaeger-net:
    driver: bridge



package main

import (
	"context"
	"database/sql"
	"encoding/json"
	"fmt"
	"log"
	"net/http"

	"github.com/go-chi/chi/v5"
	"github.com/orololuwa/crispy-octo-guacamole/driver"
	"github.com/orololuwa/crispy-octo-guacamole/models"
	"github.com/orololuwa/crispy-octo-guacamole/repository"
)
const portNumber = ":8080"

func main(){
	db, route, err := run()
	if (err != nil){
		log.Fatal(err)
	}
	defer db.SQL.Close()

	fmt.Println(fmt.Sprintf("Staring application on port %s", portNumber))


	srv := &http.Server{
		Addr: portNumber,
		Handler: route,
	}

	err = srv.ListenAndServe()
	if err != nil {
		log.Fatal(err)
	}
}

func run()(*driver.DB, *chi.Mux, error){
	dbHost := "localhost"
	dbPort := "5432"
	dbName := "bookings"
	dbUser := "orololuwa"
	dbPassword := ""
	dbSSL := "disable"

	// Connecto to DB
	log.Println("Connecting to dabase")
	connectionString := fmt.Sprintf("host=%s port=%s dbname=%s user=%s password=%s sslmode=%s", dbHost, dbPort, dbName, dbUser, dbPassword, dbSSL)

	db, err := driver.ConnectSQL(connectionString)
	if err != nil {
		log.Fatal("Cannot conect to database: Dying!", err)
	}
	log.Println("Connected to database")

	userRepo := repository.NewUserRepo(db.SQL)
	dbRepo := repository.NewDBRepo(db.SQL)
	router := chi.NewRouter()

	router.Post("/user", func(w http.ResponseWriter, r *http.Request) {
		type userBody struct {
			FirstName string `json:"firstName"`
			LastName string `json:"lastName"`
			Email string `json:"email"`
			Password string `json:"password"`
		}

		var body userBody
		
		err := json.NewDecoder(r.Body).Decode(&body)
		if err != nil {
			w.Header().Set("Content-Type", "application/json")
			w.WriteHeader(http.StatusInternalServerError)
			return
		}

		user := models.User{
			FirstName: body.FirstName,
			LastName: body.LastName,
			Email: body.Email,
			Password: body.Password,
		}

		ctx := context.Background()
		var id int

		err = dbRepo.Transaction(ctx, func(ctx context.Context, tx *sql.Tx) error {
			id, err = userRepo.CreateAUser(ctx, tx, user)
			if err != nil {
				return err
			}

			userRepo.UpdateAUsersName(ctx, tx, id, body.FirstName, "test")
			if err != nil {
				return err
			}

			return nil
		})
		
		if err != nil {
			w.Header().Set("Content-Type", "application/json")
			w.WriteHeader(http.StatusInternalServerError)
			return
		}

		response := map[string]interface{}{"message": "user created successfully", "data": id}
		jsonResponse, err := json.Marshal(response)
		if err != nil {
			http.Error(w, "Failed to marshal response", http.StatusInternalServerError)
			return
		}
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(http.StatusOK)
		w.Write(jsonResponse)
	})

	return db, router, nil
}




package repository

import (
	"context"
	"database/sql"
	"time"

	"github.com/orololuwa/crispy-octo-guacamole/models"
)

type user struct {
	DB *sql.DB
}

func NewUserRepo(conn *sql.DB) UserRepo {
	return &user{
		DB: conn,
	}
}

func (m *user) CreateAUser(ctx context.Context, tx *sql.Tx, user models.User) (int, error){
	ctx, cancel := context.WithTimeout(ctx, 3*time.Second)
	defer cancel()

	var newId int

	query := `
			INSERT into users 
				(first_name, last_name, email, password, created_at, updated_at)
			values 
				($1, $2, $3, $4, $5, $6)
			returning id`

	var err error;
	if tx != nil {
		err = tx.QueryRowContext(ctx, query, 
			user.FirstName, 
			user.LastName, 
			user.Email, 
			user.Password,
			time.Now(),
			time.Now(),
		).Scan(&newId)
	}else{
		err = m.DB.QueryRowContext(ctx, query, 
			user.FirstName, 
			user.LastName, 
			user.Email, 
			user.Password,
			time.Now(),
			time.Now(),
		).Scan(&newId)
	}

	if err != nil {
		return 0, err
	}

	return newId, nil
}

func (m *user) GetAUser(ctx context.Context, tx *sql.Tx, id int) (models.User, error){
	ctx, cancel := context.WithTimeout(ctx, 3*time.Second)
	defer cancel()

	var user models.User

	query := `
			SELECT (id, first_name, last_name, email, password, created_at, updated_at)
			from users
			WHERE
			id=$1
	`

	var err error
	if tx != nil {
		err = tx.QueryRowContext(ctx, query, id).Scan(
			&user.ID,
			&user.FirstName,
			&user.LastName,
			&user.Email,
			&user.Password,
			&user.CreatedAt,
			&user.UpdatedAt,
		)
	}else{
		err = m.DB.QueryRowContext(ctx, query, id).Scan(
			&user.ID,
			&user.FirstName,
			&user.LastName,
			&user.Email,
			&user.Password,
			&user.CreatedAt,
			&user.UpdatedAt,
		)
	}

	if err != nil {
		return user, err
	}

	return user, nil
}

func (m *user) GetAllUser(ctx context.Context, tx *sql.Tx) ([]models.User, error){
	ctx, cancel := context.WithTimeout(ctx, 3*time.Second)
	defer cancel()

	var users = make([]models.User, 0)

	query := `
		SELECT (id, first_name, last_name, email, password, created_at, updated_at)
		from users
	`

	var rows *sql.Rows
	var err error

	if tx != nil {
		rows, err = tx.QueryContext(ctx, query)
	}else{
		rows, err = m.DB.QueryContext(ctx, query)
	}
	if err != nil {
		return users, err
	}

	for rows.Next(){
		var user models.User
		err := rows.Scan(
			&user.ID,
			&user.FirstName,
			&user.LastName,
			&user.Email,
			&user.Password,
			&user.CreatedAt,
			&user.UpdatedAt,
		)
		if err != nil {
			return users, err
		}
		users = append(users, user)
	}

	if err = rows.Err(); err != nil {
		return users, err
	}

	return users, nil
}

func (m *user) UpdateAUsersName(ctx context.Context, tx *sql.Tx, id int, firstName, lastName string)(error){
	ctx, cancel := context.WithTimeout(ctx, 3*time.Second)
	defer cancel()

	query := `
		UPDATE 
			users set (first_name, last_name) = ($1, $2)
		WHERE
			id = $3
	`

	var err error
	if tx != nil{
		_, err = tx.ExecContext(ctx, query, firstName, lastName, id)
	}else{
		_, err = m.DB.ExecContext(ctx, query, firstName, lastName, id)
	}

	if err != nil{
		return  err
	}

	return nil
}

func (m *user) DeleteUserByID(ctx context.Context, tx *sql.Tx, id int) error {
    ctx, cancel := context.WithTimeout(ctx, 3*time.Second)
    defer cancel()

    query := "DELETE FROM users WHERE id = $1"

	var err error 

	if tx != nil {
		_, err = tx.ExecContext(ctx, query, id)
	}else{
		_, err = m.DB.ExecContext(ctx, query, id)
	}

    if err != nil {
        return err
    }

    return nil
}



package repository

import (
	"context"
	"database/sql"

	"github.com/orololuwa/crispy-octo-guacamole/models"
)

type UserRepo interface {
	CreateAUser(ctx context.Context, tx *sql.Tx, user models.User) (int, error)
	GetAUser(ctx context.Context, tx *sql.Tx, id int) (models.User, error)
	GetAllUser(ctx context.Context, tx *sql.Tx) ([]models.User, error)
	UpdateAUsersName(ctx context.Context, tx *sql.Tx, id int, firstName, lastName string)(error)
	DeleteUserByID(ctx context.Context, tx *sql.Tx, id int) error
}

type DBRepo interface {
	Transaction(ctx context.Context, operation func(context.Context, *sql.Tx) error) error 
}



package repository

import (
	"context"
	"database/sql"
)

type dbRepo struct {
	DB *sql.DB
}

func NewDBRepo(conn *sql.DB) DBRepo {
	return &dbRepo{
		DB: conn,
	}
}

func (m *dbRepo) Transaction(ctx context.Context, operation func(context.Context, *sql.Tx) error) error {
    tx, err := m.DB.BeginTx(ctx, nil)
    if err != nil {
        return err
    }
	
    defer func() error{
        if err != nil {
            tx.Rollback()
            return err
        }

        if err := tx.Commit(); err != nil {
            return err
        }

        return nil
    }()

    if err := operation(ctx, tx); err != nil {
        return err
    }

    return nil
}



package models

import "time"

type User struct {
	ID int
	FirstName string
	LastName  string
	Email     string
	Password string
	CreatedAt time.Time
	UpdatedAt time.Time
}



package driver

import (
	"database/sql"

	_ "github.com/jackc/pgx/v5/stdlib"
)

type DB struct {
	SQL *sql.DB
}

var dbConn = &DB{}

func ConnectSQL(dsn string)(*DB, error){
	db, err := sql.Open("pgx", dsn)

	if err := db.Ping(); err != nil {
		panic(err)
	}

	dbConn.SQL = db

	return dbConn, err
}




go get github.com/jackc/pgx/v5

package driver

import (
    "database/sql"

    _ "github.com/jackc/pgx/v5/stdlib"
)

type DB struct {
    SQL *sql.DB
}

var dbConn = &DB{}

func ConnectSQL(dsn string)(*DB, error){
    db, err := sql.Open("pgx", dsn)

    if err := db.Ping(); err != nil {
        panic(err)
    }

    dbConn.SQL = db

    return dbConn, err
}


package main

import (
    "fmt"
    "log"
    "net/http"

    "github.com/orololuwa/crispy-octo-guacamole/driver"
)
const portNumber = ":8080"

func main(){
    db, err := run()
    if (err != nil){
        log.Fatal(err)
    }
    defer db.SQL.Close()

    fmt.Println(fmt.Sprintf("Staring application on port %s", portNumber))


    srv := &http.Server{
        Addr: portNumber,
        Handler: nil,
    }

    err = srv.ListenAndServe()
    if err != nil {
        log.Fatal(err)
    }
}

func run()(*driver.DB, error){
    dbHost := "localhost"
    dbPort := "5432"
    dbName := "your_db_name"
    dbUser := "your_user"
    dbPassword := ""
    dbSSL := "disable"

    // Connecto to DB
    log.Println("Connecting to dabase")
    connectionString := fmt.Sprintf("host=%s port=%s dbname=%s user=%s password=%s sslmode=%s", dbHost, dbPort, dbName, dbUser, dbPassword, dbSSL)

    db, err := driver.ConnectSQL(connectionString)
    if err != nil {
        log.Fatal("Cannot conect to database: Dying!", err)
    }
    log.Println("Connected to database")

    return db, nil
}


package models

import "time"

type User struct {
    ID int
    FirstName string
    LastName  string
    Email     string
    Password string
    CreatedAt time.Time
    UpdatedAt time.Time
}



package repository

import (
    "github.com/orololuwa/crispy-octo-guacamole/models"
)

type UserRepo interface {
    CreateAUser(user models.User) (int, error)
    GetAUser(id int) (models.User, error)
    GetAllUser() ([]models.User, error)
    UpdateAUsersName(id int, firstName, lastName string)(error)
    DeleteUserByID(id int) error
}



package repository

import (
    "context"
    "database/sql"
    "time"

    "github.com/orololuwa/crispy-octo-guacamole/models"
)

type user struct {
    DB *sql.DB
}

func NewUserRepo(conn *sql.DB) UserRepo {
    return &user{
        DB: conn,
    }
}

func (m *user) CreateAUser(user models.User) (int, error){
    ctx, cancel := context.WithTimeout(context.Background(), 3*time.Second)
    defer cancel()

    var newId int

    query := `
            INSERT into users 
                (first_name, last_name, email, password, created_at, updated_at)
            values 
                ($1, $2, $3, $4, $5, $6)
            returning id`

    err := m.DB.QueryRowContext(ctx, query, 
        user.FirstName, 
        user.LastName, 
        user.Email, 
        user.Password,
        time.Now(),
        time.Now(),
    ).Scan(&newId)

    if err != nil {
        return 0, err
    }

    return newId, nil
}

func (m *user) GetAUser(id int) (models.User, error){
    ctx, cancel := context.WithTimeout(context.Background(), 3*time.Second)
    defer cancel()

    var user models.User

    query := `
            SELECT (id, first_name, last_name, email, password, created_at, updated_at)
            from users
            WHERE
            id=$1
    `

    err := m.DB.QueryRowContext(ctx, query, id).Scan(
        &user.ID,
        &user.FirstName,
        &user.LastName,
        &user.Email,
        &user.Password,
        &user.CreatedAt,
        &user.UpdatedAt,
    )

    if err != nil {
        return user, err
    }

    return user, nil
}

func (m *user) GetAllUser() ([]models.User, error){
    ctx, cancel := context.WithTimeout(context.Background(), 3*time.Second)
    defer cancel()

    var users = make([]models.User, 0)

    query := `
        SELECT (id, first_name, last_name, email, password, created_at, updated_at)
        from users
    `

    rows, err := m.DB.QueryContext(ctx, query)
    if err != nil {
        return users, err
    }

    for rows.Next(){
        var user models.User
        err := rows.Scan(
            &user.ID,
            &user.FirstName,
            &user.LastName,
            &user.Email,
            &user.Password,
            &user.CreatedAt,
            &user.UpdatedAt,
        )
        if err != nil {
            return users, err
        }
        users = append(users, user)
    }

    if err = rows.Err(); err != nil {
        return users, err
    }

    return users, nil
}

func (m *user) UpdateAUsersName(id int, firstName, lastName string)(error){
    ctx, cancel := context.WithTimeout(context.Background(), 3*time.Second)
    defer cancel()

    query := `
        UPDATE 
            users set (first_name, last_name) = ($1, $2)
        WHERE
            id = $3
    `

    _, err := m.DB.ExecContext(ctx, query, firstName, lastName, id)
    if err != nil{
        return  err
    }

    return nil
}

func (m *user) DeleteUserByID(id int) error {
    ctx, cancel := context.WithTimeout(context.Background(), 3*time.Second)
    defer cancel()

    query := "DELETE FROM users WHERE id = $1"




    _, err := m.DB.ExecContext(ctx, query, id)
    if err != nil {
        return err
    }

    return nil
}




package main

import (
+   "encoding/json"
    "fmt"
    "log"
    "net/http"

+   "github.com/go-chi/chi/v5"
    "github.com/orololuwa/crispy-octo-guacamole/driver"
+   "github.com/orololuwa/crispy-octo-guacamole/models"
+   "github.com/orololuwa/crispy-octo-guacamole/repository"
)
const portNumber = ":8080"

func main(){
-   db, err := run()
+   db, route, err := run()
    if (err != nil){
        log.Fatal(err)
    }
    defer db.SQL.Close()

    fmt.Println(fmt.Sprintf("Staring application on port %s", portNumber))


    srv := &http.Server{
        Addr: portNumber,
-       Handler: nil,
+       Handler: route,
    }

    err = srv.ListenAndServe()
    if err != nil {
        log.Fatal(err)
    }
}

-func run()(*driver.DB, error){
+func run()(*driver.DB, *chi.Mux, error){
    dbHost := "localhost"
    dbPort := "5432"
    dbName := "bookings"
    dbUser := "orololuwa"
    dbPassword := ""
    dbSSL := "disable"

    // Connecto to DB
    log.Println("Connecting to dabase")
    connectionString := fmt.Sprintf("host=%s port=%s dbname=%s user=%s password=%s sslmode=%s", dbHost, dbPort, dbName, dbUser, dbPassword, dbSSL)

    db, err := driver.ConnectSQL(connectionString)
    if err != nil {
        log.Fatal("Cannot conect to database: Dying!", err)
    }
    log.Println("Connected to database")
+   userRepo := repository.NewUserRepo(db.SQL)
+   router := chi.NewRouter()
+
+   router.Post("/user", func(w http.ResponseWriter, r *http.Request) {
+       type userBody struct {
+           FirstName string `json:"firstName"`
+           LastName string `json:"lastName"`
+           Email string `json:"email"`
+           Password string `json:"password"`
+       }
+
+       var body userBody
+       
+       err := json.NewDecoder(r.Body).Decode(&body)
+       if err != nil {
+           w.Header().Set("Content-Type", "application/json")
+           +w.WriteHeader(http.StatusInternalServerError)
+           return
+       }
+
+       user := models.User{
+           FirstName: body.FirstName,
+           LastName: body.LastName,
+           Email: body.Email,
+           Password: body.Password,
+       }
+       
+       id, err := userRepo.CreateAUser(user)
+       if err != nil {
+           w.Header().Set("Content-Type", "application/json")
+           +w.WriteHeader(http.StatusInternalServerError)
+           return
+       }
+
+       response := map[string]interface{}{"message": "user created successfully", "data": id}
+       jsonResponse, err := json.Marshal(response)
+       if err != nil {
+           http.Error(w, "Failed to marshal response", http.StatusInternalServerError)
+           return


+       }
+       w.Header().Set("Content-Type", "application/json")
+       w.WriteHeader(http.StatusOK)
+       w.Write(jsonResponse)
+   })
+
-   return db, nil
+   return db, router, nil
}








package repository

import (
+   "context"
+   "database/sql"
+
    "github.com/orololuwa/crispy-octo-guacamole/models"
)

type UserRepo interface {
    CreateAUser(user models.User) (int, error)
    GetAUser(id int) (models.User, error)
    GetAllUser() ([]models.User, error)
    UpdateAUsersName(id int, firstName, lastName string)(error)
    DeleteUserByID(id int) error
}

+type DBRepo interface {
+   Transaction(ctx context.Context, operation func(context.Context, *sql.Tx) error) error 
+}


package repository

import (
    "context"
    "database/sql"
)

type dbRepo struct {
    DB *sql.DB
}

func NewDBRepo(conn *sql.DB) DBRepo {
    return &dbRepo{
        DB: conn,
    }
}

func (m *dbRepo) Transaction(ctx context.Context, operation func(context.Context, *sql.Tx) error) error {
    tx, err := m.DB.BeginTx(ctx, nil)
    if err != nil {
        return err
    }

    defer func() error{
        if err != nil {
            tx.Rollback()
            return err
        }

        if err := tx.Commit(); err != nil {
            return err
        }

        return nil
    }()

    if err := operation(ctx, tx); err != nil {
        return err
    }

    return nil
}




package repository

import (
    "context"
    "database/sql"

    "github.com/orololuwa/crispy-octo-guacamole/models"
)

type UserRepo interface {
-   CreateAUser(user models.User) (int, error)
-   GetAUser(id int) (models.User, error)
-   GetAllUser() ([]models.User, error)
-   UpdateAUsersName(id int, firstName, lastName string)(error)
-   DeleteUserByID(id int) error
+   CreateAUser(ctx context.Context, tx *sql.Tx, user models.User) (int, error)
+   GetAUser(ctx context.Context, tx *sql.Tx, id int) (models.User, error)
+   GetAllUser(ctx context.Context, tx *sql.Tx) ([]models.User, error)
+   UpdateAUsersName(ctx context.Context, tx *sql.Tx, id int, firstName, lastName string)(error)
+   DeleteUserByID(ctx context.Context, tx *sql.Tx, id int) error
}

type DBRepo interface {
    Transaction(ctx context.Context, operation func(context.Context, *sql.Tx) error) error 
}


-func (m *user) CreateAUser(user models.User) (int, error){
-   ctx, cancel := context.WithTimeout(context.Background(), 3*time.Second)
+func (m *user) CreateAUser(ctx context.Context, tx *sql.Tx, user models.User) (int, error){
+   ctx, cancel := context.WithTimeout(ctx, 3*time.Second)
    defer cancel()

    var newId int

    query := `
            INSERT into users 
                (first_name, last_name, email, password, created_at, updated_at)
            values 
                ($1, $2, $3, $4, $5, $6)
            returning id`

-   err := m.DB.QueryRowContext(ctx, query, 
+   var err error;
+   if tx != nil {
+       err = tx.QueryRowContext(ctx, query, 
+           user.FirstName, 
+           user.LastName, 
+           user.Email, 
+           user.Password,
+           time.Now(),
+           time.Now(),
+       ).Scan(&newId)
+   }else{
        err = m.DB.QueryRowContext(ctx, query, 
            user.FirstName, 
            user.LastName, 
            user.Email, 
            user.Password,
            time.Now(),
            time.Now(),
        ).Scan(&newId)
+   }



package repository

import (
    "context"
    "database/sql"
    "time"

    "github.com/orololuwa/crispy-octo-guacamole/models"
)

type user struct {
    DB *sql.DB
}

func NewUserRepo(conn *sql.DB) UserRepo {
    return &user{
        DB: conn,
    }
}

func (m *user) CreateAUser(ctx context.Context, tx *sql.Tx, user models.User) (int, error){
    ctx, cancel := context.WithTimeout(ctx, 3*time.Second)
    defer cancel()

    var newId int

    query := `
            INSERT into users 
                (first_name, last_name, email, password, created_at, updated_at)
            values 
                ($1, $2, $3, $4, $5, $6)
            returning id`

    var err error;
    if tx != nil {
        err = tx.QueryRowContext(ctx, query, 
            user.FirstName, 
            user.LastName, 
            user.Email, 
            user.Password,
            time.Now(),
            time.Now(),
        ).Scan(&newId)
    }else{
        err = m.DB.QueryRowContext(ctx, query, 
            user.FirstName, 
            user.LastName, 
            user.Email, 
            user.Password,
            time.Now(),
            time.Now(),
        ).Scan(&newId)
    }

    if err != nil {
        return 0, err
    }

    return newId, nil
}

func (m *user) GetAUser(ctx context.Context, tx *sql.Tx, id int) (models.User, error){
    ctx, cancel := context.WithTimeout(ctx, 3*time.Second)
    defer cancel()

    var user models.User

    query := `
            SELECT (id, first_name, last_name, email, password, created_at, updated_at)
            from users
            WHERE
            id=$1
    `

    var err error
    if tx != nil {
        err = tx.QueryRowContext(ctx, query, id).Scan(
            &user.ID,
            &user.FirstName,
            &user.LastName,
            &user.Email,
            &user.Password,
            &user.CreatedAt,
            &user.UpdatedAt,
        )
    }else{
        err = m.DB.QueryRowContext(ctx, query, id).Scan(
            &user.ID,
            &user.FirstName,
            &user.LastName,
            &user.Email,
            &user.Password,
            &user.CreatedAt,
            &user.UpdatedAt,
        )
    }

    if err != nil {
        return user, err
    }

    return user, nil
}

func (m *user) GetAllUser(ctx context.Context, tx *sql.Tx) ([]models.User, error){
    ctx, cancel := context.WithTimeout(ctx, 3*time.Second)
    defer cancel()

    var users = make([]models.User, 0)

    query := `
        SELECT (id, first_name, last_name, email, password, created_at, updated_at)
        from users
    `

    var rows *sql.Rows
    var err error

    if tx != nil {
        rows, err = tx.QueryContext(ctx, query)
    }else{
        rows, err = m.DB.QueryContext(ctx, query)
    }
    if err != nil {
        return users, err
    }

    for rows.Next(){
        var user models.User
        err := rows.Scan(
            &user.ID,
            &user.FirstName,
            &user.LastName,
            &user.Email,
            &user.Password,
            &user.CreatedAt,
            &user.UpdatedAt,
        )
        if err != nil {
            return users, err
        }
        users = append(users, user)
    }

    if err = rows.Err(); err != nil {
        return users, err
    }

    return users, nil
}

func (m *user) UpdateAUsersName(ctx context.Context, tx *sql.Tx, id int, firstName, lastName string)(error){
    ctx, cancel := context.WithTimeout(ctx, 3*time.Second)
    defer cancel()

    query := `
        UPDATE 
            users set (first_name, last_name) = ($1, $2)
        WHERE
            id = $3
    `

    var err error
    if tx != nil{
        _, err = tx.ExecContext(ctx, query, firstName, lastName, id)
    }else{
        _, err = m.DB.ExecContext(ctx, query, firstName, lastName, id)
    }

    if err != nil{
        return  err
    }

    return nil
}

func (m *user) DeleteUserByID(ctx context.Context, tx *sql.Tx, id int) error {
    ctx, cancel := context.WithTimeout(ctx, 3*time.Second)
    defer cancel()

    query := "DELETE FROM users WHERE id = $1"

    var err error 

    if tx != nil {
        _, err = tx.ExecContext(ctx, query, id)
    }else{
        _, err = m.DB.ExecContext(ctx, query, id)
    }

    if err != nil {
        return err
    }

    return nil
}



package main

import (
+   "context"
+   "database/sql"
    "encoding/json"
    "fmt"
    "log"
    "net/http"

    "github.com/go-chi/chi/v5"
    "github.com/orololuwa/crispy-octo-guacamole/driver"
    "github.com/orololuwa/crispy-octo-guacamole/models"
    "github.com/orololuwa/crispy-octo-guacamole/repository"
)
const portNumber = ":8080"

func main(){
    db, route, err := run()
    if (err != nil){
        log.Fatal(err)
    }
    defer db.SQL.Close()

    fmt.Println(fmt.Sprintf("Staring application on port %s", portNumber))


    srv := &http.Server{
        Addr: portNumber,
        Handler: route,
    }

    err = srv.ListenAndServe()
    if err != nil {
        log.Fatal(err)
    }
}

func run()(*driver.DB, *chi.Mux, error){
    dbHost := "localhost"
    dbPort := "5432"
    dbName := "bookings"
    dbUser := "orololuwa"
    dbPassword := ""
    dbSSL := "disable"

    // Connecto to DB
    log.Println("Connecting to dabase")
    connectionString := fmt.Sprintf("host=%s port=%s dbname=%s user=%s password=%s sslmode=%s", dbHost, dbPort, dbName, dbUser, dbPassword, dbSSL)

    db, err := driver.ConnectSQL(connectionString)
    if err != nil {
        log.Fatal("Cannot conect to database: Dying!", err)
    }
    log.Println("Connected to database")

    userRepo := repository.NewUserRepo(db.SQL)
    dbRepo := repository.NewDBRepo(db.SQL)
    router := chi.NewRouter()

    router.Post("/user", func(w http.ResponseWriter, r *http.Request) {
        type userBody struct {
            FirstName string `json:"firstName"`
            LastName string `json:"lastName"`
            Email string `json:"email"`
            Password string `json:"password"`
        }

        var body userBody

        err := json.NewDecoder(r.Body).Decode(&body)
        if err != nil {
            w.Header().Set("Content-Type", "application/json")
            w.WriteHeader(http.StatusInternalServerError)
            return
        }

        user := models.User{
            FirstName: body.FirstName,
            LastName: body.LastName,
            Email: body.Email,
            Password: body.Password,
        }

-       id, err := userRepo.CreateAUser(user)
+       ctx := context.Background()
+       var id int

+       err = dbRepo.Transaction(ctx, func(ctx context.Context, tx *sql.Tx) error {
+           id, err = userRepo.CreateAUser(ctx, tx, user)
+           if err != nil {
+               return err
+           }
+
+           userRepo.UpdateAUsersName(ctx, tx, id, body.FirstName, "test")
+           if err != nil {
+               return err
+           }
+
+           return nil
+       })
+       
        if err != nil {
            w.Header().Set("Content-Type", "application/json")
            w.WriteHeader(http.StatusInternalServerError)
            return
        }

        response := map[string]interface{}{"message": "user created successfully", "data": id}
        jsonResponse, err := json.Marshal(response)
        if err != nil {
            http.Error(w, "Failed to marshal response", http.StatusInternalServerError)
            return
        }
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(http.StatusOK)
        w.Write(jsonResponse)
    })

    return db, router, nil
}


https://github.com/Orololuwa/crispy-octo-guacamole



handlers
	handlers/middlewares.go
	handlers/routes.go
	handlers/task_handler.go
models
	models/task_model.go
entities
	entities/task.go
helpers
	helpers/hateoas.go
	
	
entities/task.go
	
	package entities

type Task struct {
	TaskId    	int
	UserId    	int
	TaskName  	string
	StartDate 	string
	EndDate		string
}

	
	handlers/task_handler.go
package handlers

import (
	"encoding/json"
	"fmt"
	"net/http"

	"github.com/ortizdavid/go-nopain/conversion"
	"github.com/ortizdavid/go-rest-concepts/entities"
	"github.com/ortizdavid/go-nopain/httputils"
	"github.com/ortizdavid/go-rest-concepts/models"
)

type TaskHandler struct {
}


func (th TaskHandler) Routes(router *http.ServeMux) {
	router.HandleFunc("GET /tasks", th.getAllTasks)
	router.HandleFunc("GET /tasks/{id}", th.getTask)
	router.HandleFunc("POST /tasks", th.createTask)
	router.HandleFunc("PUT /tasks/{id}", th.updateTask)
	router.HandleFunc("DELETE /tasks/{id}", th.deleteTask)
	router.HandleFunc("POST /tasks/create-default", th.createDefaultTasks)

	router.HandleFunc("GET /tasks-xml", th.getAllTasksXml)
	router.HandleFunc("GET /tasks-xml/{id}", th.getTaskXml)
	
	router.Handle("GET /protected-apikey", ApiKeyAuthMiddleware(http.HandlerFunc(th.protectedApiKey)))
}


func (th TaskHandler) getAllTasks(w http.ResponseWriter, r *http.Request) {
	var taskModel models.TaskModel
	tasks, err := taskModel.FindAll()
	count := len(tasks)
	if err != nil {
		httputils.WriteJsonError(w, err.Error(), http.StatusInternalServerError)
		return
	}
	if count == 0 {
		httputils.WriteJsonError(w, "Tasks not found", http.StatusNotFound)
		return
	}
	httputils.WriteJson(w, http.StatusOK, tasks, count)
}


func (th TaskHandler) getTask(w http.ResponseWriter, r *http.Request) {
	var taskModel models.TaskModel
	rawId := r.PathValue("id")
	id := conversion.StringToInt(rawId)
	task, err := taskModel.FindById(id)

	if err != nil {
		httputils.WriteJsonError(w, err.Error(), http.StatusInternalServerError)
		return
	}
	if !taskModel.ExistsById(id) {
		httputils.WriteJsonError(w, "Task with id: "+rawId+" not exists", http.StatusNotFound)
		return
	}
	httputils.WriteJsonSimple(w, http.StatusOK, task)
}


func (th TaskHandler) createTask(w http.ResponseWriter, r *http.Request) {
	var taskModel models.TaskModel
	var newTask entities.Task

	if err := json.NewDecoder(r.Body).Decode(&newTask); err != nil {
		httputils.WriteJsonError(w, err.Error(), http.StatusInternalServerError)
		return
	}
	if err := taskModel.Create(newTask); err != nil {
		httputils.WriteJsonError(w, err.Error(), http.StatusInternalServerError)
		return
	}
	httputils.WriteJsonSimple(w, http.StatusCreated, newTask)
}


func (th TaskHandler) updateTask(w http.ResponseWriter, r *http.Request) {
	fmt.Fprintf(w, "Update a task")
}


func (th TaskHandler) deleteTask(w http.ResponseWriter, r *http.Request) {
	fmt.Fprintf(w, "Delete a task")
}


func (th TaskHandler) createDefaultTasks(w http.ResponseWriter, r *http.Request) {
	var taskModel models.TaskModel
	count, _ := taskModel.CreateDefault()
	httputils.WriteJson(w, http.StatusCreated, nil, count)
}


func (th TaskHandler) protectedApiKey(w http.ResponseWriter, r *http.Request) {
	fmt.Fprintf(w, "Accessed API Key Resource")
}


func (th TaskHandler) getAllTasksXml(w http.ResponseWriter, r *http.Request) {
	var taskModel models.TaskModel
	tasks, err := taskModel.FindAll()
	count := len(tasks)
	if err != nil {
		httputils.WriteXmlError(w, err.Error(), http.StatusInternalServerError)
		return
	}
	if count == 0 {
		httputils.WriteXmlError(w, "Tasks not found", http.StatusNotFound)
		return
	}
	httputils.WriteXml(w, http.StatusOK, tasks, count)
}


func (th TaskHandler) getTaskXml(w http.ResponseWriter, r *http.Request) {
	var taskModel models.TaskModel
	rawId := r.PathValue("id")
	id := conversion.StringToInt(rawId)
	task, err := taskModel.FindById(id)

	if err != nil {
		httputils.WriteXmlError(w, err.Error(), http.StatusInternalServerError)
		return
	}
	if !taskModel.ExistsById(id) {
		httputils.WriteXmlError(w, "Task with id: "+rawId+" not exists", http.StatusNotFound)
		return
	}
	httputils.WriteXmlSimple(w, http.StatusOK, task)
}
	
	handlers/routes.go
	
	package handlers

import "net/http"

func RegisterRoutes(router* http.ServeMux) {
	TaskHandler{}.Routes(router)
}
	
	
	
	handlers/middlewares.go
	
package handlers

import (
	"fmt"
	"net/http"
)


const (
	DEFAULT_TOKEN = "token12345"
	DEFAULT_API_KEY = "key12345"
)


// Token Based Authentication
func TokenAuthMiddleware(next http.Handler) http.Handler {
	validToken := DEFAULT_TOKEN
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		token := r.Header.Get("Authorization")
		if token == "" {
			w.WriteHeader(http.StatusUnauthorized)
			fmt.Fprintf(w, "Unauthoried. Token missing")
			return
		}
		if token != validToken {
			w.WriteHeader(http.StatusUnauthorized)
			fmt.Fprintf(w, "Unauthorized. Invalid Token")
			return
		}
		next.ServeHTTP(w, r)
	})
}


// API KEY Authentication
func ApiKeyAuthMiddleware(next http.Handler) http.Handler {
	validApiKey := DEFAULT_API_KEY
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		apiKey := r.Header.Get("X-API-Key")
		if apiKey == "" {
			w.WriteHeader(http.StatusUnauthorized)
			fmt.Fprintf(w, "Unauthoried. API Key missing")
			return
		}
		if apiKey != validApiKey {
			w.WriteHeader(http.StatusUnauthorized)
			fmt.Fprintf(w, "Unauthorized. Invalid API Key")
			return
		}
		next.ServeHTTP(w, r)
	})
}


// JWT Authentication
func JwtAuthMiddleWare(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		next.ServeHTTP(w, r)
	})
}


func AuthorizationMiddleware(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request)  {
		next.ServeHTTP(w, r)
	})
}


package main

import (
    "github.com/jinzhu/gorm"
)

type UsuarioCarteiraCripto struct {
    gorm.Model
    ID            int     `gorm:"primary_key;auto_increment"`
    IDCarteira    int     `gorm:"type:int;not null;index"`
    IDCripto      int     `gorm:"type:int;not null;index"`
    Quant         *int    `gorm:"type:int"`
    VLRPrecoMedio *float64 `gorm:"type:decimal(20,10)"`
    VLRPrecoTeto  *float64 `gorm:"type:decimal(17,2)"`
    PercentBalac  *float64 `gorm:"type:decimal(17,2)"`
    NotaBalac     *int    `gorm:"type:int"`
    Situacao      string `gorm:"type:varchar(1);not null;index"`
}

func (u *UsuarioCarteiraCripto) SituacaoDescr() string {
    switch u.Situacao {
    case "A":
        return "Ativo"
    case "I":
        return "Inativo"
    case "F":
        return "Finalizado"
    default:
        return "Desconhecido"
    }
}



go get github.com/influxdata/influxdb-client-go/v2



package main

import (
    "context"
    "fmt"
    "time"

    "github.com/influxdata/influxdb-client-go/v2"
)

func main() {
    // Create a new client using an InfluxDB server base URL and an authentication token
    client := influxdb2.NewClient("http://localhost:8086", "my-token")
    // Use blocking write client for writes to desired bucket
    writeAPI := client.WriteAPIBlocking("my-org", "my-bucket")
    // Create point using full params constructor
    p := influxdb2.NewPoint("stat",
        map[string]string{"unit": "temperature"},
        map[string]interface{}{"avg": 24.5, "max": 45.0},
        time.Now())
    // write point immediately
    writeAPI.WritePoint(context.Background(), p)
    // Create point using fluent style
    p = influxdb2.NewPointWithMeasurement("stat").
        AddTag("unit", "temperature").
        AddField("avg", 23.2).
        AddField("max", 45.0).
        SetTime(time.Now())
    err := writeAPI.WritePoint(context.Background(), p)
	if err != nil {
		panic(err)
	}
    // Or write directly line protocol
    line := fmt.Sprintf("stat,unit=temperature avg=%f,max=%f", 23.5, 45.0)
    err = writeAPI.WriteRecord(context.Background(), line)
	if err != nil {
		panic(err)
	}

    // Get query client
    queryAPI := client.QueryAPI("my-org")
    // Get parser flux query result
    result, err := queryAPI.Query(context.Background(), `from(bucket:"my-bucket")|> range(start: -1h) |> filter(fn: (r) => r._measurement == "stat")`)
    if err == nil {
        // Use Next() to iterate over query result lines
        for result.Next() {
            // Observe when there is new grouping key producing new table
            if result.TableChanged() {
                fmt.Printf("table: %s\n", result.TableMetadata().String())
            }
            // read result
            fmt.Printf("row: %s\n", result.Record().String())
        }
        if result.Err() != nil {
            fmt.Printf("Query error: %s\n", result.Err().Error())
        }
    } else {
		panic(err)
    }
    // Ensures background processes finishes
    client.Close()
}


client := influxdb2.NewClientWithOptions("http://localhost:8086", "my-token",
    influxdb2.DefaultOptions().
        SetUseGZip(true).
        SetTLSConfig(&tls.Config{
            InsecureSkipVerify: true,
        }))


services:
    influxdb:
        image: influxdb:2.0.7
        environment:
            DOCKER_INFLUXDB_INIT_MODE: setup
            DOCKER_INFLUXDB_INIT_USERNAME: ${INFLUXDB_USERNAME}
            DOCKER_INFLUXDB_INIT_PASSWORD: ${INFLUXDB_PASSWORD}
            DOCKER_INFLUXDB_INIT_ORG: iot
            DOCKER_INFLUXDB_INIT_BUCKET: users_business_events
            DOCKER_INFLUXDB_INIT_ADMIN_TOKEN: ${INFLUXDB_TOKEN}
        ports:
        - "8086:8086"


http://localhost:8086


go get github.com/influxdata/influxdb-client-go/v2


func Test_connectToInfluxDB(t *testing.T) {

    //load environment variable from a file for test purposes
    godotenv.Load("../test_influxdb.env")

    tests := []struct {
        name string
        wantErr bool
    }{
        {
            name:    "Successful connection to InfluxDB",
            wantErr: false,
        },
    }
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            got, err := ConnectToInfluxDB()
            if (err != nil) != tt.wantErr {
                t.Errorf("ConnectToInfluxDB() error = %v, wantErr %v", err, tt.wantErr)
                return
            }
            health, err := got.Health(context.Background())
            if (err != nil) && health.Status == domain.HealthCheckStatusPass {
                t.Errorf("connectToInfluxDB() error. database not healthy")
                return
            }
            got.Close()
        })
    }
}


https://www.influxdata.com/blog/getting-started-go-influxdb/


func main() {
    bucket := "example-bucket"
    org := "example-org"
    token := "example-token"
    // Store the URL of your InfluxDB instance
    url := "https://us-west-2-1.aws.cloud2.influxdata.com"
    // Create new client with default option for server url authenticate by token
    client := influxdb2.NewClient(url, token)
    // User blocking write client for writes to desired bucket
    writeAPI := client.WriteAPIBlocking(org, bucket)
    // Create point using full params constructor
    p := influxdb2.NewPoint("stat",
        map[string]string{"unit": "temperature"},
        map[string]interface{}{"avg": 24.5, "max": 45},
        time.Now())
    // Write point immediately
    writeAPI.WritePoint(context.Background(), p)
    // Ensures background processes finishes
    client.Close()
}



package main

import (
      "context"
      "fmt"
      "time"

      "github.com/influxdata/influxdb-client-go/v2"
)

func main() {
    bucket := "DATABASE_NAME"
    org := "ignored"
    token := "DATABASE_TOKEN"
    // Store the URL of your InfluxDB instance
    url := "https://cluster-id.influxdb.io"
    // Create new client with default option for server url authenticate by token
    client := influxdb2.NewClient(url, token)
    // User blocking write client for writes to desired bucket
    writeAPI := client.WriteAPIBlocking(org, bucket)
    // Create point using full params constructor
    p := influxdb2.NewPoint("stat",
        map[string]string{"unit": "temperature"},
        map[string]interface{}{"avg": 24.5, "max": 45},
        time.Now())
    // Write point immediately
    writeAPI.WritePoint(context.Background(), p)
    // Ensures background processes finishes
    client.Close()
}




https://www.youtube.com/watch?v=F7KbVoJOZEM
https://github.com/alexgtn/go-midleware-logging




go get github.com/Graylog2/go-gelf/gelf
go get gopkg.in/Graylog2/go-gelf.v1/gelf
go get gopkg.in/Graylog2/go-gelf.v2/gelf

package main

import (
	"flag"
	"gopkg.in/Graylog2/go-gelf.v1/gelf"
	"io"
	"log"
	"os"
)

func main() {
	var graylogAddr string

	flag.StringVar(&graylogAddr, "graylog", "", "graylog server addr")
	flag.Parse()

	if graylogAddr != "" {
		gelfWriter, err := gelf.NewWriter(graylogAddr)
		if err != nil {
			log.Fatalf("gelf.NewWriter: %s", err)
		}
		// log to both stderr and graylog2
		log.SetOutput(io.MultiWriter(os.Stderr, gelfWriter))
		log.Printf("logging to stderr & graylog2@'%s'", graylogAddr)
	}

	// From here on out, any calls to log.Print* functions
	// will appear on stdout, and be sent over UDP to the
	// specified Graylog2 server.

	log.Printf("Hello gray World")

	// ...
}


go run test.go -graylog=localhost:12201




package main

import (
  "github.com/robertkowalski/graylog-golang"
)

func main() {

  g := gelf.New(gelf.Config{})

  g.Log(`{
      "version": "1.0",
      "host": "localhost",
      "timestamp": 1356262644,
      "facility": "Google Go",
      "short_message": "Hello From Golang!"
  }`)
}

g := gelf.New(gelf.Config{
  GraylogPort:     80,
  GraylogHostname: "example.com",
  Connection:      "wan",
  MaxChunkSizeWan: 42,
  MaxChunkSizeLan: 1337,
})



version: '3'
services:
# MongoDB: https://hub.docker.com/_/mongo/
  mongodb:
    image: mongo:6.0.14
    networks:
      - graylog

  opensearch:
    image: "opensearchproject/opensearch:2.12.0"
    environment:
      - "OPENSEARCH_JAVA_OPTS=-Xms1g -Xmx1g"
      - "bootstrap.memory_lock=true"
      - "discovery.type=single-node"
      - "action.auto_create_index=false"
      - "plugins.security.ssl.http.enabled=false"
      - "plugins.security.disabled=true"
      # Can generate a password for `OPENSEARCH_INITIAL_ADMIN_PASSWORD` using a linux device via:
      # tr -dc A-Z-a-z-0-9_@#%^-_=+ < /dev/urandom  | head -c${1:-32}
      - OPENSEARCH_INITIAL_ADMIN_PASSWORD=+_8r#wliY3Pv5-HMIf4qzXImYzZf-M=M
    ulimits:
      memlock:
        hard: -1
        soft: -1
      nofile:
        soft: 65536
        hard: 65536
    restart: "on-failure"
    networks:
        - graylog

  # Graylog: https://hub.docker.com/r/graylog/graylog/
  graylog:
    image: graylog/graylog:5.2
    environment:
    - GRAYLOG_NODE_ID_FILE=/usr/share/graylog/data/config/node-id
    - GRAYLOG_HTTP_BIND_ADDRESS=0.0.0.0:9000
    - GRAYLOG_ELASTICSEARCH_HOSTS=http://opensearch:9200
    - GRAYLOG_MONGODB_URI=mongodb://mongodb:27017/graylog
    # CHANGE ME (must be at least 16 characters)!
    - GRAYLOG_PASSWORD_SECRET=somepasswordpepper
    # Password: admin
    - GRAYLOG_ROOT_PASSWORD_SHA2=8c6976e5b5410415bde908bd4dee15dfb167a9c873fc4bb8a81f6f2ab448a918
    - GRAYLOG_HTTP_EXTERNAL_URI=http://127.0.0.1:9000/
    entrypoint: /usr/bin/tini -- wait-for-it elasticsearch:9200 --  /docker-entrypoint.sh
    networks:
      - graylog
    restart: always
    depends_on:
      - mongodb
      - opensearch
    ports:
      # Graylog web interface and REST API
      - 9000:9000
      # Syslog TCP
      - 1514:1514
      # Syslog UDP
      - 1514:1514/udp
      # GELF TCP
      - 12201:12201
      # GELF UDP
      - 12201:12201/udp

networks:
  graylog:
    driver: bridge




package main

import (
	"fmt"
	"github.com/alexgtn/go-midleware-logging/log"
	"github.com/alexgtn/go-midleware-logging/middleware"
	"github.com/gorilla/mux"
	"net"
	"net/http"
)

func main() {
	r := mux.NewRouter()

	conn, err := net.Dial("tcp", "localhost:5555")
	if err != nil {
		fmt.Errorf("error: %s", err.Error())
		return
	}

	logger := log.NewGraylogLogger(conn)
	//logger := logrus.New()
	loggingMiddleware := middleware.NewLoggingMiddleware(logger)
	r.HandleFunc("/lemon", lemonHandler).Methods(http.MethodGet)
	r.HandleFunc("/potato", potatoHandler).Methods(http.MethodPost)
	r.Use(loggingMiddleware.Logging)

	http.ListenAndServe(":8080", r)
}

func lemonHandler(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(200)
	w.Write([]byte("Lemon"))
}

func potatoHandler(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(200)
	w.Write([]byte("Potato"))
}



package middleware

import (
	"bufio"
	"errors"
	"net"
	"net/http"
)

type LoggingMiddleware struct {
	logger logger
}

func NewLoggingMiddleware(l logger) *LoggingMiddleware {
	return &LoggingMiddleware{
		logger: l,
	}
}

type logger interface {
	Infof(format string, args ...interface{})
}

// Logging middleware to log http requests
func (lm *LoggingMiddleware) Logging(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {

		wi := &responseWriterInterceptor{
			statusCode:     http.StatusOK,
			ResponseWriter: w,
		}
		//lm.logger.Infof("%s %s", r.Method, r.RequestURI)
		next.ServeHTTP(wi, r)

		lm.logger.Infof("%s %s %d", r.Method, r.RequestURI, wi.statusCode)
	})
}

// responseWriterInterceptor is a simple wrapper to intercept set data on a
// ResponseWriter.
type responseWriterInterceptor struct {
	http.ResponseWriter
	statusCode int
}

func (w *responseWriterInterceptor) WriteHeader(statusCode int) {
	w.statusCode = statusCode
	w.ResponseWriter.WriteHeader(statusCode)
}

func (w *responseWriterInterceptor) Write(p []byte) (int, error) {
	return w.ResponseWriter.Write(p)
}

func (w *responseWriterInterceptor) Hijack() (net.Conn, *bufio.ReadWriter, error) {
	h, ok := w.ResponseWriter.(http.Hijacker)
	if !ok {
		return nil, nil, errors.New("type assertion failed http.ResponseWriter not a http.Hijacker")
	}
	return h.Hijack()
}

func (w *responseWriterInterceptor) Flush() {
	f, ok := w.ResponseWriter.(http.Flusher)
	if !ok {
		return
	}

	f.Flush()
}




package log

import (
	"fmt"
	"net"
)

type GrayLogLogger struct {
	conn net.Conn
}

func NewGraylogLogger(tcpConn net.Conn) *GrayLogLogger {
	return &GrayLogLogger{
		conn: tcpConn,
	}
}

func (l *GrayLogLogger) Infof(format string, args ...interface{})  {
	l.conn.Write([]byte(fmt.Sprintf(format, args...) + "\n"))
}


version: '3'
services:
  # MongoDB: https://hub.docker.com/_/mongo/
  mongo:
    image: mongo:4.2
    networks:
      - graylog
  # Elasticsearch: https://www.elastic.co/guide/en/elasticsearch/reference/7.10/docker.html
  elasticsearch:
    image: docker.elastic.co/elasticsearch/elasticsearch-oss:7.10.2
    environment:
      - http.host=0.0.0.0
      - transport.host=localhost
      - network.host=0.0.0.0
      - "ES_JAVA_OPTS=-Xms512m -Xmx512m"
    ulimits:
      memlock:
        soft: -1
        hard: -1
    deploy:
      resources:
        limits:
          memory: 1g
    networks:
      - graylog
  # Graylog: https://hub.docker.com/r/graylog/graylog/
  graylog:
    image: graylog/graylog:4.0
    environment:
      # CHANGE ME (must be at least 16 characters)!
      - GRAYLOG_PASSWORD_SECRET=somepasswordpepper
      # Password: admin
      - GRAYLOG_ROOT_PASSWORD_SHA2=8c6976e5b5410415bde908bd4dee15dfb167a9c873fc4bb8a81f6f2ab448a918
      - GRAYLOG_HTTP_EXTERNAL_URI=http://127.0.0.1:9000/
    entrypoint: /usr/bin/tini -- wait-for-it elasticsearch:9200 --  /docker-entrypoint.sh
    networks:
      - graylog
    restart: always
    depends_on:
      - mongo
      - elasticsearch
    ports:
      # Graylog web interface and REST API
      - 9000:9000
      # Syslog TCP
      - 1514:1514
      # Syslog UDP
      - 1514:1514/udp
      # GELF TCP
      - 12201:12201
      # GELF UDP
      - 12201:12201/udp
      # Log Input TCP
      - 5555:5555
networks:
  graylog:
    driver: bridge


module github.com/alexgtn/go-midleware-logging

go 1.16

require (
	github.com/gorilla/mux v1.8.0
	github.com/sirupsen/logrus v1.8.1 // indirect
)










---
version: "3"

networks:
  loki:

services:
  read:
    image: grafana/loki:2.9.2
    command: "-config.file=/etc/loki/config.yaml -target=read"
    ports:
      - 3101:3100
      - 7946
      - 9095
    volumes:
      - ./loki-config.yaml:/etc/loki/config.yaml
    depends_on:
      - minio
    healthcheck:
      test: [ "CMD-SHELL", "wget --no-verbose --tries=1 --spider http://localhost:3100/ready || exit 1" ]
      interval: 10s
      timeout: 5s
      retries: 5
    networks: &loki-dns
      loki:
        aliases:
          - loki

  write:
    image: grafana/loki:2.9.2
    command: "-config.file=/etc/loki/config.yaml -target=write"
    ports:
      - 3102:3100
      - 7946
      - 9095
    volumes:
      - ./loki-config.yaml:/etc/loki/config.yaml
    healthcheck:
      test: [ "CMD-SHELL", "wget --no-verbose --tries=1 --spider http://localhost:3100/ready || exit 1" ]
      interval: 10s
      timeout: 5s
      retries: 5
    depends_on:
      - minio
    networks:
      <<: *loki-dns

  promtail:
    image: grafana/promtail:2.9.2
    volumes:
      - ./promtail-local-config.yaml:/etc/promtail/config.yaml:ro
      - /var/run/docker.sock:/var/run/docker.sock
    command: -config.file=/etc/promtail/config.yaml
    depends_on:
      - gateway
    networks:
      - loki

  minio:
    image: minio/minio
    entrypoint:
      - sh
      - -euc
      - |
        mkdir -p /data/loki-data && \
        mkdir -p /data/loki-ruler && \
        minio server /data
    environment:
      - MINIO_ROOT_USER=loki
      - MINIO_ROOT_PASSWORD=supersecret
      - MINIO_PROMETHEUS_AUTH_TYPE=public
      - MINIO_UPDATE=off
    ports:
      - 9000
    volumes:
      - ./.data/minio:/data
    healthcheck:
      test: [ "CMD", "curl", "-f", "http://localhost:9000/minio/health/live" ]
      interval: 15s
      timeout: 20s
      retries: 5
    networks:
      - loki

  grafana:
    image: grafana/grafana:latest
    environment:
      - GF_PATHS_PROVISIONING=/etc/grafana/provisioning
      - GF_AUTH_ANONYMOUS_ENABLED=true
      - GF_AUTH_ANONYMOUS_ORG_ROLE=Admin
    depends_on:
      - gateway
    entrypoint:
      - sh
      - -euc
      - |
        mkdir -p /etc/grafana/provisioning/datasources
        cat <<EOF > /etc/grafana/provisioning/datasources/ds.yaml
        apiVersion: 1
        datasources:
          - name: Loki
            type: loki
            access: proxy
            url: http://gateway:3100
            jsonData:
              httpHeaderName1: "X-Scope-OrgID"
            secureJsonData:
              httpHeaderValue1: "tenant1"
        EOF
        /run.sh
    ports:
      - "3000:3000"
    healthcheck:
      test: [ "CMD-SHELL", "wget --no-verbose --tries=1 --spider http://localhost:3000/api/health || exit 1" ]
      interval: 10s
      timeout: 5s
      retries: 5
    networks:
      - loki

  gateway:
    image: nginx:latest
    depends_on:
      - read
      - write
    entrypoint:
      - sh
      - -euc
      - |
        cat <<EOF > /etc/nginx/nginx.conf
        user  nginx;
        worker_processes  5;  ## Default: 1

        events {
          worker_connections   1000;
        }

        http {
          resolver 127.0.0.11;

          server {
            listen             3100;

            location = / {
              return 200 'OK';
              auth_basic off;
            }

            location = /api/prom/push {
              proxy_pass       http://write:3100\$$request_uri;
            }

            location = /api/prom/tail {
              proxy_pass       http://read:3100\$$request_uri;
              proxy_set_header Upgrade \$$http_upgrade;
              proxy_set_header Connection "upgrade";
            }

            location ~ /api/prom/.* {
              proxy_pass       http://read:3100\$$request_uri;
            }

            location = /loki/api/v1/push {
              proxy_pass       http://write:3100\$$request_uri;
            }

            location = /loki/api/v1/tail {
              proxy_pass       http://read:3100\$$request_uri;
              proxy_set_header Upgrade \$$http_upgrade;
              proxy_set_header Connection "upgrade";
            }

            location ~ /loki/api/.* {
              proxy_pass       http://read:3100\$$request_uri;
            }
          }
        }
        EOF
        /docker-entrypoint.sh nginx -g "daemon off;"
    ports:
      - "3100:3100"
    healthcheck:
      test: ["CMD", "service", "nginx", "status"]
      interval: 10s
      timeout: 5s
      retries: 5
    networks:
      - loki

  flog:
    image: mingrammer/flog
    command: -f json -d 200ms -l
    networks:
      - loki




examples/getting-started/loki-config.yaml
---
server:
  http_listen_port: 3100
memberlist:
  join_members:
    - loki:7946
schema_config:
  configs:
    - from: 2021-08-01
      store: tsdb
      object_store: s3
      schema: v13
      index:
        prefix: index_
        period: 24h
common:
  path_prefix: /loki
  replication_factor: 1
  storage:
    s3:
      endpoint: minio:9000
      insecure: true
      bucketnames: loki-data
      access_key_id: loki
      secret_access_key: supersecret
      s3forcepathstyle: true
  ring:
    kvstore:
      store: memberlist
ruler:
  storage:
    s3:
      bucketnames: loki-ruler




go get github.com/grafana/loki





version: "3"

networks:
  loki:

services:
  loki:
    image: grafana/loki:2.9.0
    ports:
      - "3100:3100"
    command: -config.file=/etc/loki/local-config.yaml
    networks:
      - loki

  promtail:
    image: grafana/promtail:2.9.0
    volumes:
      - /var/log:/var/log
    command: -config.file=/etc/promtail/config.yml
    networks:
      - loki

  grafana:
    environment:
      - GF_PATHS_PROVISIONING=/etc/grafana/provisioning
      - GF_AUTH_ANONYMOUS_ENABLED=true
      - GF_AUTH_ANONYMOUS_ORG_ROLE=Admin
    entrypoint:
      - sh
      - -euc
      - |
        mkdir -p /etc/grafana/provisioning/datasources
        cat <<EOF > /etc/grafana/provisioning/datasources/ds.yaml
        apiVersion: 1
        datasources:
        - name: Loki
          type: loki
          access: proxy
          orgId: 1
          url: http://loki:3100
          basicAuth: false
          isDefault: true
          version: 1
          editable: false
        EOF
        /run.sh
    image: grafana/grafana:latest
    ports:
      - "3000:3000"
    networks:
      - loki





version: '3.4'

networks:
  app:

services:
  nginx-app:
    container_name: nginx-app
    image: nginx
    labels:
      logging: "promtail"
      logging_jobname: "containerlogs"
    ports:
      - 8080:80
    networks:
      - app

  grafana:
    image: grafana/grafana:latest
    ports:
      - 3000:3000
    volumes:
      - ./config/grafana-datasources.yml:/etc/grafana/provisioning/datasources/datasources.yaml
    environment:
      - GF_AUTH_ANONYMOUS_ENABLED=true
      - GF_AUTH_ANONYMOUS_ORG_ROLE=Admin
      - GF_AUTH_DISABLE_LOGIN_FORM=true
    networks:
      - app

  loki:
    image: grafana/loki:latest
    ports:
      - 3100:3100
    command: -config.file=/etc/loki/local-config.yaml
    networks:
      - app

  promtail:
    image:  grafana/promtail:latest
    container_name: promtail
    volumes:
      - ./config/promtail.yaml:/etc/promtail/docker-config.yaml
      - /var/lib/docker/containers:/var/lib/docker/containers:ro
      - /var/run/docker.sock:/var/run/docker.sock
    command: -config.file=/etc/promtail/docker-config.yaml
    depends_on:
      - loki
    networks:
      - app


File grafana-datasources.yml:

apiVersion: 1

datasources:
  - name: Loki
    type: loki
    access: proxy
    url: http://loki:3100
    version: 1
    editable: false
    isDefault: true


File promtail.yaml:

server:
  http_listen_port: 9080
  grpc_listen_port: 0

positions:
  filename: /tmp/positions.yaml

clients:
  - url: http://loki:3100/loki/api/v1/push

scrape_configs:
  - job_name: flog_scrape
    docker_sd_configs:
      - host: unix:///var/run/docker.sock
        refresh_interval: 5s
        filters:
          - name: label
            values: ["logging=promtail"]
    relabel_configs:
      - source_labels: ['__meta_docker_container_name']
        regex: '/(.*)'
        target_label: 'container'
      - source_labels: ['__meta_docker_container_log_stream']
        target_label: 'logstream'
      - source_labels: ['__meta_docker_container_label_logging_jobname']
        target_label: 'job'


python-logging-loki

import logging
import logging_loki

handler = logging_loki.LokiHandler(
 url="https://my-loki-instance/loki/api/v1/push", 
 tags={"application": "my-app"},
 auth=("username", "password"),
 version="1",
)
logger = logging.getLogger("my-logger")
logger.addHandler(handler)
logger.error(
 "Something happened", 
 extra={"tags": {"service": "my-service"}},
)



package main

import (
	"context"
	"fmt"
	"math/rand"
	"net/http"
	"os"
	"time"

	"google.golang.org/grpc"

	"github.com/go-kit/kit/log"
	"github.com/gorilla/mux"
	"github.com/prometheus/client_golang/prometheus"
	"github.com/prometheus/client_golang/prometheus/promauto"
	"github.com/prometheus/client_golang/prometheus/promhttp"
	"go.opentelemetry.io/contrib/instrumentation/net/http/otelhttp"
	"go.opentelemetry.io/otel"
	"go.opentelemetry.io/otel/exporters/otlp"
	"go.opentelemetry.io/otel/exporters/otlp/otlpgrpc"
	"go.opentelemetry.io/otel/propagation"
	"go.opentelemetry.io/otel/sdk/resource"
	sdktrace "go.opentelemetry.io/otel/sdk/trace"
	"go.opentelemetry.io/otel/semconv"
	"go.opentelemetry.io/otel/trace"
)

// global vars...gasp!
var addr = "127.0.0.1:8000"
var tracer trace.Tracer
var httpClient http.Client
var logger log.Logger

var metricRequestLatency = promauto.NewHistogram(prometheus.HistogramOpts{
	Namespace: "demo",
	Name:      "request_latency_seconds",
	Help:      "Request Latency",
	Buckets:   prometheus.ExponentialBuckets(.0001, 2, 50),
})

func main() {
	flush := initTracer()
	defer flush()

	// initiate globals
	tracer = otel.Tracer("demo-app")
	httpClient = http.Client{Transport: otelhttp.NewTransport(http.DefaultTransport)}
	logger = log.NewLogfmtLogger(log.NewSyncWriter(os.Stdout))
	logger = log.With(logger, "ts", log.DefaultTimestampUTC)

	// create and start server
	server := instrumentedServer(handler)

	fmt.Println("listening...")
	server.ListenAndServe()
}

func handler(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	longRunningProcess(ctx)

	// check cache
	if shouldExecute(40) {
		url := "http://" + addr + "/"

		resp, err := instrumentedGet(ctx, url)
		defer resp.Body.Close()
		if err != nil {
			http.Error(w, err.Error(), http.StatusInternalServerError)
		}
	}

	// query database
	if shouldExecute(40) {
		url := "http://" + addr + "/"

		resp, err := instrumentedGet(ctx, url)
		defer resp.Body.Close()
		if err != nil {
			http.Error(w, err.Error(), http.StatusInternalServerError)
		}
	}
}

func shouldExecute(percent int) bool {
	return rand.Int()%100 < percent
}

func longRunningProcess(ctx context.Context) {
	ctx, sp := tracer.Start(ctx, "Long Running Process")
	defer sp.End()

	time.Sleep(time.Millisecond * 50)
	sp.AddEvent("halfway done!")
	time.Sleep(time.Millisecond * 50)
}

/***
Tracing
***/
// Initializes an OTLP exporter, and configures the trace provider
func initTracer() func() {
	ctx := context.Background()

	driver := otlpgrpc.NewDriver(
		otlpgrpc.WithInsecure(),
		otlpgrpc.WithEndpoint("tempo:55680"),
		otlpgrpc.WithDialOption(grpc.WithBlock()), // useful for testing
	)
	exp, err := otlp.NewExporter(ctx, driver)
	handleErr(err, "failed to create exporter")

	res, err := resource.New(ctx,
		resource.WithAttributes(
			// the service name used to display traces in backends
			semconv.ServiceNameKey.String("demo-service"),
		),
	)
	handleErr(err, "failed to create resource")

	bsp := sdktrace.NewBatchSpanProcessor(exp)
	tracerProvider := sdktrace.NewTracerProvider(
		sdktrace.WithConfig(sdktrace.Config{DefaultSampler: sdktrace.AlwaysSample()}),
		sdktrace.WithResource(res),
		sdktrace.WithSpanProcessor(bsp),
	)

	// set global propagator to tracecontext (the default is no-op).
	otel.SetTextMapPropagator(propagation.TraceContext{})
	otel.SetTracerProvider(tracerProvider)

	return func() {
		// Shutdown will flush any remaining spans.
		handleErr(tracerProvider.Shutdown(ctx), "failed to shutdown TracerProvider")
	}
}

/***
Server
***/
func instrumentedServer(handler http.HandlerFunc) *http.Server {
	// OpenMetrics handler : metrics and exemplars
	omHandleFunc := func(w http.ResponseWriter, r *http.Request) {
		start := time.Now()

		handler.ServeHTTP(w, r)

		ctx := r.Context()
		traceID := trace.SpanContextFromContext(ctx).TraceID.String()

		metricRequestLatency.(prometheus.ExemplarObserver).ObserveWithExemplar(
			time.Since(start).Seconds(), prometheus.Labels{"traceID": traceID},
		)

		// log the trace id with other fields so we can discover traces through logs
		logger.Log("msg", "http request", "traceID", traceID, "path", r.URL.Path, "latency", time.Since(start))
	}

	// OTel handler : traces
	otelHandler := otelhttp.NewHandler(http.HandlerFunc(omHandleFunc), "http")

	r := mux.NewRouter()
	r.Handle("/", otelHandler)
	r.Handle("/metrics", promhttp.HandlerFor(prometheus.DefaultGatherer, promhttp.HandlerOpts{
		EnableOpenMetrics: true,
	}))

	return &http.Server{
		Handler: r,
		Addr:    "0.0.0.0:8000",
	}
}

/***
Client
***/
func instrumentedGet(ctx context.Context, url string) (*http.Response, error) {
	// create http request
	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		panic(err)
	}

	return httpClient.Do(req)
}

func handleErr(err error, message string) {
	if err != nil {
		panic(fmt.Sprintf("%s: %s", err, message))
	}
}


module github.com/joe-elliott/tracing-example

go 1.14

require (
	github.com/codahale/hdrhistogram v0.0.0-20161010025455-3a0bb77429bd // indirect
	github.com/go-kit/kit v0.9.0
	github.com/gorilla/mux v1.8.0
	github.com/opentracing/opentracing-go v1.2.0
	github.com/pkg/errors v0.9.1 // indirect
	github.com/prometheus/client_golang v1.7.1
	github.com/uber/jaeger-client-go v2.25.0+incompatible
	github.com/uber/jaeger-lib v2.2.0+incompatible
	go.opentelemetry.io/contrib/instrumentation/net/http v0.11.0 // indirect
	go.opentelemetry.io/contrib/instrumentation/net/http/otelhttp v0.16.0
	go.opentelemetry.io/otel v0.16.0
	go.opentelemetry.io/otel/exporters/otlp v0.16.0
	go.opentelemetry.io/otel/sdk v0.16.0
	go.uber.org/atomic v1.6.0 // indirect
	google.golang.org/grpc v1.34.0
)


version: "3.4"
services:
  tracing-example:
    image: tracing-example
    ports:
      - 8000:8000
    logging:
      driver: loki
      options:
        loki-url: http://localhost:3100/loki/api/v1/push

  tempo:
    image: grafana/tempo:0.7.0
    command: ["--target=all", "--storage.trace.backend=local", "--storage.trace.local.path=/var/tempo", "--auth.enabled=false"]
    ports:
    - 8081:80
    logging:
      driver: loki
      options:
        loki-url: 'http://localhost:3100/api/prom/push'

  tempo-query:
    image: grafana/tempo-query:0.7.0
    environment:
    - BACKEND=tempo:80
    volumes:
    - ./etc/tempo-query.yaml:/etc/tempo-query.yaml
    ports:
    - "16686:16686"  # jaeger-ui
    depends_on:
    - tempo
    logging:
      driver: loki
      options:
        loki-url: 'http://localhost:3100/api/prom/push'

  grafana:
    image: grafana/grafana:7.3.x-exemplars
    volumes:
    - ./config/datasource.yml:/etc/grafana/provisioning/datasources/datasource.yml
    environment:
    - GF_AUTH_ANONYMOUS_ENABLED=true
    - GF_AUTH_ANONYMOUS_ORG_ROLE=Admin
    - GF_AUTH_DISABLE_LOGIN_FORM=true
    ports:
    - "3000:3000"

  loki:
    image: grafana/loki:2.2.1
    command: -config.file=/etc/loki/local-config.yaml
    ports:
    - "3100:3100"
    logging:
      driver: loki
      options:
        loki-url: 'http://localhost:3100/api/prom/push'

  prometheus:
    image: cstyan/prometheus:exemplars-64206a
    volumes:
      - ./config/prometheus.yaml:/etc/prometheus.yaml
    entrypoint:
      - /bin/prometheus
      - --config.file=/etc/prometheus.yaml
    ports:
      - "9090:9090"


config/datasource.yml


# config file version
apiVersion: 1

deleteDatasources:
  - name: loki
  - name: jaeger

datasources:
- name: loki
  type: loki
  access: proxy
  orgId: 1
  url: http://loki:3100
  basicAuth: false
  isDefault: true
  version: 1
  editable: false
  jsonData:
    derivedFields:
    - datasourceUid: tempo
      matcherRegex: traceID=(\w+)
      name: TraceID
      url: $${__value.raw}
- name: tempo
  type: tempo
  uid: tempo
  access: proxy
  url: http://tempo-query:16686
  isDefault: false
  version: 1
  editable: false
  basicAuth: false
- name: prometheus
  type: prometheus
  uid: prometheus
  access: proxy
  url: http://prometheus:9090
  isDefault: false
  version: 1
  editable: false
  basicAuth: false
  jsonData:
    httpMethod: 'GET'
    exemplarTraceIDDestination:
      name: 'traceID'
      url: 'http://localhost:3000/explore?orgId=1&left=%5B%22now-1h%22,%22now%22,%22tempo%22,%7B%22query%22:%22$${value}%22%7D%5D'


config/prometheus.yaml

global:
  scrape_interval:     15s

scrape_configs:
  - job_name: 'demo'
    static_configs:
    - targets: ['tracing-example:8000']




version: '2'

services:
    hotrod:
      image: jaegertracing/example-hotrod:latest
      ports:
        - '8080:8080'
        - '8083:8083'
      command: ["-m","prometheus","all"]
      environment:
        - JAEGER_AGENT_HOST=jaeger-agent
        - JAEGER_AGENT_PORT=6831
        - JAEGER_SAMPLER_TYPE=remote
        - JAEGER_SAMPLING_ENDPOINT=http://jaeger-agent:5778/sampling
      depends_on:
        - jaeger-agent

    jaeger-collector:
      image: jaegertracing/jaeger-collector
      command: 
        - "--cassandra.keyspace=jaeger_v1_dc1"
        - "--cassandra.servers=cassandra"
        - "--collector.zipkin.host-port=9411"
        - "--sampling.initial-sampling-probability=.5"
        - "--sampling.target-samples-per-second=.01"
      environment: 
        - SAMPLING_CONFIG_TYPE=adaptive
      ports:
        - "14269:14269"
        - "14268:14268"
        - "14250"
        - "9411:9411"
      restart: on-failure
      depends_on:
        - cassandra-schema

    jaeger-query:
      image: jaegertracing/jaeger-query
      command: ["--cassandra.keyspace=jaeger_v1_dc1", "--cassandra.servers=cassandra"]
      ports:
        - "16686:16686"
        - "16687"
      restart: on-failure
      depends_on:
        - cassandra-schema

    jaeger-agent:
      image: jaegertracing/jaeger-agent
      command: ["--reporter.grpc.host-port=jaeger-collector:14250"]
      ports:
        - "5775:5775/udp"
        - "6831:6831/udp"
        - "6832:6832/udp"
        - "5778:5778"
      restart: on-failure
      depends_on:
        - jaeger-collector

    cassandra:
      image: cassandra:4.0

    cassandra-schema:
      image: jaegertracing/jaeger-cassandra-schema
      depends_on:
        - cassandra



// Copyright (c) 2019 The Jaeger Authors.
// Copyright (c) 2017 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package main

import (
	"fmt"
	"io"
	"log"
	"os"

	"github.com/opentracing/opentracing-go"
	"github.com/spf13/cobra"
	"github.com/spf13/viper"
	jaegerClientConfig "github.com/uber/jaeger-client-go/config"
	jaegerClientZapLog "github.com/uber/jaeger-client-go/log/zap"
	_ "go.uber.org/automaxprocs"
	"go.uber.org/zap"

	agentApp "github.com/jaegertracing/jaeger/cmd/agent/app"
	agentRep "github.com/jaegertracing/jaeger/cmd/agent/app/reporter"
	agentGrpcRep "github.com/jaegertracing/jaeger/cmd/agent/app/reporter/grpc"
	"github.com/jaegertracing/jaeger/cmd/all-in-one/setupcontext"
	collectorApp "github.com/jaegertracing/jaeger/cmd/collector/app"
	collectorFlags "github.com/jaegertracing/jaeger/cmd/collector/app/flags"
	"github.com/jaegertracing/jaeger/cmd/docs"
	"github.com/jaegertracing/jaeger/cmd/env"
	"github.com/jaegertracing/jaeger/cmd/flags"
	queryApp "github.com/jaegertracing/jaeger/cmd/query/app"
	"github.com/jaegertracing/jaeger/cmd/query/app/querysvc"
	"github.com/jaegertracing/jaeger/cmd/status"
	"github.com/jaegertracing/jaeger/internal/metrics/expvar"
	"github.com/jaegertracing/jaeger/internal/metrics/fork"
	"github.com/jaegertracing/jaeger/internal/metrics/jlibadapter"
	"github.com/jaegertracing/jaeger/pkg/config"
	"github.com/jaegertracing/jaeger/pkg/metrics"
	"github.com/jaegertracing/jaeger/pkg/tenancy"
	"github.com/jaegertracing/jaeger/pkg/version"
	metricsPlugin "github.com/jaegertracing/jaeger/plugin/metrics"
	ss "github.com/jaegertracing/jaeger/plugin/sampling/strategystore"
	"github.com/jaegertracing/jaeger/plugin/storage"
	"github.com/jaegertracing/jaeger/ports"
	"github.com/jaegertracing/jaeger/storage/dependencystore"
	metricsstoreMetrics "github.com/jaegertracing/jaeger/storage/metricsstore/metrics"
	"github.com/jaegertracing/jaeger/storage/spanstore"
	storageMetrics "github.com/jaegertracing/jaeger/storage/spanstore/metrics"
)

// all-in-one/main is a standalone full-stack jaeger backend, backed by a memory store
func main() {
	setupcontext.SetAllInOne()

	svc := flags.NewService(ports.CollectorAdminHTTP)

	if os.Getenv(storage.SpanStorageTypeEnvVar) == "" {
		os.Setenv(storage.SpanStorageTypeEnvVar, "memory") // other storage types default to SpanStorage
	}
	storageFactory, err := storage.NewFactory(storage.FactoryConfigFromEnvAndCLI(os.Args, os.Stderr))
	if err != nil {
		log.Fatalf("Cannot initialize storage factory: %v", err)
	}
	strategyStoreFactoryConfig, err := ss.FactoryConfigFromEnv(os.Stderr)
	if err != nil {
		log.Fatalf("Cannot initialize sampling strategy store factory config: %v", err)
	}
	strategyStoreFactory, err := ss.NewFactory(*strategyStoreFactoryConfig)
	if err != nil {
		log.Fatalf("Cannot initialize sampling strategy store factory: %v", err)
	}

	fc := metricsPlugin.FactoryConfigFromEnv()
	metricsReaderFactory, err := metricsPlugin.NewFactory(fc)
	if err != nil {
		log.Fatalf("Cannot initialize metrics store factory: %v", err)
	}

	v := viper.New()
	command := &cobra.Command{
		Use:   "jaeger-all-in-one",
		Short: "Jaeger all-in-one distribution with agent, collector and query in one process.",
		Long: `Jaeger all-in-one distribution with agent, collector and query. Use with caution this version
by default uses only in-memory database.`,
		RunE: func(cmd *cobra.Command, args []string) error {
			if err := svc.Start(v); err != nil {
				return err
			}
			logger := svc.Logger // shortcut
			metricsFactory := fork.New("internal",
				expvar.NewFactory(10), // backend for internal opts
				svc.MetricsFactory.Namespace(metrics.NSOptions{Name: "jaeger"}))
			version.NewInfoMetrics(metricsFactory)

			tracerCloser := initTracer(svc)

			storageFactory.InitFromViper(v, logger)
			if err := storageFactory.Initialize(metricsFactory, logger); err != nil {
				logger.Fatal("Failed to init storage factory", zap.Error(err))
			}

			spanReader, err := storageFactory.CreateSpanReader()
			if err != nil {
				logger.Fatal("Failed to create span reader", zap.Error(err))
			}
			spanWriter, err := storageFactory.CreateSpanWriter()
			if err != nil {
				logger.Fatal("Failed to create span writer", zap.Error(err))
			}
			dependencyReader, err := storageFactory.CreateDependencyReader()
			if err != nil {
				logger.Fatal("Failed to create dependency reader", zap.Error(err))
			}

			metricsQueryService, err := createMetricsQueryService(metricsReaderFactory, v, logger, metricsFactory)
			if err != nil {
				logger.Fatal("Failed to create metrics reader", zap.Error(err))
			}

			ssFactory, err := storageFactory.CreateSamplingStoreFactory()
			if err != nil {
				logger.Fatal("Failed to create sampling store factory", zap.Error(err))
			}

			strategyStoreFactory.InitFromViper(v, logger)
			if err := strategyStoreFactory.Initialize(metricsFactory, ssFactory, logger); err != nil {
				logger.Fatal("Failed to init sampling strategy store factory", zap.Error(err))
			}
			strategyStore, aggregator, err := strategyStoreFactory.CreateStrategyStore()
			if err != nil {
				logger.Fatal("Failed to create sampling strategy store", zap.Error(err))
			}

			aOpts := new(agentApp.Builder).InitFromViper(v)
			repOpts := new(agentRep.Options).InitFromViper(v, logger)
			grpcBuilder, err := agentGrpcRep.NewConnBuilder().InitFromViper(v)
			if err != nil {
				logger.Fatal("Failed to configure connection for grpc", zap.Error(err))
			}
			cOpts, err := new(collectorFlags.CollectorOptions).InitFromViper(v, logger)
			if err != nil {
				logger.Fatal("Failed to initialize collector", zap.Error(err))
			}
			qOpts, err := new(queryApp.QueryOptions).InitFromViper(v, logger)
			if err != nil {
				logger.Fatal("Failed to configure query service", zap.Error(err))
			}

			tm := tenancy.NewManager(&cOpts.GRPC.Tenancy)

			// collector
			c := collectorApp.New(&collectorApp.CollectorParams{
				ServiceName:    "jaeger-collector",
				Logger:         logger,
				MetricsFactory: metricsFactory,
				SpanWriter:     spanWriter,
				StrategyStore:  strategyStore,
				Aggregator:     aggregator,
				HealthCheck:    svc.HC(),
				TenancyMgr:     tm,
			})
			if err := c.Start(cOpts); err != nil {
				log.Fatal(err)
			}

			// agent
			// if the agent reporter grpc host:port was not explicitly set then use whatever the collector is listening on
			if len(grpcBuilder.CollectorHostPorts) == 0 {
				grpcBuilder.CollectorHostPorts = append(grpcBuilder.CollectorHostPorts, cOpts.GRPC.HostPort)
			}
			agentMetricsFactory := metricsFactory.Namespace(metrics.NSOptions{Name: "agent", Tags: nil})
			builders := map[agentRep.Type]agentApp.CollectorProxyBuilder{
				agentRep.GRPC: agentApp.GRPCCollectorProxyBuilder(grpcBuilder),
			}
			cp, err := agentApp.CreateCollectorProxy(agentApp.ProxyBuilderOptions{
				Options: *repOpts,
				Logger:  logger,
				Metrics: agentMetricsFactory,
			}, builders)
			if err != nil {
				logger.Fatal("Could not create collector proxy", zap.Error(err))
			}
			agent := startAgent(cp, aOpts, logger, metricsFactory)

			// query
			querySrv := startQuery(
				svc, qOpts, qOpts.BuildQueryServiceOptions(storageFactory, logger),
				spanReader, dependencyReader, metricsQueryService,
				metricsFactory, tm,
			)

			svc.RunAndThen(func() {
				agent.Stop()
				_ = cp.Close()
				_ = c.Close()
				_ = querySrv.Close()
				if closer, ok := spanWriter.(io.Closer); ok {
					if err := closer.Close(); err != nil {
						logger.Error("Failed to close span writer", zap.Error(err))
					}
				}
				if err := storageFactory.Close(); err != nil {
					logger.Error("Failed to close storage factory", zap.Error(err))
				}
				_ = tracerCloser.Close()
			})
			return nil
		},
	}

	command.AddCommand(version.Command())
	command.AddCommand(env.Command())
	command.AddCommand(docs.Command(v))
	command.AddCommand(status.Command(v, ports.CollectorAdminHTTP))

	config.AddFlags(
		v,
		command,
		svc.AddFlags,
		storageFactory.AddPipelineFlags,
		agentApp.AddFlags,
		agentRep.AddFlags,
		agentGrpcRep.AddFlags,
		collectorFlags.AddFlags,
		queryApp.AddFlags,
		strategyStoreFactory.AddFlags,
		metricsReaderFactory.AddFlags,
	)

	if err := command.Execute(); err != nil {
		log.Fatal(err)
	}
}

func startAgent(
	cp agentApp.CollectorProxy,
	b *agentApp.Builder,
	logger *zap.Logger,
	baseFactory metrics.Factory,
) *agentApp.Agent {
	agent, err := b.CreateAgent(cp, logger, baseFactory)
	if err != nil {
		logger.Fatal("Unable to initialize Jaeger Agent", zap.Error(err))
	}

	logger.Info("Starting agent")
	if err := agent.Run(); err != nil {
		logger.Fatal("Failed to run the agent", zap.Error(err))
	}

	return agent
}

func startQuery(
	svc *flags.Service,
	qOpts *queryApp.QueryOptions,
	queryOpts *querysvc.QueryServiceOptions,
	spanReader spanstore.Reader,
	depReader dependencystore.Reader,
	metricsQueryService querysvc.MetricsQueryService,
	baseFactory metrics.Factory,
	tm *tenancy.Manager,
) *queryApp.Server {
	spanReader = storageMetrics.NewReadMetricsDecorator(spanReader, baseFactory.Namespace(metrics.NSOptions{Name: "query"}))
	qs := querysvc.NewQueryService(spanReader, depReader, *queryOpts)
	server, err := queryApp.NewServer(svc.Logger, qs, metricsQueryService, qOpts, tm, opentracing.GlobalTracer())
	if err != nil {
		svc.Logger.Fatal("Could not start jaeger-query service", zap.Error(err))
	}
	go func() {
		for s := range server.HealthCheckStatus() {
			svc.SetHealthCheckStatus(s)
		}
	}()
	if err := server.Start(); err != nil {
		svc.Logger.Fatal("Could not start jaeger-query service", zap.Error(err))
	}
	return server
}

func initTracer(svc *flags.Service) io.Closer {
	logger := svc.Logger
	traceCfg := &jaegerClientConfig.Configuration{
		ServiceName: "jaeger-query",
		Sampler: &jaegerClientConfig.SamplerConfig{
			Type:  "const",
			Param: 1.0,
		},
		RPCMetrics: true,
	}
	traceCfg, err := traceCfg.FromEnv()
	if err != nil {
		logger.Fatal("Failed to read tracer configuration", zap.Error(err))
	}
	tracer, closer, err := traceCfg.NewTracer(
		jaegerClientConfig.Metrics(jlibadapter.NewAdapter(svc.MetricsFactory)),
		jaegerClientConfig.Logger(jaegerClientZapLog.NewLogger(logger)),
	)
	if err != nil {
		logger.Fatal("Failed to initialize tracer", zap.Error(err))
	}
	opentracing.SetGlobalTracer(tracer)
	return closer
}

func createMetricsQueryService(
	metricsReaderFactory *metricsPlugin.Factory,
	v *viper.Viper,
	logger *zap.Logger,
	metricsReaderMetricsFactory metrics.Factory,
) (querysvc.MetricsQueryService, error) {
	if err := metricsReaderFactory.Initialize(logger); err != nil {
		return nil, fmt.Errorf("failed to init metrics reader factory: %w", err)
	}

	// Ensure default parameter values are loaded correctly.
	metricsReaderFactory.InitFromViper(v, logger)
	reader, err := metricsReaderFactory.CreateMetricsReader()
	if err != nil {
		return nil, fmt.Errorf("failed to create metrics reader: %w", err)
	}

	// Decorate the metrics reader with metrics instrumentation.
	return metricsstoreMetrics.NewReadMetricsDecorator(reader, metricsReaderMetricsFactory), nil
}


apiVersion: 1
datasources:
- name: Prometheus
  type: prometheus
  url: http://prometheus:9090
  isDefault: true
  access: proxy
  editable: true



// Copyright (c) 2017 The Jaeger Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package prometheus

import (
	"strings"
	"sync"

	"github.com/prometheus/client_golang/prometheus"
)

// vectorCache is used to avoid creating Prometheus vectors with the same set of labels more than once.
type vectorCache struct {
	registerer prometheus.Registerer
	lock       sync.Mutex
	cVecs      map[string]*prometheus.CounterVec
	gVecs      map[string]*prometheus.GaugeVec
	hVecs      map[string]*prometheus.HistogramVec
}

func newVectorCache(registerer prometheus.Registerer) *vectorCache {
	return &vectorCache{
		registerer: registerer,
		cVecs:      make(map[string]*prometheus.CounterVec),
		gVecs:      make(map[string]*prometheus.GaugeVec),
		hVecs:      make(map[string]*prometheus.HistogramVec),
	}
}

func (c *vectorCache) getOrMakeCounterVec(opts prometheus.CounterOpts, labelNames []string) *prometheus.CounterVec {
	c.lock.Lock()
	defer c.lock.Unlock()

	cacheKey := c.getCacheKey(opts.Name, labelNames)
	cv, cvExists := c.cVecs[cacheKey]
	if !cvExists {
		cv = prometheus.NewCounterVec(opts, labelNames)
		c.registerer.MustRegister(cv)
		c.cVecs[cacheKey] = cv
	}
	return cv
}

func (c *vectorCache) getOrMakeGaugeVec(opts prometheus.GaugeOpts, labelNames []string) *prometheus.GaugeVec {
	c.lock.Lock()
	defer c.lock.Unlock()

	cacheKey := c.getCacheKey(opts.Name, labelNames)
	gv, gvExists := c.gVecs[cacheKey]
	if !gvExists {
		gv = prometheus.NewGaugeVec(opts, labelNames)
		c.registerer.MustRegister(gv)
		c.gVecs[cacheKey] = gv
	}
	return gv
}

func (c *vectorCache) getOrMakeHistogramVec(opts prometheus.HistogramOpts, labelNames []string) *prometheus.HistogramVec {
	c.lock.Lock()
	defer c.lock.Unlock()

	cacheKey := c.getCacheKey(opts.Name, labelNames)
	hv, hvExists := c.hVecs[cacheKey]
	if !hvExists {
		hv = prometheus.NewHistogramVec(opts, labelNames)
		c.registerer.MustRegister(hv)
		c.hVecs[cacheKey] = hv
	}
	return hv
}

func (c *vectorCache) getCacheKey(name string, labels []string) string {
	return strings.Join(append([]string{name}, labels...), "||")
}


// Copyright (c) 2017 The Jaeger Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package prometheus

import (
	"sort"
	"strings"
	"time"

	"github.com/prometheus/client_golang/prometheus"

	"github.com/jaegertracing/jaeger/pkg/metrics"
)

// Factory implements metrics.Factory backed by Prometheus registry.
type Factory struct {
	scope      string
	tags       map[string]string
	cache      *vectorCache
	buckets    []float64
	normalizer *strings.Replacer
	separator  Separator
}

var _ metrics.Factory = (*Factory)(nil)

type options struct {
	registerer prometheus.Registerer
	buckets    []float64
	separator  Separator
}

// Separator represents the namespace separator to use
type Separator rune

const (
	// SeparatorUnderscore uses an underscore as separator
	SeparatorUnderscore Separator = '_'

	// SeparatorColon uses a colon as separator
	SeparatorColon = ':'
)

// Option is a function that sets some option for the Factory constructor.
type Option func(*options)

// WithRegisterer returns an option that sets the registerer.
// If not used we fallback to prometheus.DefaultRegisterer.
func WithRegisterer(registerer prometheus.Registerer) Option {
	return func(opts *options) {
		opts.registerer = registerer
	}
}

// WithBuckets returns an option that sets the default buckets for histogram.
// If not used, we fallback to default Prometheus buckets.
func WithBuckets(buckets []float64) Option {
	return func(opts *options) {
		opts.buckets = buckets
	}
}

// WithSeparator returns an option that sets the default separator for the namespace
// If not used, we fallback to underscore.
func WithSeparator(separator Separator) Option {
	return func(opts *options) {
		opts.separator = separator
	}
}

func applyOptions(opts []Option) *options {
	options := new(options)
	for _, o := range opts {
		o(options)
	}
	if options.registerer == nil {
		options.registerer = prometheus.DefaultRegisterer
	}
	if options.separator == '\x00' {
		options.separator = SeparatorUnderscore
	}
	return options
}

// New creates a Factory backed by Prometheus registry.
// Typically the first argument should be prometheus.DefaultRegisterer.
//
// Parameter buckets defines the buckets into which Timer observations are counted.
// Each element in the slice is the upper inclusive bound of a bucket. The
// values must be sorted in strictly increasing order. There is no need
// to add a highest bucket with +Inf bound, it will be added
// implicitly. The default value is prometheus.DefBuckets.
func New(opts ...Option) *Factory {
	options := applyOptions(opts)
	return newFactory(
		&Factory{ // dummy struct to be discarded
			cache:      newVectorCache(options.registerer),
			buckets:    options.buckets,
			normalizer: strings.NewReplacer(".", "_", "-", "_"),
			separator:  options.separator,
		},
		"",  // scope
		nil) // tags
}

func newFactory(parent *Factory, scope string, tags map[string]string) *Factory {
	return &Factory{
		cache:      parent.cache,
		buckets:    parent.buckets,
		normalizer: parent.normalizer,
		separator:  parent.separator,
		scope:      scope,
		tags:       tags,
	}
}

// Counter implements Counter of metrics.Factory.
func (f *Factory) Counter(options metrics.Options) metrics.Counter {
	help := strings.TrimSpace(options.Help)
	if len(help) == 0 {
		help = options.Name
	}
	name := counterNamingConvention(f.subScope(options.Name))
	tags := f.mergeTags(options.Tags)
	labelNames := f.tagNames(tags)
	opts := prometheus.CounterOpts{
		Name: name,
		Help: help,
	}
	cv := f.cache.getOrMakeCounterVec(opts, labelNames)
	return &counter{
		counter: cv.WithLabelValues(f.tagsAsLabelValues(labelNames, tags)...),
	}
}

// Gauge implements Gauge of metrics.Factory.
func (f *Factory) Gauge(options metrics.Options) metrics.Gauge {
	help := strings.TrimSpace(options.Help)
	if len(help) == 0 {
		help = options.Name
	}
	name := f.subScope(options.Name)
	tags := f.mergeTags(options.Tags)
	labelNames := f.tagNames(tags)
	opts := prometheus.GaugeOpts{
		Name: name,
		Help: help,
	}
	gv := f.cache.getOrMakeGaugeVec(opts, labelNames)
	return &gauge{
		gauge: gv.WithLabelValues(f.tagsAsLabelValues(labelNames, tags)...),
	}
}

// Timer implements Timer of metrics.Factory.
func (f *Factory) Timer(options metrics.TimerOptions) metrics.Timer {
	help := strings.TrimSpace(options.Help)
	if len(help) == 0 {
		help = options.Name
	}
	name := f.subScope(options.Name)
	buckets := f.selectBuckets(asFloatBuckets(options.Buckets))
	tags := f.mergeTags(options.Tags)
	labelNames := f.tagNames(tags)
	opts := prometheus.HistogramOpts{
		Name:    name,
		Help:    help,
		Buckets: buckets,
	}
	hv := f.cache.getOrMakeHistogramVec(opts, labelNames)
	return &timer{
		histogram: hv.WithLabelValues(f.tagsAsLabelValues(labelNames, tags)...),
	}
}

func asFloatBuckets(buckets []time.Duration) []float64 {
	data := make([]float64, len(buckets))
	for i := range data {
		data[i] = float64(buckets[i]) / float64(time.Second)
	}
	return data
}

// Histogram implements Histogram of metrics.Factory.
func (f *Factory) Histogram(options metrics.HistogramOptions) metrics.Histogram {
	help := strings.TrimSpace(options.Help)
	if len(help) == 0 {
		help = options.Name
	}
	name := f.subScope(options.Name)
	buckets := f.selectBuckets(options.Buckets)
	tags := f.mergeTags(options.Tags)
	labelNames := f.tagNames(tags)
	opts := prometheus.HistogramOpts{
		Name:    name,
		Help:    help,
		Buckets: buckets,
	}
	hv := f.cache.getOrMakeHistogramVec(opts, labelNames)
	return &histogram{
		histogram: hv.WithLabelValues(f.tagsAsLabelValues(labelNames, tags)...),
	}
}

// Namespace implements Namespace of metrics.Factory.
func (f *Factory) Namespace(scope metrics.NSOptions) metrics.Factory {
	return newFactory(f, f.subScope(scope.Name), f.mergeTags(scope.Tags))
}

type counter struct {
	counter prometheus.Counter
}

func (c *counter) Inc(v int64) {
	c.counter.Add(float64(v))
}

type gauge struct {
	gauge prometheus.Gauge
}

func (g *gauge) Update(v int64) {
	g.gauge.Set(float64(v))
}

type observer interface {
	Observe(v float64)
}

type timer struct {
	histogram observer
}

func (t *timer) Record(v time.Duration) {
	t.histogram.Observe(float64(v.Nanoseconds()) / float64(time.Second/time.Nanosecond))
}

type histogram struct {
	histogram observer
}

func (h *histogram) Record(v float64) {
	h.histogram.Observe(v)
}

func (f *Factory) subScope(name string) string {
	if f.scope == "" {
		return f.normalize(name)
	}
	if name == "" {
		return f.normalize(f.scope)
	}
	return f.normalize(f.scope + string(f.separator) + name)
}

func (f *Factory) normalize(v string) string {
	return f.normalizer.Replace(v)
}

func (f *Factory) mergeTags(tags map[string]string) map[string]string {
	ret := make(map[string]string, len(f.tags)+len(tags))
	for k, v := range f.tags {
		ret[k] = v
	}
	for k, v := range tags {
		ret[k] = v
	}
	return ret
}

func (f *Factory) tagNames(tags map[string]string) []string {
	ret := make([]string, 0, len(tags))
	for k := range tags {
		ret = append(ret, k)
	}
	sort.Strings(ret)
	return ret
}

func (f *Factory) tagsAsLabelValues(labels []string, tags map[string]string) []string {
	ret := make([]string, 0, len(tags))
	for _, l := range labels {
		ret = append(ret, tags[l])
	}
	return ret
}

func (f *Factory) selectBuckets(buckets []float64) []float64 {
	if len(buckets) > 0 {
		return buckets
	}
	return f.buckets
}

func counterNamingConvention(name string) string {
	if !strings.HasSuffix(name, "_total") {
		name += "_total"
	}
	return name
}


// Copyright (c) 2022 The Jaeger Authors.
// Copyright (c) 2017 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package metricstest

import (
	"sort"
)

// GetKey converts name+tags into a single string of the form
// "name|tag1=value1|...|tagN=valueN", where tag names are
// sorted alphabetically.
func GetKey(name string, tags map[string]string, tagsSep string, tagKVSep string) string {
	keys := make([]string, 0, len(tags))
	for k := range tags {
		keys = append(keys, k)
	}
	sort.Strings(keys)
	key := name
	for _, k := range keys {
		key = key + tagsSep + k + tagKVSep + tags[k]
	}
	return key
}


// Copyright (c) 2022 The Jaeger Authors.
// Copyright (c) 2017 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package metricstest

import (
	"sync"
	"sync/atomic"
	"time"

	"github.com/HdrHistogram/hdrhistogram-go"

	"github.com/jaegertracing/jaeger/pkg/metrics"
)

// This is intentionally very similar to github.com/codahale/metrics, the
// main difference being that counters/gauges are scoped to the provider
// rather than being global (to facilitate testing).

// A Backend is a metrics provider which aggregates data in-vm, and
// allows exporting snapshots to shove the data into a remote collector
type Backend struct {
	cm         sync.Mutex
	gm         sync.Mutex
	tm         sync.Mutex
	hm         sync.Mutex
	counters   map[string]*int64
	gauges     map[string]*int64
	timers     map[string]*localBackendTimer
	histograms map[string]*localBackendHistogram
	stop       chan struct{}
	wg         sync.WaitGroup
	TagsSep    string
	TagKVSep   string
}

// NewBackend returns a new Backend. The collectionInterval is the histogram
// time window for each timer.
func NewBackend(collectionInterval time.Duration) *Backend {
	b := &Backend{
		counters:   make(map[string]*int64),
		gauges:     make(map[string]*int64),
		timers:     make(map[string]*localBackendTimer),
		histograms: make(map[string]*localBackendHistogram),
		stop:       make(chan struct{}),
		TagsSep:    "|",
		TagKVSep:   "=",
	}
	if collectionInterval == 0 {
		// Use one histogram time window for all timers
		return b
	}
	b.wg.Add(1)
	go b.runLoop(collectionInterval)
	return b
}

// Clear discards accumulated stats
func (b *Backend) Clear() {
	b.cm.Lock()
	defer b.cm.Unlock()
	b.gm.Lock()
	defer b.gm.Unlock()
	b.tm.Lock()
	defer b.tm.Unlock()
	b.hm.Lock()
	defer b.hm.Unlock()
	b.counters = make(map[string]*int64)
	b.gauges = make(map[string]*int64)
	b.timers = make(map[string]*localBackendTimer)
	b.histograms = make(map[string]*localBackendHistogram)
}

func (b *Backend) runLoop(collectionInterval time.Duration) {
	defer b.wg.Done()
	ticker := time.NewTicker(collectionInterval)
	for {
		select {
		case <-ticker.C:
			b.tm.Lock()
			timers := make(map[string]*localBackendTimer, len(b.timers))
			for timerName, timer := range b.timers {
				timers[timerName] = timer
			}
			b.tm.Unlock()

			for _, t := range timers {
				t.Lock()
				t.hist.Rotate()
				t.Unlock()
			}
		case <-b.stop:
			ticker.Stop()
			return
		}
	}
}

// IncCounter increments a counter value
func (b *Backend) IncCounter(name string, tags map[string]string, delta int64) {
	name = GetKey(name, tags, b.TagsSep, b.TagKVSep)
	b.cm.Lock()
	defer b.cm.Unlock()
	counter := b.counters[name]
	if counter == nil {
		b.counters[name] = new(int64)
		*b.counters[name] = delta
		return
	}
	atomic.AddInt64(counter, delta)
}

// UpdateGauge updates the value of a gauge
func (b *Backend) UpdateGauge(name string, tags map[string]string, value int64) {
	name = GetKey(name, tags, b.TagsSep, b.TagKVSep)
	b.gm.Lock()
	defer b.gm.Unlock()
	gauge := b.gauges[name]
	if gauge == nil {
		b.gauges[name] = new(int64)
		*b.gauges[name] = value
		return
	}
	atomic.StoreInt64(gauge, value)
}

// RecordHistogram records a timing duration
func (b *Backend) RecordHistogram(name string, tags map[string]string, v float64) {
	name = GetKey(name, tags, b.TagsSep, b.TagKVSep)
	histogram := b.findOrCreateHistogram(name)
	histogram.Lock()
	histogram.hist.Current.RecordValue(int64(v))
	histogram.Unlock()
}

func (b *Backend) findOrCreateHistogram(name string) *localBackendHistogram {
	b.hm.Lock()
	defer b.hm.Unlock()
	if t, ok := b.histograms[name]; ok {
		return t
	}

	t := &localBackendHistogram{
		hist: hdrhistogram.NewWindowed(5, 0, int64((5*time.Minute)/time.Millisecond), 1),
	}
	b.histograms[name] = t
	return t
}

type localBackendHistogram struct {
	sync.Mutex
	hist *hdrhistogram.WindowedHistogram
}

// RecordTimer records a timing duration
func (b *Backend) RecordTimer(name string, tags map[string]string, d time.Duration) {
	name = GetKey(name, tags, b.TagsSep, b.TagKVSep)
	timer := b.findOrCreateTimer(name)
	timer.Lock()
	timer.hist.Current.RecordValue(int64(d / time.Millisecond))
	timer.Unlock()
}

func (b *Backend) findOrCreateTimer(name string) *localBackendTimer {
	b.tm.Lock()
	defer b.tm.Unlock()
	if t, ok := b.timers[name]; ok {
		return t
	}

	t := &localBackendTimer{
		hist: hdrhistogram.NewWindowed(5, 0, int64((5*time.Minute)/time.Millisecond), 1),
	}
	b.timers[name] = t
	return t
}

type localBackendTimer struct {
	sync.Mutex
	hist *hdrhistogram.WindowedHistogram
}

var percentiles = map[string]float64{
	"P50":  50,
	"P75":  75,
	"P90":  90,
	"P95":  95,
	"P99":  99,
	"P999": 99.9,
}

// Snapshot captures a snapshot of the current counter and gauge values
func (b *Backend) Snapshot() (counters, gauges map[string]int64) {
	b.cm.Lock()
	defer b.cm.Unlock()

	counters = make(map[string]int64, len(b.counters))
	for name, value := range b.counters {
		counters[name] = atomic.LoadInt64(value)
	}

	b.gm.Lock()
	defer b.gm.Unlock()

	gauges = make(map[string]int64, len(b.gauges))
	for name, value := range b.gauges {
		gauges[name] = atomic.LoadInt64(value)
	}

	b.tm.Lock()
	timers := make(map[string]*localBackendTimer)
	for timerName, timer := range b.timers {
		timers[timerName] = timer
	}
	b.tm.Unlock()

	for timerName, timer := range timers {
		timer.Lock()
		hist := timer.hist.Merge()
		timer.Unlock()
		for name, q := range percentiles {
			gauges[timerName+"."+name] = hist.ValueAtQuantile(q)
		}
	}

	b.hm.Lock()
	histograms := make(map[string]*localBackendHistogram)
	for histogramName, histogram := range b.histograms {
		histograms[histogramName] = histogram
	}
	b.hm.Unlock()

	for histogramName, histogram := range histograms {
		histogram.Lock()
		hist := histogram.hist.Merge()
		histogram.Unlock()
		for name, q := range percentiles {
			gauges[histogramName+"."+name] = hist.ValueAtQuantile(q)
		}
	}

	return
}

// Stop cleanly closes the background goroutine spawned by NewBackend.
func (b *Backend) Stop() {
	close(b.stop)
	b.wg.Wait()
}

type stats struct {
	name            string
	tags            map[string]string
	buckets         []float64
	durationBuckets []time.Duration
	localBackend    *Backend
}

type localTimer struct {
	stats
}

func (l *localTimer) Record(d time.Duration) {
	l.localBackend.RecordTimer(l.name, l.tags, d)
}

type localHistogram struct {
	stats
}

func (l *localHistogram) Record(v float64) {
	l.localBackend.RecordHistogram(l.name, l.tags, v)
}

type localCounter struct {
	stats
}

func (l *localCounter) Inc(delta int64) {
	l.localBackend.IncCounter(l.name, l.tags, delta)
}

type localGauge struct {
	stats
}

func (l *localGauge) Update(value int64) {
	l.localBackend.UpdateGauge(l.name, l.tags, value)
}

// Factory stats factory that creates metrics that are stored locally
type Factory struct {
	*Backend
	namespace string
	tags      map[string]string
}

// NewFactory returns a new LocalMetricsFactory
func NewFactory(collectionInterval time.Duration) *Factory {
	return &Factory{
		Backend: NewBackend(collectionInterval),
	}
}

// appendTags adds the tags to the namespace tags and returns a combined map.
func (l *Factory) appendTags(tags map[string]string) map[string]string {
	newTags := make(map[string]string)
	for k, v := range l.tags {
		newTags[k] = v
	}
	for k, v := range tags {
		newTags[k] = v
	}
	return newTags
}

func (l *Factory) newNamespace(name string) string {
	if l.namespace == "" {
		return name
	}

	if name == "" {
		return l.namespace
	}

	return l.namespace + "." + name
}

// Counter returns a local stats counter
func (l *Factory) Counter(options metrics.Options) metrics.Counter {
	return &localCounter{
		stats{
			name:         l.newNamespace(options.Name),
			tags:         l.appendTags(options.Tags),
			localBackend: l.Backend,
		},
	}
}

// Timer returns a local stats timer.
func (l *Factory) Timer(options metrics.TimerOptions) metrics.Timer {
	return &localTimer{
		stats{
			name:            l.newNamespace(options.Name),
			tags:            l.appendTags(options.Tags),
			durationBuckets: options.Buckets,
			localBackend:    l.Backend,
		},
	}
}

// Gauge returns a local stats gauge.
func (l *Factory) Gauge(options metrics.Options) metrics.Gauge {
	return &localGauge{
		stats{
			name:         l.newNamespace(options.Name),
			tags:         l.appendTags(options.Tags),
			localBackend: l.Backend,
		},
	}
}

// Histogram returns a local stats histogram.
func (l *Factory) Histogram(options metrics.HistogramOptions) metrics.Histogram {
	return &localHistogram{
		stats{
			name:         l.newNamespace(options.Name),
			tags:         l.appendTags(options.Tags),
			buckets:      options.Buckets,
			localBackend: l.Backend,
		},
	}
}

// Namespace returns a new namespace.
func (l *Factory) Namespace(scope metrics.NSOptions) metrics.Factory {
	return &Factory{
		namespace: l.newNamespace(scope.Name),
		tags:      l.appendTags(scope.Tags),
		Backend:   l.Backend,
	}
}


version: '3.8'
x-postgres-common:
  &postgres-common
  image: postgres:14-alpine
  user: postgres
  restart: always
  healthcheck:
    test: 'pg_isready -U user --dbname=postgres'
    interval: 10s
    timeout: 5s
    retries: 5

services:
  postgres_primary:
    <<: *postgres-common
    ports:
      - 5432:5432
    environment:
      POSTGRES_USER: user
      POSTGRES_DB: postgres
      POSTGRES_PASSWORD: password
      POSTGRES_HOST_AUTH_METHOD: "scram-sha-256\nhost replication all 0.0.0.0/0 md5"
      POSTGRES_INITDB_ARGS: "--auth-host=scram-sha-256"
    command: |
      postgres 
      -c wal_level=replica 
      -c hot_standby=on 
      -c max_wal_senders=10 
      -c max_replication_slots=10 
      -c hot_standby_feedback=on
    volumes:
      - ./00_init.sql:/docker-entrypoint-initdb.d/00_init.sql

  postgres_replica:
    <<: *postgres-common
    ports:
      - 5433:5432
    environment:
      PGUSER: replicator
      PGPASSWORD: replicator_password
    command: |
      bash -c "
      until pg_basebackup --pgdata=/var/lib/postgresql/data -R --slot=replication_slot --host=postgres_primary --port=5432
      do
      echo 'Waiting for primary to connect...'
      sleep 1s
      done
      echo 'Backup done, starting replica...'
      chmod 0700 /var/lib/postgresql/data
      postgres
      "
    depends_on:
      - postgres_primary
	  
	  
--------------------


x-postgres-common:
  &postgres-common
  image: postgres:14-alpine
  user: postgres
  restart: always
  healthcheck:
    test: 'pg_isready -U user --dbname=postgres'
    interval: 10s
    timeout: 5s
  ¬†¬†retries:¬†5
...

--------------------


...
services:
  postgres_primary:
    <<: *postgres-common
    ports:
      - 5432:5432
    environment:
      POSTGRES_USER: user
      POSTGRES_DB: postgres
      POSTGRES_PASSWORD: password
      POSTGRES_HOST_AUTH_METHOD: "scram-sha-256\nhost replication all 0.0.0.0/0 md5"
      POSTGRES_INITDB_ARGS: "--auth-host=scram-sha-256"
    command: |
      postgres 
      -c wal_level=replica 
      -c hot_standby=on 
      -c max_wal_senders=10 
      -c max_replication_slots=10 
      -c hot_standby_feedback=on
    volumes:
      - ./00_init.sql:/docker-entrypoint-initdb.d/00_init.sql
...


--------------------


...
postgres_replica:
    <<: *postgres-common
    ports:
      - 5433:5432
    environment:
      PGUSER: replicator
      PGPASSWORD: replicator_password
    command: |
      bash -c "
      until pg_basebackup --pgdata=/var/lib/postgresql/data -R --slot=replication_slot --host=postgres_primary --port=5432
      do
      echo 'Waiting for primary to connect...'
      sleep 1s
      done
      echo 'Backup done, starting replica...'
      chmod 0700 /var/lib/postgresql/data
      postgres
      "
    depends_on:
      - postgres_primary

--------------------

listen_addresses = '*'
# DB Version: 13
# OS Type: linux
# DB Type: web
# Total Memory (RAM): 62 GB
# CPUs num: 12
# Connections num: 1000
# Data Storage: ssd
# Performance tweaks
max_connections = 1000
shared_buffers = 15872MB
effective_cache_size = 47616MB
maintenance_work_mem = 2GB
checkpoint_completion_target = 0.7
wal_buffers = 16MB
default_statistics_target = 100
random_page_cost = 1.1
effective_io_concurrency = 200
work_mem = 4063kB
min_wal_size = 1GB
max_wal_size = 4GB
max_worker_processes = 12
max_parallel_workers_per_gather¬†=¬†4

--------------------

# Replication
wal_level = replica
hot_standby = on
max_wal_senders = 10
max_replication_slots¬†=¬†10

--------------------

version: '3'
services:
  database:
    image: postgres:13
    container_name: my_postgres_database
    restart: always
    volumes:
        - ./data:/var/lib/postgresql/data
        - ./my-postgres.conf:/etc/postgresql/postgresql.conf
        - ./my-pg_hba.conf:/etc/postgresql/pg_hba.conf
    ports:
      - "127.0.0.1:5432:5432"
    environment:
      - 'POSTGRES_PASSWORD=my_password'
      - 'POSTGRES_DB=my_default_database'
--------------------

version: '2'

services:
  postgresql-master:
    image: 'docker.io/bitnami/postgresql:11-debian-10'
    ports:
      - '5432:5432'
    volumes:
      - 'postgresql_master_data:/bitnami/postgresql'
    environment:
      - POSTGRESQL_PGAUDIT_LOG=READ,WRITE
      - POSTGRESQL_LOG_HOSTNAME=true
      - POSTGRESQL_REPLICATION_MODE=master
      - POSTGRESQL_REPLICATION_USER=repl_user
      - POSTGRESQL_REPLICATION_PASSWORD=repl_password
      - POSTGRESQL_USERNAME=postgres
      - POSTGRESQL_DATABASE=my_database
      - ALLOW_EMPTY_PASSWORD=yes
  postgresql-slave:
    image: 'docker.io/bitnami/postgresql:11-debian-10'
    ports:
      - '5433:5432'
    depends_on:
      - postgresql-master
    environment:
      - POSTGRESQL_USERNAME=postgres
      - POSTGRESQL_PASSWORD=my_password
      - POSTGRESQL_MASTER_HOST=postgresql-master
      - POSTGRESQL_PGAUDIT_LOG=READ,WRITE
      - POSTGRESQL_LOG_HOSTNAME=true
      - POSTGRESQL_REPLICATION_MODE=slave
      - POSTGRESQL_REPLICATION_USER=repl_user
      - POSTGRESQL_REPLICATION_PASSWORD=repl_password
      - POSTGRESQL_MASTER_PORT_NUMBER=5432

volumes:
  postgresql_master_data:
 ¬†¬†¬†driver:¬†local

--------------------

version: "3"
services:
  postgresql-master:
    image: bitnami/postgresql
    restart: always
    ports:
      - '5432:5432'
    volumes:
      - postgresql_master_data:/bitnami/postgresql
      - ./db.sql:/docker-entrypoint-initdb.d/db.sql
    environment:
      - POSTGRESQL_PGAUDIT_LOG=READ,WRITE
      - POSTGRESQL_LOG_HOSTNAME=true
      - POSTGRESQL_REPLICATION_MODE=master
      - POSTGRESQL_REPLICATION_USER=repl_user
      - POSTGRESQL_REPLICATION_PASSWORD=repl_user
      - POSTGRESQL_USERNAME=postgres
      - POSTGRESQL_PASSWORD=postgres
      - POSTGRESQL_DATABASE=development_database
      - ALLOW_EMPTY_PASSWORD=yes

  postgresql-slave:
    image: bitnami/postgresql
    restart: always
    ports:
      - '5432'
    depends_on:
      - postgresql-master
    environment:
      - POSTGRESQL_PASSWORD=postgres
      - POSTGRESQL_MASTER_HOST=postgresql-master
      - POSTGRESQL_PGAUDIT_LOG=READ
      - POSTGRESQL_LOG_HOSTNAME=true
      - POSTGRESQL_REPLICATION_MODE=slave
      - POSTGRESQL_REPLICATION_USER=repl_user
      - POSTGRESQL_REPLICATION_PASSWORD=repl_user
      - POSTGRESQL_MASTER_PORT_NUMBER=5432
      - ALLOW_EMPTY_PASSWORD=yes

volumes:
  postgresql_master_data:
 ¬†¬†¬†driver:¬†local
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 version: '3'

services:
  rabbitmq:
    image: rabbitmq:management
    container_name: cryptowatch-rabbitmq
    environment:
      - RABBITMQ_DEFAULT_USER=guest
      - RABBITMQ_DEFAULT_PASS=guest
    ports:
      - "5672:5672"
      - "15672:15672"
  redis:
    image: redis
    container_name: cryptowatch-redis
    ports:
      - "6379:6379"
  sqlserver:
    platform: linux/amd64
    image: mcr.microsoft.com/mssql/server:2022-latest
    container_name: cryptowatch-sqlserver
    environment:
      SA_PASSWORD: "CryptoW@tch2024"
      ACCEPT_EULA: "Y"
      MSSQL_PID: "Developer"
    ports:
      - "1433:1433"
  mongo:
    image: mongo
    container_name: cryptowatch-mongo
    restart: always
    environment:
      MONGO_INITDB_ROOT_USERNAME: guest
      MONGO_INITDB_ROOT_PASSWORD: guest
    ports:
      - "27017:27017"
networks:
  default:
    driver: bridge
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    

https://johnfercher.medium.com/go-grafana-2b1419f7a99d



version: '3'

networks:
  metrics:
    driver: bridge
  transactional:
    driver: bridge


services:
  product-db:
    image: product-db
    container_name: product-db
    expose:
      - '3306'
    ports:
      - "3306:3306"
    environment:
      MYSQL_ROOT_PASSWORD: supersecret
      MYSQL_DATABASE: ProductDb
      MYSQL_USER: AdminUser
      MYSQL_PASSWORD: AdminPassword
    volumes:
      - ./productdb/mysql:/var/lib/mysql
    healthcheck:
      test: "exit 0"
    networks:
      - transactional

  product-api:
    image: product-api
    container_name: product-api
    expose:
      - '8081'
    ports:
      - "8081:8081"
    depends_on:
      product-db:
        condition: service_healthy
    networks:
      - metrics
      - transactional

  prometheus:
    image: prom/prometheus
    container_name: prometheus
    expose:
      - '9090'
    ports:
      - "9090:9090"
    volumes:
      - ./prometheus:/etc/prometheus
    networks:
      - metrics

# ALTERA√á√ÉO <<<<<<<<<<<<<<<<<<<<<<<<<
  grafana:
    image: grafana/grafana
    container_name: grafana
    hostname: grafana
    environment:
      - GF_SECURITY_ADMIN_PASSWORD=admin
    restart: unless-stopped
    ports:
      - 3000:3000
    networks:
      - metrics



#pgxpool


import (
	"github.com/jackc/pgx/v5"x
	"github.com/jackc/pgx/v5/pgxpool"
)

var defaultMaxConns = int32(4)
var defaultMinConns = int32(0)
var defaultMaxConnLifetime = time.Hour
var defaultMaxConnIdleTime = time.Minute * 30
var defaultHealthCheckPeriod = time.Minute

	dbpool, err := pgxpool.New(context.Background(), os.Getenv("DATABASE_URL"))
	if err != nil {
		fmt.Fprintf(os.Stderr, "Unable to create connection pool: %v\n", err)
		os.Exit(1)
	}
	defer dbpool.Close()

	conn, err := pgx.Connect(context.Background(), os.Getenv("DATABASE_URL"))
	if err != nil {
		fmt.Fprintf(os.Stderr, "Unable to connect to database: %v\n", err)
		os.Exit(1)
	}
	defer conn.Close(context.Background())



// NewWithConfig creates a new Pool. config must have been created by [ParseConfig].
func NewWithConfig(ctx context.Context, config *Config) (*Pool, error) {
	// Default values are set in ParseConfig. Enforce initial creation by ParseConfig rather than setting defaults from
	// zero values.
	if !config.createdByParseConfig {
		panic("config must be created by ParseConfig")
	}

	p := &Pool{
		config:                config,
		beforeConnect:         config.BeforeConnect,
		afterConnect:          config.AfterConnect,
		beforeAcquire:         config.BeforeAcquire,
		afterRelease:          config.AfterRelease,
		beforeClose:           config.BeforeClose,
		minConns:              config.MinConns,
		maxConns:              config.MaxConns,
		maxConnLifetime:       config.MaxConnLifetime,
		maxConnLifetimeJitter: config.MaxConnLifetimeJitter,
		maxConnIdleTime:       config.MaxConnIdleTime,
		healthCheckPeriod:     config.HealthCheckPeriod,
		healthCheckChan:       make(chan struct{}, 1),
		closeChan:             make(chan struct{}),
	}

	var err error
	p.p, err = puddle.NewPool(
		&puddle.Config[*connResource]{
			Constructor: func(ctx context.Context) (*connResource, error) {
				atomic.AddInt64(&p.newConnsCount, 1)
				connConfig := p.config.ConnConfig.Copy()

				// Connection will continue in background even if Acquire is canceled. Ensure that a connect won't hang forever.
				if connConfig.ConnectTimeout <= 0 {
					connConfig.ConnectTimeout = 2 * time.Minute
				}

				if p.beforeConnect != nil {
					if err := p.beforeConnect(ctx, connConfig); err != nil {
						return nil, err
					}
				}

				conn, err := pgx.ConnectConfig(ctx, connConfig)
				if err != nil {
					return nil, err
				}

				if p.afterConnect != nil {
					err = p.afterConnect(ctx, conn)
					if err != nil {
						conn.Close(ctx)
						return nil, err
					}
				}

				jitterSecs := rand.Float64() * config.MaxConnLifetimeJitter.Seconds()
				maxAgeTime := time.Now().Add(config.MaxConnLifetime).Add(time.Duration(jitterSecs) * time.Second)

				cr := &connResource{
					conn:       conn,
					conns:      make([]Conn, 64),
					poolRows:   make([]poolRow, 64),
					poolRowss:  make([]poolRows, 64),
					maxAgeTime: maxAgeTime,
				}

				return cr, nil
			},
			Destructor: func(value *connResource) {
				ctx, cancel := context.WithTimeout(context.Background(), 15*time.Second)
				conn := value.conn
				if p.beforeClose != nil {
					p.beforeClose(conn)
				}
				conn.Close(ctx)
				select {
				case <-conn.PgConn().CleanupDone():
				case <-ctx.Done():
				}
				cancel()
			},
			MaxSize: config.MaxConns,
		},
	)
	if err != nil {
		return nil, err
	}

	go func() {
		p.createIdleResources(ctx, int(p.minConns))
		p.backgroundHealthCheck()
	}()

	return p, nil
}




package database

import (
	"context"

	"github.com/filhodanuvem/rinha/internal/config"
	"github.com/jackc/pgx/v4/pgxpool"
)

var Connection *pgxpool.Pool

func Connect() error {
	var err error
	Connection, err = pgxpool.Connect(context.Background(), config.DatabaseURL)

	return err
}

func Close() {
	if Connection == nil {
		return
	}
	Connection.Close()
}



services:
  api1:
    volumes:
      - ./pprof/api1:/pprof
    deploy:
      resources:
        limits:
          cpus: '0.1'
          memory: '0.15GB'

  nginx: 
    deploy:
      resources:
        limits:
          cpus: '0.2'
          memory: '0.5GB'

  db:
    image: postgres
    deploy:
      resources:
        limits:
          cpus: '1.0'
          memory: '1.7GB'
		  



-------------------
package main

import (
	"log/slog"
	"net/http"
	"os"
	"os/signal"
	"syscall"
	"time"

	"runtime/pprof"
	"runtime/trace"

	"github.com/filhodanuvem/rinha/internal/cache"
	"github.com/filhodanuvem/rinha/internal/config"
	"github.com/filhodanuvem/rinha/internal/database"
	route "github.com/filhodanuvem/rinha/internal/http"
	"github.com/filhodanuvem/rinha/internal/pessoa"
)

func main() {
	if config.PROFILING {
		slog.Info("Running with profiling")
		// Create a CPU profile file
		f, err := os.Create("/pprof/profile.prof")
		if err != nil {
			panic(err)
		}
		defer f.Close()

		// Start CPU profiling
		if err := pprof.StartCPUProfile(f); err != nil {
			panic(err)
		}
		defer pprof.StopCPUProfile()

		// Start tracing
		traceFile, err := os.Create("/pprof/trace.out")
		if err != nil {
			panic(err)
		}
		defer traceFile.Close()

		if err := trace.Start(traceFile); err != nil {
			panic(err)
		}
		defer trace.Stop()
	}

	slog.Info("Waiting for database...")
	if err := database.Connect(); err != nil {
		panic(err)
	}
	defer database.Close()

	chExit := make(chan struct{})
	repo := pessoa.NewRepository(database.Connection, cache.Client)

	for i := 0; i < config.NumWorkers; i++ {
		go pessoa.RunWorker(repo.ChPessoas, chExit, repo, config.NumBatch)
	}

	http.HandleFunc("/", route.Pessoas)
	go http.ListenAndServe(":80", nil)

	signalChan := make(chan os.Signal, 1)
	signal.Notify(signalChan, syscall.SIGINT, syscall.SIGTERM)
	<-signalChan
	close(repo.ChPessoas)
	for i := 0; i < config.NumWorkers; i++ {
		<-chExit
	}
}

func RunWorker(chPessoas chan rinha.Pessoa, chExit chan struct{}, repo *Repository, batch int) {
	slog.Debug("Starting worker...")
	defer slog.Debug("Finishing worker...")
	i := 0
	pessoas := make([]rinha.Pessoa, 0, batch)
	tick := time.NewTicker(config.WorkerTimeout)

	for {
		select {
		case p, ok := <-chPessoas:
			if p.ID != uuid.Nil {
				pessoas = append(pessoas, p)
			}
			if i == batch || !ok {
				if err := repo.Insert(pessoas); err != nil {
					slog.Error(err.Error())
				}
				i = 0
				pessoas = make([]rinha.Pessoa, 0, batch)
			}
			i++

			if !ok {
				chExit <- struct{}{}
				return
			}

		case <-tick.C:
			if len(pessoas) > 0 {
				if err := repo.Insert(pessoas); err != nil {
					slog.Error(err.Error())
				}
			}
			i = 0
			pessoas = make([]rinha.Pessoa, 0, batch)
		}
	}
}



import (
	"context"
	"encoding/json"
	"fmt"
	"strings"
	"time"
	"log/slog"
	"github.com/filhodanuvem/rinha"
	"github.com/google/uuid"
	"github.com/jackc/pgconn"
	"github.com/jackc/pgx/v4"
	"github.com/jackc/pgx/v4/pgxpool"
	"github.com/redis/go-redis/v9"
)

type Repository struct {
	Conn      *pgxpool.Pool
	ChPessoas chan rinha.Pessoa
}

var Repo *Repository

func NewRepository(Conn *pgxpool.Pool, Cache *redis.Client) *Repository {
	if Repo == nil {
		Repo = &Repository{Conn: Conn, Cache: Cache, ChPessoas: make(chan rinha.Pessoa)}
	}
	return Repo
}

func (r *Repository) Create(ctx context.Context, pessoa rinha.Pessoa) error {
	r.ChPessoas <- pessoa
	return nil
}

func (r *Repository) Insert(pessoas []rinha.Pessoa) error {
	if len(pessoas) == 0 {
		return nil
	}

	_, err := r.Conn.CopyFrom(
		context.Background(),
		pgx.Identifier{"pessoas"},
		[]string{"id", "apelido", "nome", "nascimento", "stack", "search_index"},
		pgx.CopyFromSlice(len(pessoas), func(i int) ([]any, error) {
			p := pessoas[i]
			index := fmt.Sprintf("%s %s %s", strings.ToLower(p.Apelido), strings.ToLower(p.Nome), strings.ToLower(strings.Join(p.Stack, " ")))
			return []any{p.ID, p.Apelido, p.Nome, p.Nascimento.Time, p.Stack, index}, nil
		}),
	)

	if pgErr, ok := err.(*pgconn.PgError); ok && pgErr.ConstraintName == "pessoas_apelido_key" {
		slog.Error("algum apelido ja existe")
		return pgErr
	}

	return err
}

func (r *Repository) FindOne(ctx context.Context, id uuid.UUID) (rinha.Pessoa, error) {
	var pessoa rinha.Pessoa
	var nascimento time.Time
	err = r.Conn.QueryRow(ctx, `SELECT id, apelido, nome, nascimento, stack FROM pessoas WHERE id = $1 LIMIT 1`, id).Scan(&pessoa.ID, &pessoa.Apelido, &pessoa.Nome, &nascimento, &pessoa.Stack)
	pessoa.Nascimento = rinha.Date{Time: nascimento}
	if err == pgx.ErrNoRows {
		return pessoa, nil
	}
	return pessoa, err
}

func (r *Repository) FindByTermo(ctx context.Context, t string) ([]rinha.Pessoa, error) {
	pessoas := []rinha.Pessoa{}
	rows, err := r.Conn.Query(ctx, ` SELECT id, apelido, nome, nascimento, stack FROM pessoas WHERE search_index ILIKE '%' || $1 || '%' LIMIT 50 `, strings.ToLower(t))
	if err != nil {
		return pessoas, err
	}
	defer rows.Close()x
	for rows.Next() {
		var pessoa rinha.Pessoa
		var nascimento time.Time
		err := rows.Scan(&pessoa.ID, &pessoa.Apelido, &pessoa.Nome, &nascimento, &pessoa.Stack)
		if err != nil {
			slog.Error(err.Error())
		}
		pessoas = append(pessoas, pessoa)
	}
	return pessoas, err
}






import (
	"context"
	"log/slog"
	"time"
)

func PostPessoas(w http.ResponseWriter, r *http.Request) {
	ctx, cancel := context.WithTimeout(r.Context(), 15*time.Second)
	defer cancel()
	
	var p rinha.Pessoa
	if err := pessoa.Repo.Create(r.Context(), p); err != nil {
		w.WriteHeader(http.StatusUnprocessableEntity)
		if err == rinha.ErrApelidoJaExiste {
			w.Write([]byte("apelido j√° existe"))
			return
		}
		slog.Error(err.Error())
		return
	}
}


func GetPessoaByID(w http.ResponseWriter, r *http.Request, param string) {
	pessoa, err := pessoa.Repo.FindOne(r.Context(), id)
	if err != nil {
		slog.Error(err.Error())
		w.WriteHeader(http.StatusInternalServerError)
		return
	}
}

func GetPessoasByTermo(w http.ResponseWriter, r *http.Request) {
	pessoas, err := pessoa.Repo.FindByTermo(r.Context(), termo)
	if err != nil {
		slog.Error("error when finding by t:" + err.Error())
		w.WriteHeader(http.StatusInternalServerError)
		return
	}
}














#sqlc

https://www.youtube.com/watch?v=EYgnlMWhrnM&t=10s



type Querier interface {
	CreateProduct(ctx context.Context, arg CreateProductParams) (Product, error)
	DeleteProduct(ctx context.Context, id int32) error
	GetProduct(ctx context.Context, id int32) (Product, error)
	GetProducts(ctx context.Context) ([]Product, error)
	UpdateProduct(ctx context.Context, arg UpdateProductParams) (Product, error)
}

var _ Querier = (*Queries)(nil)



func createRandomProduct(t *testing.T) Product {
	arg := CreateProductParams{ Name:  "any_name", Price: 10 }
	
	product, err := testQueries.CreateProduct(context.Background(), arg)
	
	require.NoError(t, err)
	require.NotEmpty(t, product)

	require.NotEmpty(t, product.ID)
	require.NotEmpty(t, product.CreatedAt)
	require.Equal(t, arg.Name, product.Name)
	require.Equal(t, arg.Price, product.Price)

	return product
}

func TestCreateProduct(t *testing.T) {
	createRandomProduct(t)
}

func TestGetProduct(t *testing.T) {
	productRandomCreated := createRandomProduct(t)
	productFinded, err := testQueries.GetProduct(context.Background(), productRandomCreated.ID)

	require.NoError(t, err)
	require.NotEmpty(t, productRandomCreated)
	require.NotEmpty(t, productFinded)

	require.Equal(t, productRandomCreated.ID, productFinded.ID)
	require.Equal(t, productRandomCreated.Name, productFinded.Name)
	require.Equal(t, productRandomCreated.Price, productFinded.Price)
	require.Equal(t, productRandomCreated.CreatedAt, productFinded.CreatedAt)
}

func TestDeleteProduct(t *testing.T) {
	productRandomCreated := createRandomProduct(t)
	err := testQueries.DeleteProduct(context.Background(), productRandomCreated.ID)

	require.NoError(t, err)
}

func TestUpdateProduct(t *testing.T) {
	productRandomCreated := createRandomProduct(t)

	arg := UpdateProductParams{
		ID:    productRandomCreated.ID,
		Name:  "updated_name",
		Price: 20,
	}

	productUpdated, err := testQueries.UpdateProduct(context.Background(), arg)

	require.NoError(t, err)
	require.NotEmpty(t, productUpdated)

	require.Equal(t, productRandomCreated.ID, productUpdated.ID)
	require.Equal(t, arg.Name, productUpdated.Name)
	require.Equal(t, arg.Price, productUpdated.Price)
	require.Equal(t, productRandomCreated.CreatedAt, productUpdated.CreatedAt)
}

func TestGetProducts(t *testing.T) {
	productRandomCreated := createRandomProduct(t)
	productsFinded, err := testQueries.GetProducts(context.Background())

	require.NoError(t, err)
	require.NotEmpty(t, productRandomCreated)
	require.NotEmpty(t, productsFinded)

	for _, product := range productsFinded {
		require.NotEmpty(t, product.ID)
		require.NotEmpty(t, product.Name)
		require.NotEmpty(t, product.Price)
		require.NotEmpty(t, product.CreatedAt)
	}
}




db.go

package db

import (
	"context"
	"database/sql"
)

type DBTX interface {
	ExecContext(context.Context, string, ...interface{}) (sql.Result, error)
	PrepareContext(context.Context, string) (*sql.Stmt, error)
	QueryContext(context.Context, string, ...interface{}) (*sql.Rows, error)
	QueryRowContext(context.Context, string, ...interface{}) *sql.Row
}

func New(db DBTX) *Queries {
	return &Queries{db: db}
}

type Queries struct {
	db DBTX
}

func (q *Queries) WithTx(tx *sql.Tx) *Queries {
	return &Queries{
		db: tx,
	}
}


product.sql.go


package db

import (
	"context"
)

const createProduct = `-- name: CreateProduct :one
INSERT INTO products (
  name,
  price
) VALUES (
  $1, $2
) RETURNING id, name, price, created_at
`

type CreateProductParams struct {
	Name  string `json:"name"`
	Price int32  `json:"price"`
}

func (q *Queries) CreateProduct(ctx context.Context, arg CreateProductParams) (Product, error) {
	row := q.db.QueryRowContext(ctx, createProduct, arg.Name, arg.Price)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Price,
		&i.CreatedAt,
	)
	return i, err
}

const deleteProduct = `-- name: DeleteProduct :exec
DELETE FROM products 
WHERE id = $1
`

func (q *Queries) DeleteProduct(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, deleteProduct, id)
	return err
}

const getProduct = `-- name: GetProduct :one
SELECT id, name, price, created_at FROM products  
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetProduct(ctx context.Context, id int32) (Product, error) {
	row := q.db.QueryRowContext(ctx, getProduct, id)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Price,
		&i.CreatedAt,
	)
	return i, err
}

const getProducts = `-- name: GetProducts :many
SELECT id, name, price, created_at FROM products
`

func (q *Queries) GetProducts(ctx context.Context) ([]Product, error) {
	rows, err := q.db.QueryContext(ctx, getProducts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Product{}
	for rows.Next() {
		var i Product
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Price,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateProduct = `-- name: UpdateProduct :one
UPDATE products 
SET name = $2, price = $3
WHERE id = $1 RETURNING id, name, price, created_at
`

type UpdateProductParams struct {
	ID    int32  `json:"id"`
	Name  string `json:"name"`
	Price int32  `json:"price"`
}

func (q *Queries) UpdateProduct(ctx context.Context, arg UpdateProductParams) (Product, error) {
	row := q.db.QueryRowContext(ctx, updateProduct, arg.ID, arg.Name, arg.Price)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Price,
		&i.CreatedAt,
	)
	return i, err
}










https://www.youtube.com/watch?v=VR4mF9TMPws
https://www.youtube.com/watch?v=7zVG0HoqkGk
https://www.youtube.com/watch?v=OFud4iPuAH8
https://www.youtube.com/watch?v=qIcSHpx2Z1Q
https://www.youtube.com/watch?v=wyEYpX5U4Vg



func Transacoes(c *fiber.Ctx) error {

	transacaoResponse, err := services.CreateTransacao(clienteId, &transacao)
	if err != nil {
		if errors.Is(err, services.ErroClienteNaoExiste) {
			return c.Status(http.StatusNotFound).JSON(&fiber.Map{"erro": "Cliente n√£o existe."})
		}
		if errors.Is(err, services.ErroValorDaTransacao) {
			return c.Status(http.StatusBadRequest).JSON(&fiber.Map{"erro": "O valor da transa√ß√£o deve ser maior que zero."})
		}
		if errors.Is(err, services.ErroTipoDaTransacao) {
			return c.Status(http.StatusBadRequest).JSON(&fiber.Map{"erro": "A transa√ß√£o deve ser do tipo 'c' (cr√©dito) ou 'd' (d√©bito)."})
		}
		if errors.Is(err, services.ErroDescricao) {
			return c.Status(http.StatusBadRequest).JSON(&fiber.Map{"erro": "A descri√ß√£o deve ter de 1 a 10 caract√©res."})
		}
		if errors.Is(err, services.ErroTransacaoDebito) {
			return c.Status(http.StatusUnprocessableEntity).JSON(&fiber.Map{"erro":       "A transa√ß√£o do tipo 'd' (d√©bito) nunca pode deixar o saldo do cliente menor que seu limite dispon√≠vel.", "observacao": "Transa√ß√µes do tipo 'c' (cr√©dito) ainda ser√£o processadas."})
		}
		return c.Status(http.StatusBadRequest).JSON(&fiber.Map{"erro": err.Error()})
	}

	return c.JSON(transacaoResponse)
}








TransactionQuery(db *sql.DB, baseQuery string) (rows *sql.Rows, code int, err error) {
        tx, txErr := db.Begin()
        if txErr != nil {
            return nil, -1, txErr
        }

        selectStmt, prepErr := tx.Prepare(baseQuery)
        if prepErr != nil {
            return nil, -1, fmt.Errorf("Failed to prepare statment: %s Error: %v", baseQuery, prepErr)
        }

        defer func() {
            if stmtErr := selectStmt.Close(); stmtErr != nil {
                rows = nil
                code = -2
                err = fmt.Errorf("Failed to close statement: %v.", stmtErr)
            }
        }()

        rows, err = selectStmt.Query()
        if err != nil {
            fmt.Errorf("Failed to retrieve data: %v", err)
            return nil, -1, err
        }
        return rows, 0, nil
    }
	
	
	
	func TransactionQuery(db *sql.DB, baseQuery string) (rows *sql.Rows, code int, err error) {
    tx, txErr := db.Begin()
    if txErr != nil {
        return nil, -1, txErr
    }

    /*selectStmt, prepErr := tx.Prepare(baseQuery)
      if prepErr != nil {
          return nil, -1, fmt.Errorf("Failed to prepare statment: %s Error: %v", baseQuery, prepErr)
      }
    */
    rows, err = tx.Query(baseQuery)
    if err != nil {
        fmt.Errorf("Failed to retrieve data: %v", err)
        return nil, -1, err
    }

    /*    if stmtErr := selectStmt.Close(); stmtErr != nil {
          rows = nil
          code = -2
          err = fmt.Errorf("Failed to close statement: %v.", stmtErr)
      }*/

    if txCloseErr := tx.Commit(); txErr != nil {
        rows = rows
        code = -3
        err = txCloseErr
    }
    return rows, 0, nil
}







ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	err = db.PingContext(ctx)
	if err != nil {
		return nil, err
	}
	
	
	
	
	
ConnectContext().

-   // db is *sqlx.DB that contain *sql.DB
-   db, err := sqlx.Connect("postgres", fmt.Sprintf("host=%s port=%s user=%s password=%s dbname=%s sslmode=%s",
+   ctxTimeout, ctxCancel := context.WithTimeout(context.Background(), time.Second*3)
+   defer ctxCancel()
+
+   db, err := sqlx.ConnectContext(ctxTimeout, "postgres", fmt.Sprintf("host=%s port=%s user=%s password=%s dbname=%s sslmode=%s",
        postgresConfig.Host, postgresConfig.Port, postgresConfig.Username, postgresConfig.Password, postgresConfig.DBName, postgresConfig.SSLMode))
    if err != nil {
        panic(err)
    }
	
	
	
// CancelSubscription cancels a given subscription by setting canceled_at to now()
func (r *srepo) CancelSubscription(tx *sqlx.Tx, id int64) (Subscription, error) {
  var sub Subscription
  err := tx.Get(&sub, "UPDATE subscription SET canceled_at = NOW(), status='canceled' WHERE id = $1 RETURNING *", id)
  if err != nil {
    return sub, err
  }

  return sub, nil
}







type Service struct {
  db   *sqlx.DB
  repo *srepo
}

func NewService(db *sqlx.DB, repo *srepo) *Service {
  return &Service{repo: repo, db: db}
}

func (s *Service) CancelSubscription(ctx context.Context, id int64) (*Subscription, error) {
  tx, err := s.db.BeginTxx(ctx, nil)
  if err != nil {
    return nil, err
  }

  defer func() {
    // !!! This would not work if the subscriptions is already canceled 
    // and the error is not returned
    if err != nil {
      _ = tx.Rollback()
      return
    }
  }()

  sub, err := s.repo.GetSubscription(tx, id)
  if err != nil {
    return nil, err
  }

  if sub.Status != "active" {
    return &sub, nil
  }

  if sub.CanceledAt.Valid {
    return &sub, nil
  }

  sub, err = s.repo.CancelSubscription(tx, id)
  if err != nil {
    return nil, err
  }

  err = tx.Commit()

  return &sub, err
}





stats := dbx.Stats()
      require.Equal(t, 0, stats.InUse)
      require.Equal(t, 0, stats.MaxOpenConnections)
    })
	
	
	
	
	
	
	
	
	
	
	
	func (c *Activities) Insert(activity api.Activity) (int, error) {
 res, err := c.db.Exec("INSERT INTO activities VALUES(NULL,?,?);", activity.Time, activity.Description)
 if err != nil {
  return 0, err
 }

 var id int64
 if id, err = res.LastInsertId(); err != nil {
  return 0, err
 }
 return int(id), nil
}



 row := c.db.QueryRow("SELECT id, time, description FROM activities WHERE id=?", id)
row, err := c.db.Query("SELECT * FROM activities WHERE id=?", id)
if err != nil {
 return nil, err
}

func (c *Activities) Retrieve(id int) (api.Activity, error) {
 log.Printf("Getting %d", id)

 // Query DB row based on ID
 row := c.db.QueryRow("SELECT id, time, description FROM activities WHERE id=?", id)

 // Parse row into Activity struct
 activity := api.Activity{}
 var err error
 if err = row.Scan(&activity.ID, &activity.Time, &activity.Description); err == sql.ErrNoRows {
  log.Printf("Id not found")
  return api.Activity{}, ErrIDNotFound
 }
 return activity, err
}






func (c *Activities) List(offset int) ([]api.Activity, error) {
 rows, err := c.db.Query("SELECT * FROM activities WHERE ID > ? ORDER BY id DESC LIMIT 100", offset)
 if err != nil {
  return nil, err
 }
 defer rows.Close()

 data := []api.Activity{}
 for rows.Next() {
  i := api.Activity{}
  err = rows.Scan(&i.ID, &i.Time, &i.Description)
  if err != nil {
   return nil, err
  }
  data = append(data, i)
 }
 return data, nil
}



type Activities struct {
 db     *sql.DB
 mu     sync.Mutex
+ insert, retrieve, list *sql.Stmt
}

func NewActivities() (*Activities, error) {
 db, err := sql.Open("sqlite3", file)
 if err != nil {
  return nil, err
 }
 if _, err := db.Exec(create); err != nil {
  return nil, err
 }
+ insert, err := db.Prepare("INSERT INTO activities VALUES(NULL,?,?);")
+ if err != nil {
+  return nil, err
+ }
 ...
 return &Activities{
  db:     db,
+  insert: insert,
+  retrieve: retrieve,
+  list: list,
 }, nil

}


 res, err := insStmt.Exec(activity.Time, activity.Description)
 if err != nil {
  return 0, err
 }


----


 CREATE TABLE `userinfo` (
        `uid` INTEGER PRIMARY KEY AUTOINCREMENT,
        `username` VARCHAR(64) NULL,
        `departname` VARCHAR(64) NULL,
        `created` DATE NULL
    );

 func main() {
        db, err := sql.Open("sqlite3", "./foo.db")
        checkErr(err)

        // insert
        stmt, err := db.Prepare("INSERT INTO userinfo(username, departname, created) values(?,?,?)")
        checkErr(err)

        res, err := stmt.Exec("astaxie", "Á†îÂèëÈÉ®Èó®", "2012-12-09")
        checkErr(err)

        id, err := res.LastInsertId()
        checkErr(err)

        fmt.Println(id)
        // update
        stmt, err = db.Prepare("update userinfo set username=? where uid=?")
        checkErr(err)

        res, err = stmt.Exec("astaxieupdate", id)
        checkErr(err)

        affect, err := res.RowsAffected()
        checkErr(err)

        fmt.Println(affect)

        // query
        rows, err := db.Query("SELECT * FROM userinfo")
        checkErr(err)
        var uid int
        var username string
        var department string
        var created time.Time

        for rows.Next() {
            err = rows.Scan(&uid, &username, &department, &created)
            checkErr(err)
            fmt.Println(uid)
            fmt.Println(username)
            fmt.Println(department)
            fmt.Println(created)
        }

        rows.Close() //good habit to close

        // delete
        stmt, err = db.Prepare("delete from userinfo where uid=?")
        checkErr(err)

        res, err = stmt.Exec(id)
        checkErr(err)

        affect, err = res.RowsAffected()
        checkErr(err)

        fmt.Println(affect)

        db.Close()

    }

    func checkErr(err error) {
        if err != nil {
            panic(err)
        }
    }


 trashSQL, err := database.Prepare("update task set is_deleted='Y',last_modified_at=datetime() where id=?")
    if err != nil {
        fmt.Println(err)
    }
    tx, err := database.Begin()
    if err != nil {
        fmt.Println(err)
    }
    _, err = tx.Stmt(trashSQL).Exec(id)
    if err != nil {
        fmt.Println("doing rollback")
        tx.Rollback()
    } else {
        tx.Commit()
    }
	
	
	----
	
	func insertUsers(db *sql.DB, count int) error {
 for i := 0; i < count; i++ {
  _, err := db.Exec("INSERT INTO users VALUES (?)", gofakeit.Email())
  if err != nil {
   return err
  }
 }
 return nil
}


 db, err := sql.Open("sqlite", dbDir+"/test.db")
   if err != nil { panic(err) }
 defer db.Close()

 _, err = db.Exec("PRAGMA journal_mode=WAL")
   if err != nil { panic(err) }

 _, err = db.Exec("CREATE TABLE users (email TEXT)")
   if err != nil { panic(err) }

 err = insertUsers(db, 10)
   if err != nil { panic(err) }

 rows, err := db.Query("SELECT email FROM users")
   if err != nil { panic(err) }

 // Do stuff with rows here but
 //   don't call rows.Close()
 //   and don't read all the rows

 rows.Close() // <-- REMOVING THIS WILL HAVE AN INTERESTING EFFECT

 err = insertUsers(db, 10000)
   if err != nil { panic(err) }

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 go get github.com/pterm/pterm


package main

import (
	"time"

	"github.com/pterm/pterm"
)

func main() {
	// Create a multi printer instance from the default one
	multi := pterm.DefaultMultiPrinter

	// Create five progress bars with a total of 100 units each, and assign each a new writer from the multi printer
	pb1, _ := pterm.DefaultProgressbar.WithTotal(100).WithWriter(multi.NewWriter()).Start("Progressbar 1")
	pb2, _ := pterm.DefaultProgressbar.WithTotal(100).WithWriter(multi.NewWriter()).Start("Progressbar 2")
	pb3, _ := pterm.DefaultProgressbar.WithTotal(100).WithWriter(multi.NewWriter()).Start("Progressbar 3")
	pb4, _ := pterm.DefaultProgressbar.WithTotal(100).WithWriter(multi.NewWriter()).Start("Progressbar 4")
	pb5, _ := pterm.DefaultProgressbar.WithTotal(100).WithWriter(multi.NewWriter()).Start("Progressbar 5")

	// Start the multi printer
	multi.Start()

	// Loop to increment progress bars based on certain conditions
	for i := 1; i <= 100; i++ {
		pb1.Increment() // Increment the first progress bar at each iteration

		if i%2 == 0 {
			pb2.Add(3) // Add 3 units to the second progress bar at every even iteration
		}

		if i%5 == 0 {
			pb3.Increment() // Increment the third progress bar at every fifth iteration
		}

		if i%10 == 0 {
			pb4.Increment() // Increment the fourth progress bar at every tenth iteration
		}

		if i%3 == 0 {
			pb5.Increment() // Increment the fifth progress bar at every third iteration
		}

		time.Sleep(time.Millisecond * 50) // Pause for 50 milliseconds at each iteration
	}

	// Stop the multi printer
	multi.Stop()
}



package main

import "github.com/pterm/pterm"

func main() {
	// Define the data for the table.
	data := pterm.TableData{
		{"Firstname", "Lastname", "Email"},
		{"Paul\n\nNewline", "Dean", "augue@velitAliquam.co.uk"},
		{"Callie", "Mckay", "nunc.sed@est.com\nNewline"},
		{"Libby", "Camacho", "lobortis@semper.com"},
		{"Âº†", "Â∞èÂÆù", "zhang@example.com"},
	}

	// Create and render the table.
	// The options are chained in a single line for simplicity.
	// The table has a header, a row separator, and a header row separator.
	pterm.DefaultTable.WithHasHeader().WithRowSeparator("-").WithHeaderRowSeparator("-").WithData(data).Render()
}


package main

import "github.com/pterm/pterm"

func main() {
	// Define the data for the first table
	tableData1 := pterm.TableData{
		{"Firstname", "Lastname", "Email", "Note"},
		{"Paul", "Dean", "augue@velitAliquam.co.uk", ""},
		{"Callie", "Mckay", "nunc.sed@est.com", "ËøôÊòØ‰∏Ä‰∏™ÊµãËØï, haha!"},
		{"Libby", "Camacho", "lobortis@semper.com", "just a test, hey!"},
		{"Âº†", "Â∞èÂÆù", "zhang@example.com", ""},
	}

	// Create a table with a header and the defined data, then render it
	pterm.DefaultTable.WithHasHeader().WithData(tableData1).Render()

	pterm.Println() // Blank line

	// Define the data for the second table
	tableData2 := pterm.TableData{
		{"Firstname", "Lastname", "Email"},
		{"Paul\n\nNewline", "Dean", "augue@velitAliquam.co.uk"},
		{"Callie", "Mckay", "nunc.sed@est.com\nNewline"},
		{"Libby", "Camacho", "lobortis@semper.com"},
		{"Âº†", "Â∞èÂÆù", "zhang@example.com"},
	}

	// Create another table with a header and the defined data, then render it
	pterm.DefaultTable.WithHasHeader().WithData(tableData2).Render()
}





























go get github.com/jedib0t/go-pretty/v6
github.com/jedib0t/go-pretty/v6/list
github.com/jedib0t/go-pretty/v6/progress
github.com/jedib0t/go-pretty/v6/table
github.com/jedib0t/go-pretty/v6/text

  "github.com/jedib0t/go-pretty/v6/list"
    "github.com/jedib0t/go-pretty/v6/progress"
    "github.com/jedib0t/go-pretty/v6/table"
    "github.com/jedib0t/go-pretty/v6/text"



package main

import (
	"flag"
	"fmt"
	"math/rand"
	"time"

	"github.com/jedib0t/go-pretty/v6/progress"
	"github.com/jedib0t/go-pretty/v6/text"
)

var (
	flagAutoStop           = flag.Bool("auto-stop", false, "Auto-stop rendering?")
	flagHideETA            = flag.Bool("hide-eta", false, "Hide the ETA?")
	flagHideETAOverall     = flag.Bool("hide-eta-overall", false, "Hide the ETA in the overall tracker?")
	flagHideOverallTracker = flag.Bool("hide-overall", false, "Hide the Overall Tracker?")
	flagHidePercentage     = flag.Bool("hide-percentage", false, "Hide the progress percent?")
	flagHideTime           = flag.Bool("hide-time", false, "Hide the time taken?")
	flagHideValue          = flag.Bool("hide-value", false, "Hide the tracker value?")
	flagNumTrackers        = flag.Int("num-trackers", 13, "Number of Trackers")
	flagShowSpeed          = flag.Bool("show-speed", false, "Show the tracker speed?")
	flagShowSpeedOverall   = flag.Bool("show-speed-overall", false, "Show the overall tracker speed?")
	flagShowPinned         = flag.Bool("show-pinned", false, "Show a pinned message?")
	flagRandomFail         = flag.Bool("rnd-fail", false, "Introduce random failures in tracking")
	flagRandomDefer        = flag.Bool("rnd-defer", false, "Introduce random deferred starts")
	flagRandomLogs         = flag.Bool("rnd-logs", false, "Output random logs in the middle of tracking")

	messageColors = []text.Color{
		text.FgRed,
		text.FgGreen,
		text.FgYellow,
		text.FgBlue,
		text.FgMagenta,
		text.FgCyan,
		text.FgWhite,
	}
	timeStart = time.Now()
)

func getMessage(idx int64, units *progress.Units) string {
	var message string
	switch units {
	case &progress.UnitsBytes:
		message = fmt.Sprintf("Downloading File    #%3d", idx)
	case &progress.UnitsCurrencyDollar, &progress.UnitsCurrencyEuro, &progress.UnitsCurrencyPound:
		message = fmt.Sprintf("Transferring Amount #%3d", idx)
	default:
		message = fmt.Sprintf("Calculating Total   #%3d", idx)
	}
	return message
}

func getUnits(idx int64) *progress.Units {
	var units *progress.Units
	switch {
	case idx%5 == 0:
		units = &progress.UnitsCurrencyPound
	case idx%4 == 0:
		units = &progress.UnitsCurrencyDollar
	case idx%3 == 0:
		units = &progress.UnitsBytes
	default:
		units = &progress.UnitsDefault
	}
	return units
}

func trackSomething(pw progress.Writer, idx int64, updateMessage bool) {
	total := idx * idx * idx * 250
	incrementPerCycle := idx * int64(*flagNumTrackers) * 250

	units := getUnits(idx)
	message := getMessage(idx, units)
	tracker := progress.Tracker{Message: message, Total: total, Units: *units, DeferStart: *flagRandomDefer && rand.Float64() < 0.5}
	if idx == int64(*flagNumTrackers) {
		tracker.Total = 0
	}

	pw.AppendTracker(&tracker)

	if tracker.DeferStart {
		time.Sleep(3 * time.Second)
		tracker.Start()
	}

	ticker := time.Tick(time.Millisecond * 500)
	updateTicker := time.Tick(time.Millisecond * 250)
	for !tracker.IsDone() {
		select {
		case <-ticker:
			tracker.Increment(incrementPerCycle)
			if idx == int64(*flagNumTrackers) && tracker.Value() >= total {
				tracker.MarkAsDone()
			} else if *flagRandomFail && rand.Float64() < 0.1 {
				tracker.MarkAsErrored()
			}
			pw.SetPinnedMessages(
				fmt.Sprintf(">> Current Time: %-32s", time.Now().Format(time.RFC3339)),
				fmt.Sprintf(">>   Total Time: %-32s", time.Since(timeStart).Round(time.Millisecond)),
			)
		case <-updateTicker:
			if updateMessage {
				rndIdx := rand.Intn(len(messageColors))
				if rndIdx == len(messageColors) {
					rndIdx--
				}
				tracker.UpdateMessage(messageColors[rndIdx].Sprint(message))
			}
		}
	}
}

func main() {
	flag.Parse()
	fmt.Printf("Tracking Progress of %d trackers ...\n\n", *flagNumTrackers)

	// instantiate a Progress Writer and set up the options
	pw := progress.NewWriter()
	pw.SetAutoStop(*flagAutoStop)
	pw.SetMessageLength(24)
	pw.SetNumTrackersExpected(*flagNumTrackers)
	pw.SetSortBy(progress.SortByPercentDsc)
	pw.SetStyle(progress.StyleDefault)
	pw.SetTrackerLength(25)
	pw.SetTrackerPosition(progress.PositionRight)
	pw.SetUpdateFrequency(time.Millisecond * 100)
	pw.Style().Colors = progress.StyleColorsExample
	pw.Style().Options.PercentFormat = "%4.1f%%"
	pw.Style().Visibility.ETA = !*flagHideETA
	pw.Style().Visibility.ETAOverall = !*flagHideETAOverall
	pw.Style().Visibility.Percentage = !*flagHidePercentage
	pw.Style().Visibility.Speed = *flagShowSpeed
	pw.Style().Visibility.SpeedOverall = *flagShowSpeedOverall
	pw.Style().Visibility.Time = !*flagHideTime
	pw.Style().Visibility.TrackerOverall = !*flagHideOverallTracker
	pw.Style().Visibility.Value = !*flagHideValue
	pw.Style().Visibility.Pinned = *flagShowPinned

	// call Render() in async mode; yes we don't have any trackers at the moment
	go pw.Render()

	// add a bunch of trackers with random parameters to demo most of the
	// features available; do this in async too like a client might do (for ex.
	// when downloading a bunch of files in parallel)
	for idx := int64(1); idx <= int64(*flagNumTrackers); idx++ {
		go trackSomething(pw, idx, idx == int64(*flagNumTrackers))

		// in auto-stop mode, the Render logic terminates the moment it detects
		// zero active trackers; but in a manual-stop mode, it keeps waiting and
		// is a good chance to demo trackers being added dynamically while other
		// trackers are active or done
		if !*flagAutoStop {
			time.Sleep(time.Millisecond * 100)
		}
	}

	// wait for one or more trackers to become active (just blind-wait for a
	// second) and then keep watching until Rendering is in progress
	time.Sleep(time.Second)
	messagesLogged := make(map[string]bool)
	for pw.IsRenderInProgress() {
		if *flagRandomLogs && pw.LengthDone()%3 == 0 {
			logMsg := text.Faint.Sprintf("[INFO] done with %d trackers", pw.LengthDone())
			if !messagesLogged[logMsg] {
				pw.Log(logMsg)
				messagesLogged[logMsg] = true
			}
		}

		// for manual-stop mode, stop when there are no more active trackers
		if !*flagAutoStop && pw.LengthActive() == 0 {
			pw.Stop()
		}
		time.Sleep(time.Millisecond * 100)
	}

	fmt.Println("\nAll done!")
}



package main

import (
	"fmt"
	"os"
	"strings"

	"github.com/jedib0t/go-pretty/v6/table"
	"github.com/jedib0t/go-pretty/v6/text"
)

var (
	colTitleIndex     = "#"
	colTitleFirstName = "First Name"
	colTitleLastName  = "Last Name"
	colTitleSalary    = "Salary"
	rowHeader         = table.Row{colTitleIndex, colTitleFirstName, colTitleLastName, colTitleSalary}
	row1              = table.Row{1, "Arya", "Stark", 3000}
	row2              = table.Row{20, "Jon", "Snow", 2000, "You know nothing, Jon Snow!"}
	row3              = table.Row{300, "Tyrion", "Lannister", 5000}
	rowFooter         = table.Row{"", "", "Total", 10000}
)

func demoTableColors() {
	tw := table.NewWriter()
	tw.AppendHeader(rowHeader)
	tw.AppendRows([]table.Row{row1, row2, row3})
	tw.AppendFooter(rowFooter)
	tw.SetIndexColumn(1)
	tw.SetTitle("Game Of Thrones")

	stylePairs := [][]table.Style{
		{table.StyleColoredBright, table.StyleColoredDark},
		{table.StyleColoredBlackOnBlueWhite, table.StyleColoredBlueWhiteOnBlack},
		{table.StyleColoredBlackOnCyanWhite, table.StyleColoredCyanWhiteOnBlack},
		{table.StyleColoredBlackOnGreenWhite, table.StyleColoredGreenWhiteOnBlack},
		{table.StyleColoredBlackOnMagentaWhite, table.StyleColoredMagentaWhiteOnBlack},
		{table.StyleColoredBlackOnRedWhite, table.StyleColoredRedWhiteOnBlack},
		{table.StyleColoredBlackOnYellowWhite, table.StyleColoredYellowWhiteOnBlack},
	}

	twOuter := table.NewWriter()
	twOuter.AppendHeader(table.Row{"Bright", "Dark"})
	for _, stylePair := range stylePairs {
		row := make(table.Row, 2)
		for idx, style := range stylePair {
			tw.SetCaption(style.Name)
			tw.SetStyle(style)
			tw.Style().Title.Align = text.AlignCenter
			row[idx] = tw.Render()
		}
		twOuter.AppendRow(row)
	}
	twOuter.SetColumnConfigs([]table.ColumnConfig{
		{Name: "Bright", Align: text.AlignCenter, AlignHeader: text.AlignCenter},
		{Name: "Dark", Align: text.AlignCenter, AlignHeader: text.AlignCenter},
	})
	twOuter.SetStyle(table.StyleLight)
	twOuter.Style().Title.Align = text.AlignCenter
	twOuter.SetTitle("C O L O R S")
	twOuter.Style().Options.SeparateRows = true
	fmt.Println(twOuter.Render())
}

func demoTableFeatures() {
	//==========================================================================
	// Initialization
	//==========================================================================
	t := table.NewWriter()
	// you can also instantiate the object directly
	tTemp := table.Table{}
	tTemp.Render() // just to avoid the compile error of not using the object
	//==========================================================================

	//==========================================================================
	// Append a few rows and render to console
	//==========================================================================
	// a row need not be just strings
	t.AppendRow(table.Row{1, "Arya", "Stark", 3000})
	// all rows need not have the same number of columns
	t.AppendRow(table.Row{20, "Jon", "Snow", 2000, "You know nothing, Jon Snow!"})
	// table.Row is just a shorthand for []interface{}
	t.AppendRow([]interface{}{300, "Tyrion", "Lannister", 5000})
	// time to take a peek
	t.SetCaption("Simple Table with 3 Rows.\n")
	fmt.Println(t.Render())
	//+-----+--------+-----------+------+-----------------------------+
	//|   1 | Arya   | Stark     | 3000 |                             |
	//|  20 | Jon    | Snow      | 2000 | You know nothing, Jon Snow! |
	//| 300 | Tyrion | Lannister | 5000 |                             |
	//+-----+--------+-----------+------+-----------------------------+
	//Simple Table with 3 Rows and a separator.
	//==========================================================================

	//==========================================================================
	// Can you index the columns?
	//==========================================================================
	t.SetAutoIndex(true)
	t.SetCaption("Table with Auto-Indexing.\n")
	fmt.Println(t.Render())
	//+---+-----+--------+-----------+------+-----------------------------+
	//|   |  A  |    B   |     C     |   D  |              E              |
	//+---+-----+--------+-----------+------+-----------------------------+
	//| 1 |   1 | Arya   | Stark     | 3000 |                             |
	//| 2 |  20 | Jon    | Snow      | 2000 | You know nothing, Jon Snow! |
	//| 3 | 300 | Tyrion | Lannister | 5000 |                             |
	//+---+-----+--------+-----------+------+-----------------------------+
	//Table with Auto-Indexing.
	//
	t.AppendHeader(rowHeader)
	t.SetCaption("Table with Auto-Indexing (columns-only).\n")
	fmt.Println(t.Render())
	//+---+-----+------------+-----------+--------+-----------------------------+
	//|   |   # | FIRST NAME | LAST NAME | SALARY |                             |
	//+---+-----+------------+-----------+--------+-----------------------------+
	//| 1 |   1 | Arya       | Stark     |   3000 |                             |
	//| 2 |  20 | Jon        | Snow      |   2000 | You know nothing, Jon Snow! |
	//| 3 | 300 | Tyrion     | Lannister |   5000 |                             |
	//+---+-----+------------+-----------+--------+-----------------------------+
	//==========================================================================

	//==========================================================================
	// A table needs to have a Header & Footer (for this demo at least!)
	//==========================================================================
	t.SetAutoIndex(false)
	t.SetCaption("Table with 3 Rows & and a Header.\n")
	fmt.Println(t.Render())
	//+-----+------------+-----------+--------+-----------------------------+
	//|   # | FIRST NAME | LAST NAME | SALARY |                             |
	//+-----+------------+-----------+--------+-----------------------------+
	//|   1 | Arya       | Stark     |   3000 |                             |
	//|  20 | Jon        | Snow      |   2000 | You know nothing, Jon Snow! |
	//| 300 | Tyrion     | Lannister |   5000 |                             |
	//+-----+------------+-----------+--------+-----------------------------+
	//Table with 3 Rows & and a Header.
	//
	// and then add a footer
	t.AppendFooter(table.Row{"", "", "Total", 10000})
	// time to take a peek
	t.SetCaption("Table with 3 Rows, a Header & a Footer.\n")
	fmt.Println(t.Render())
	//+-----+------------+-----------+--------+-----------------------------+
	//|   # | FIRST NAME | LAST NAME | SALARY |                             |
	//+-----+------------+-----------+--------+-----------------------------+
	//|   1 | Arya       | Stark     |   3000 |                             |
	//|  20 | Jon        | Snow      |   2000 | You know nothing, Jon Snow! |
	//| 300 | Tyrion     | Lannister |   5000 |                             |
	//+-----+------------+-----------+--------+-----------------------------+
	//|     |            | TOTAL     |  10000 |                             |
	//+-----+------------+-----------+--------+-----------------------------+
	//Table with 3 Rows, a Header & a Footer.
	//==========================================================================

	//==========================================================================
	// Alignment?
	//==========================================================================
	// did you notice that the numeric columns were auto-aligned? when you don't
	// specify alignment, all the columns default to text.AlignDefault - numbers
	// go right and everything else left. but what if you want the first name to
	// go right too? and the last column to be "justified"?
	t.SetColumnConfigs([]table.ColumnConfig{
		{Name: colTitleFirstName, Align: text.AlignRight},
		// the 5th column does not have a title, so use the column number as the
		// identifier for the column
		{Number: 5, Align: text.AlignJustify},
	})
	// to show AlignJustify in action, lets add one more row
	t.AppendRow(table.Row{4, "Faceless", "Man", 0, "Needs a\tname."})
	// time to take a peek:
	t.SetCaption("Table with Custom Alignment for 2 columns.\n")
	fmt.Println(t.Render())
	//+-----+------------+-----------+--------+-----------------------------+
	//|   # | FIRST NAME | LAST NAME | SALARY |                             |
	//+-----+------------+-----------+--------+-----------------------------+
	//|   1 |       Arya | Stark     |   3000 |                             |
	//|  20 |        Jon | Snow      |   2000 | You know nothing, Jon Snow! |
	//| 300 |     Tyrion | Lannister |   5000 |                             |
	//|   4 |   Faceless | Man       |      0 | Needs        a        name. |
	//+-----+------------+-----------+--------+-----------------------------+
	//|     |            | TOTAL     |  10000 |                             |
	//+-----+------------+-----------+--------+-----------------------------+
	//Table with Custom Alignment for 2 columns.
	//==========================================================================

	//==========================================================================
	// Vertical Alignment?
	//==========================================================================
	// horizontal alignment is fine... what about vertical? lets add a row with
	// a column having multiple lines; and then play with VAlign
	t.AppendRow(table.Row{13, "Winter\nIs\nComing", "Valar\nMorghulis", 0, "You\n know\n  nothing,\n   Jon\n    Snow!"})
	// first without any custom VAlign
	t.SetCaption("Table with a Multi-line Row.\n")
	fmt.Println(t.Render())
	//+-----+------------+-----------+--------+-----------------------------+
	//|   # | FIRST NAME | LAST NAME | SALARY |                             |
	//+-----+------------+-----------+--------+-----------------------------+
	//|   1 |       Arya | Stark     |   3000 |                             |
	//|  20 |        Jon | Snow      |   2000 | You know nothing, Jon Snow! |
	//| 300 |     Tyrion | Lannister |   5000 |                             |
	//|   4 |   Faceless | Man       |      0 | Needs        a        name. |
	//|  13 |     Winter | Valar     |      0 | You                         |
	//|     |         Is | Morghulis |        | know                        |
	//|     |     Coming |           |        | nothing,                    |
	//|     |            |           |        | Jon                         |
	//|     |            |           |        | Snow!                       |
	//+-----+------------+-----------+--------+-----------------------------+
	//|     |            | TOTAL     |  10000 |                             |
	//+-----+------------+-----------+--------+-----------------------------+
	//Table with a Multi-line Row.
	//
	// time to Align/VAlign the columns...
	t.SetColumnConfigs([]table.ColumnConfig{
		{Name: colTitleFirstName, Align: text.AlignRight, VAlign: text.VAlignMiddle},
		{Name: colTitleLastName, VAlign: text.VAlignBottom},
		{Name: colTitleSalary, Align: text.AlignRight, VAlign: text.VAlignMiddle},
		// the 5th column does not have a title, so use the column number
		{Number: 5, Align: text.AlignJustify},
	})
	t.SetCaption("Table with a Multi-line Row with VAlign.\n")
	fmt.Println(t.Render())
	//+-----+------------+-----------+--------+-----------------------------+
	//|   # | FIRST NAME | LAST NAME | SALARY |                             |
	//+-----+------------+-----------+--------+-----------------------------+
	//|   1 |       Arya | Stark     |   3000 |                             |
	//|  20 |        Jon | Snow      |   2000 | You know nothing, Jon Snow! |
	//| 300 |     Tyrion | Lannister |   5000 |                             |
	//|   4 |   Faceless | Man       |      0 | Needs        a        name. |
	//|  13 |            |           |        | You                         |
	//|     |     Winter |           |        | know                        |
	//|     |         Is |           |      0 | nothing,                    |
	//|     |     Coming | Valar     |        | Jon                         |
	//|     |            | Morghulis |        | Snow!                       |
	//+-----+------------+-----------+--------+-----------------------------+
	//|     |            | TOTAL     |  10000 |                             |
	//+-----+------------+-----------+--------+-----------------------------+
	//Table with a Multi-line Row with VAlign.
	//
	// changed your mind about AlignJustify?
	t.SetColumnConfigs([]table.ColumnConfig{
		{Name: colTitleFirstName, Align: text.AlignRight, VAlign: text.VAlignMiddle},
		{Name: colTitleLastName, VAlign: text.VAlignBottom},
		{Name: colTitleSalary, Align: text.AlignRight, VAlign: text.VAlignMiddle},
		{Number: 5, Align: text.AlignCenter},
	})
	t.SetCaption("Table with a Multi-line Row with VAlign and changed Align.\n")
	fmt.Println(t.Render())
	//+-----+------------+-----------+--------+-----------------------------+
	//|   # | FIRST NAME | LAST NAME | SALARY |                             |
	//+-----+------------+-----------+--------+-----------------------------+
	//|   1 |       Arya | Stark     |   3000 |                             |
	//|  20 |        Jon | Snow      |   2000 | You know nothing, Jon Snow! |
	//| 300 |     Tyrion | Lannister |   5000 |                             |
	//|   4 |   Faceless | Man       |      0 |       Needs a    name.      |
	//|  13 |            |           |        |             You             |
	//|     |     Winter |           |        |             know            |
	//|     |         Is |           |      0 |           nothing,          |
	//|     |     Coming | Valar     |        |             Jon             |
	//|     |            | Morghulis |        |            Snow!            |
	//+-----+------------+-----------+--------+-----------------------------+
	//|     |            | TOTAL     |  10000 |                             |
	//+-----+------------+-----------+--------+-----------------------------+
	//Table with a Multi-line Row with VAlign and changed Align.
	//==========================================================================

	//==========================================================================
	// Time to begin anew. Too much on the screen for a demo! How about some
	// custom separators?
	//==========================================================================
	t.ResetRows()
	t.AppendRow(row1)
	t.AppendRow(row2)
	t.AppendSeparator()
	t.AppendRow(row3)
	t.SetCaption("Simple Table with 3 Rows and a Separator in-between.\n")
	fmt.Println(t.Render())
	//+-----+--------+-----------+------+-----------------------------+
	//|   1 | Arya   | Stark     | 3000 |                             |
	//|  20 | Jon    | Snow      | 2000 | You know nothing, Jon Snow! |
	//+-----+--------+-----------+------+-----------------------------+
	//| 300 | Tyrion | Lannister | 5000 |                             |
	//+-----+--------+-----------+------+-----------------------------+
	//Simple Table with 3 Rows and a Separator in-between.
	//==========================================================================

	//==========================================================================
	// Never-mind, lets start over yet again!
	//==========================================================================
	t.ResetRows()
	t.SetColumnConfigs(nil)
	t.AppendRow(row1)
	t.AppendRow(row2)
	t.AppendRow(row3)
	t.SetCaption("Starting afresh with a Simple Table again.\n")
	fmt.Println(t.Render())
	//+-----+------------+-----------+--------+-----------------------------+
	//|   # | FIRST NAME | LAST NAME | SALARY |                             |
	//+-----+------------+-----------+--------+-----------------------------+
	//|   1 | Arya       | Stark     |   3000 |                             |
	//|  20 | Jon        | Snow      |   2000 | You know nothing, Jon Snow! |
	//| 300 | Tyrion     | Lannister |   5000 |                             |
	//+-----+------------+-----------+--------+-----------------------------+
	//|     |            | TOTAL     |  10000 |                             |
	//+-----+------------+-----------+--------+-----------------------------+
	//Starting afresh with a Simple Table again.
	//==========================================================================

	//==========================================================================
	// Does it support paging?
	//==========================================================================
	t.SetPageSize(1)
	t.Style().Box.PageSeparator = "\n... page break ..."
	t.SetCaption("Table with a PageSize of 1.\n")
	fmt.Println(t.Render())
	//+-----+------------+-----------+--------+-----------------------------+
	//|   # | FIRST NAME | LAST NAME | SALARY |                             |
	//+-----+------------+-----------+--------+-----------------------------+
	//|   1 | Arya       | Stark     |   3000 |                             |
	//+-----+------------+-----------+--------+-----------------------------+
	//|     |            | TOTAL     |  10000 |                             |
	//+-----+------------+-----------+--------+-----------------------------+
	//... page break ...
	//+-----+------------+-----------+--------+-----------------------------+
	//|   # | FIRST NAME | LAST NAME | SALARY |                             |
	//+-----+------------+-----------+--------+-----------------------------+
	//|  20 | Jon        | Snow      |   2000 | You know nothing, Jon Snow! |
	//+-----+------------+-----------+--------+-----------------------------+
	//|     |            | TOTAL     |  10000 |                             |
	//+-----+------------+-----------+--------+-----------------------------+
	//... page break ...
	//+-----+------------+-----------+--------+-----------------------------+
	//|   # | FIRST NAME | LAST NAME | SALARY |                             |
	//+-----+------------+-----------+--------+-----------------------------+
	//| 300 | Tyrion     | Lannister |   5000 |                             |
	//+-----+------------+-----------+--------+-----------------------------+
	//|     |            | TOTAL     |  10000 |                             |
	//+-----+------------+-----------+--------+-----------------------------+
	//Table with a PageSize of 1.
	t.SetPageSize(0) // disables paging
	//==========================================================================

	//==========================================================================
	// How about limiting the length of every Row?
	//==========================================================================
	t.SetAllowedRowLength(50)
	t.SetCaption("Table with an Allowed Row Length of 50.\n")
	fmt.Println(t.Render())
	//+-----+------------+-----------+--------+------- ~
	//|   # | FIRST NAME | LAST NAME | SALARY |        ~
	//+-----+------------+-----------+--------+------- ~
	//|   1 | Arya       | Stark     |   3000 |        ~
	//|  20 | Jon        | Snow      |   2000 | You kn ~
	//| 300 | Tyrion     | Lannister |   5000 |        ~
	//+-----+------------+-----------+--------+------- ~
	//|     |            | TOTAL     |  10000 |        ~
	//+-----+------------+-----------+--------+------- ~
	t.SetStyle(table.StyleDouble)
	t.SetCaption("Table with an Allowed Row Length of 50 in 'StyleDouble'.\n")
	fmt.Println(t.Render())
	//‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ï¶‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï¶‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï¶‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï¶‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê ‚âà
	//‚ïë   # ‚ïë FIRST NAME ‚ïë LAST NAME ‚ïë SALARY ‚ïë        ‚âà
	//‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ï¨‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï¨‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï¨‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï¨‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê ‚âà
	//‚ïë   1 ‚ïë Arya       ‚ïë Stark     ‚ïë   3000 ‚ïë        ‚âà
	//‚ïë  20 ‚ïë Jon        ‚ïë Snow      ‚ïë   2000 ‚ïë You kn ‚âà
	//‚ïë 300 ‚ïë Tyrion     ‚ïë Lannister ‚ïë   5000 ‚ïë        ‚âà
	//‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ï¨‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï¨‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï¨‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï¨‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê ‚âà
	//‚ïë     ‚ïë            ‚ïë TOTAL     ‚ïë  10000 ‚ïë        ‚âà
	//‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ï©‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï©‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï©‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï©‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê ‚âà
	//Table with an Allowed Row Length of 50 in 'StyleDouble'.
	//==========================================================================

	//==========================================================================
	// But I want to see all the data!
	//==========================================================================
	t.SetColumnConfigs([]table.ColumnConfig{
		{Name: colTitleFirstName, WidthMax: 6},
		{Name: colTitleLastName, WidthMax: 9},
		{Name: colTitleSalary, WidthMax: 6},
		{Number: 5, WidthMax: 10},
	})
	t.SetCaption("Table on a diet.\n")
	t.SetStyle(table.StyleRounded)
	fmt.Println(t.Render())
	//‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ
	//‚îÇ   # ‚îÇ FIRST  ‚îÇ LAST NAME ‚îÇ SALARY ‚îÇ            ‚îÇ
	//‚îÇ     ‚îÇ NAME   ‚îÇ           ‚îÇ        ‚îÇ            ‚îÇ
	//‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
	//‚îÇ   1 ‚îÇ Arya   ‚îÇ Stark     ‚îÇ   3000 ‚îÇ            ‚îÇ
	//‚îÇ  20 ‚îÇ Jon    ‚îÇ Snow      ‚îÇ   2000 ‚îÇ You know n ‚îÇ
	//‚îÇ     ‚îÇ        ‚îÇ           ‚îÇ        ‚îÇ othing, Jo ‚îÇ
	//‚îÇ     ‚îÇ        ‚îÇ           ‚îÇ        ‚îÇ n Snow!    ‚îÇ
	//‚îÇ 300 ‚îÇ Tyrion ‚îÇ Lannister ‚îÇ   5000 ‚îÇ            ‚îÇ
	//‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
	//‚îÇ     ‚îÇ        ‚îÇ TOTAL     ‚îÇ  10000 ‚îÇ            ‚îÇ
	//‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ
	//Table on a diet.
	t.SetAllowedRowLength(0)
	// remove the width restrictions
	t.SetColumnConfigs([]table.ColumnConfig{})
	//==========================================================================

	//==========================================================================
	// ASCII is too simple for me.
	//==========================================================================
	t.SetStyle(table.StyleLight)
	t.SetCaption("Table using the style 'StyleLight'.\n")
	fmt.Println(t.Render())
	//‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
	//‚îÇ   # ‚îÇ FIRST NAME ‚îÇ LAST NAME ‚îÇ SALARY ‚îÇ                             ‚îÇ
	//‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
	//‚îÇ   1 ‚îÇ Arya       ‚îÇ Stark     ‚îÇ   3000 ‚îÇ                             ‚îÇ
	//‚îÇ  20 ‚îÇ Jon        ‚îÇ Snow      ‚îÇ   2000 ‚îÇ You know nothing, Jon Snow! ‚îÇ
	//‚îÇ 300 ‚îÇ Tyrion     ‚îÇ Lannister ‚îÇ   5000 ‚îÇ                             ‚îÇ
	//‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
	//‚îÇ     ‚îÇ            ‚îÇ TOTAL     ‚îÇ  10000 ‚îÇ                             ‚îÇ
	//‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
	//Table using the style 'StyleLight'.
	t.SetStyle(table.StyleDouble)
	t.SetCaption("Table using the style '%s'.\n", t.Style().Name)
	fmt.Println(t.Render())
	//‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ï¶‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï¶‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï¶‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï¶‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
	//‚ïë   # ‚ïë FIRST NAME ‚ïë LAST NAME ‚ïë SALARY ‚ïë                             ‚ïë
	//‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ï¨‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï¨‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï¨‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï¨‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
	//‚ïë   1 ‚ïë Arya       ‚ïë Stark     ‚ïë   3000 ‚ïë                             ‚ïë
	//‚ïë  20 ‚ïë Jon        ‚ïë Snow      ‚ïë   2000 ‚ïë You know nothing, Jon Snow! ‚ïë
	//‚ïë 300 ‚ïë Tyrion     ‚ïë Lannister ‚ïë   5000 ‚ïë                             ‚ïë
	//‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ï¨‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï¨‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï¨‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï¨‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
	//‚ïë     ‚ïë            ‚ïë TOTAL     ‚ïë  10000 ‚ïë                             ‚ïë
	//‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ï©‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï©‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï©‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï©‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
	//Table using the style 'StyleDouble'.
	//==========================================================================

	//==========================================================================
	// I don't like any of the ready-made styles.
	//==========================================================================
	t.SetStyle(table.Style{
		Name: "funkyStyle",
		Box: table.BoxStyle{
			BottomLeft:       "\\",
			BottomRight:      "/",
			BottomSeparator:  "v",
			Left:             "[",
			LeftSeparator:    "{",
			MiddleHorizontal: "-",
			MiddleSeparator:  "+",
			MiddleVertical:   "|",
			PaddingLeft:      "<",
			PaddingRight:     ">",
			Right:            "]",
			RightSeparator:   "}",
			TopLeft:          "(",
			TopRight:         ")",
			TopSeparator:     "^",
			UnfinishedRow:    " ~~~",
		},
	})
	t.Style().Format = table.FormatOptions{
		Footer: text.FormatLower,
		Header: text.FormatLower,
		Row:    text.FormatUpper,
	}
	t.Style().Options.DrawBorder = true
	t.Style().Options.SeparateColumns = true
	t.Style().Options.SeparateFooter = true
	t.Style().Options.SeparateHeader = true
	t.SetCaption("Table using the style 'funkyStyle'.\n")
	fmt.Println(t.Render())
	//(-----^------------^-----------^--------^-----------------------------)
	//[<  #>|<first name>|<last name>|<salary>|<                           >]
	//{-----+------------+-----------+--------+-----------------------------}
	//[<  1>|<ARYA      >|<STARK    >|<  3000>|<                           >]
	//[< 20>|<JON       >|<SNOW     >|<  2000>|<YOU KNOW NOTHING, JON SNOW!>]
	//[<300>|<TYRION    >|<LANNISTER>|<  5000>|<                           >]
	//{-----+------------+-----------+--------+-----------------------------}
	//[<   >|<          >|<total    >|< 10000>|<                           >]
	//\-----v------------v-----------v--------v-----------------------------/
	//Table using the style 'funkyStyle'.
	//==========================================================================

	//==========================================================================
	// I need some color in my life!
	//==========================================================================
	t.SetStyle(table.StyleBold)
	colorBOnW := text.Colors{text.BgWhite, text.FgBlack}
	// set colors using Colors/ColorsHeader/ColorsFooter
	t.SetColumnConfigs([]table.ColumnConfig{
		{Name: colTitleIndex, Colors: text.Colors{text.FgYellow}, ColorsHeader: colorBOnW},
		{Name: colTitleFirstName, Colors: text.Colors{text.FgHiRed}, ColorsHeader: colorBOnW},
		{Name: colTitleLastName, Colors: text.Colors{text.FgHiRed}, ColorsHeader: colorBOnW, ColorsFooter: colorBOnW},
		{Name: colTitleSalary, Colors: text.Colors{text.FgGreen}, ColorsHeader: colorBOnW, ColorsFooter: colorBOnW},
		{Number: 5, Colors: text.Colors{text.FgCyan}, ColorsHeader: colorBOnW},
	})
	t.SetCaption("Table with Colors.\n")
	fmt.Println(t.Render())
	//‚îè‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚î≥‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚î≥‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚î≥‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚î≥‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îì
	//‚îÉ   # ‚îÉ FIRST NAME ‚îÉ LAST NAME ‚îÉ SALARY ‚îÉ                             ‚îÉ
	//‚î£‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïã‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïã‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïã‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïã‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚î´
	//‚îÉ   1 ‚îÉ Arya       ‚îÉ Stark     ‚îÉ   3000 ‚îÉ                             ‚îÉ
	//‚îÉ  20 ‚îÉ Jon        ‚îÉ Snow      ‚îÉ   2000 ‚îÉ You know nothing, Jon Snow! ‚îÉ
	//‚îÉ 300 ‚îÉ Tyrion     ‚îÉ Lannister ‚îÉ   5000 ‚îÉ                             ‚îÉ
	//‚î£‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïã‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïã‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïã‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïã‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚î´
	//‚îÉ     ‚îÉ            ‚îÉ TOTAL     ‚îÉ  10000 ‚îÉ                             ‚îÉ
	//‚îó‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îª‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îª‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îª‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îª‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îõ
	//Table with Colors.
	//
	// "Table with Colors"??? where? i don't see any! well, you have to trust me
	// on this... the colors show on a terminal that supports it. to prove it,
	// lets print the same table line-by-line using "%#v" to see the control
	// sequences ...
	t.SetCaption("Table with Colors in Raw Mode.\n")
	for _, line := range strings.Split(t.Render(), "\n") {
		if line != "" {
			fmt.Printf("%#v\n", line)
		}
	}
	fmt.Println()
	//"‚îè‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚î≥‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚î≥‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚î≥‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚î≥‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îì"
	//"‚îÉ\x1b[47;30m   # \x1b[0m‚îÉ\x1b[47;30m FIRST NAME \x1b[0m‚îÉ\x1b[47;30m LAST NAME \x1b[0m‚îÉ\x1b[47;30m SALARY \x1b[0m‚îÉ\x1b[47;30m                             \x1b[0m‚îÉ"
	//"‚î£‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïã‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïã‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïã‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïã‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚î´"
	//"‚îÉ\x1b[33m   1 \x1b[0m‚îÉ\x1b[91m Arya       \x1b[0m‚îÉ\x1b[91m Stark     \x1b[0m‚îÉ\x1b[32m   3000 \x1b[0m‚îÉ\x1b[36m                             \x1b[0m‚îÉ"
	//"‚îÉ\x1b[33m  20 \x1b[0m‚îÉ\x1b[91m Jon        \x1b[0m‚îÉ\x1b[91m Snow      \x1b[0m‚îÉ\x1b[32m   2000 \x1b[0m‚îÉ\x1b[36m You know nothing, Jon Snow! \x1b[0m‚îÉ"
	//"‚îÉ\x1b[33m 300 \x1b[0m‚îÉ\x1b[91m Tyrion     \x1b[0m‚îÉ\x1b[91m Lannister \x1b[0m‚îÉ\x1b[32m   5000 \x1b[0m‚îÉ\x1b[36m                             \x1b[0m‚îÉ"
	//"‚î£‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïã‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïã‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïã‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïã‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚î´"
	//"‚îÉ     ‚îÉ            ‚îÉ\x1b[47;30m TOTAL     \x1b[0m‚îÉ\x1b[47;30m  10000 \x1b[0m‚îÉ                             ‚îÉ"
	//"‚îó‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îª‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îª‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îª‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îª‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îõ"
	//"Table with Colors in Raw Mode."
	//""
	// disable colors and revert to previous version of the column configs
	t.SetColumnConfigs([]table.ColumnConfig{})
	//==========================================================================

	//==========================================================================
	// How about not asking me to set colors in such a verbose way? And I don't
	// like wasting my terminal space with borders and separators.
	//==========================================================================
	t.SetStyle(table.StyleColoredBright)
	t.SetCaption("Table with style 'StyleColoredBright'.\n")
	fmt.Println(t.Render())
	//   #  FIRST NAME  LAST NAME  SALARY
	//   1  Arya        Stark        3000
	//  20  Jon         Snow         2000  You know nothing, Jon Snow!
	// 300  Tyrion      Lannister    5000
	//                  TOTAL       10000
	//Table with style 'StyleColoredBright'.
	t.SetStyle(table.StyleBold)
	//==========================================================================

	//==========================================================================
	// I don't like borders!
	//==========================================================================
	t.Style().Options.DrawBorder = false
	t.SetCaption("Table without Borders.\n")
	fmt.Println(t.Render())
	//   # ‚îÉ FIRST NAME ‚îÉ LAST NAME ‚îÉ SALARY ‚îÉ
	//‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïã‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïã‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïã‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïã‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
	//   1 ‚îÉ Arya       ‚îÉ Stark     ‚îÉ   3000 ‚îÉ
	//  20 ‚îÉ Jon        ‚îÉ Snow      ‚îÉ   2000 ‚îÉ You know nothing, Jon Snow!
	// 300 ‚îÉ Tyrion     ‚îÉ Lannister ‚îÉ   5000 ‚îÉ
	//‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïã‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïã‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïã‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïã‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
	//     ‚îÉ            ‚îÉ TOTAL     ‚îÉ  10000 ‚îÉ
	//Table without Borders.
	//==========================================================================

	//==========================================================================
	// I like walls and borders everywhere!
	//==========================================================================
	t.Style().Options.DrawBorder = true
	t.Style().Options.SeparateRows = true
	t.SetCaption("Table with Borders Everywhere!\n")
	t.SetTitle("Divide!")
	fmt.Println(t.Render())
	//‚îè‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚î≥‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚î≥‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚î≥‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚î≥‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îì
	//‚îÉ   # ‚îÉ FIRST NAME ‚îÉ LAST NAME ‚îÉ SALARY ‚îÉ                             ‚îÉ
	//‚î£‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïã‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïã‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïã‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïã‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚î´
	//‚îÉ   1 ‚îÉ Arya       ‚îÉ Stark     ‚îÉ   3000 ‚îÉ                             ‚îÉ
	//‚î£‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïã‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïã‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïã‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïã‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚î´
	//‚îÉ  20 ‚îÉ Jon        ‚îÉ Snow      ‚îÉ   2000 ‚îÉ You know nothing, Jon Snow! ‚îÉ
	//‚î£‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïã‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïã‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïã‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïã‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚î´
	//‚îÉ 300 ‚îÉ Tyrion     ‚îÉ Lannister ‚îÉ   5000 ‚îÉ                             ‚îÉ
	//‚î£‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïã‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïã‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïã‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïã‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚î´
	//‚îÉ     ‚îÉ            ‚îÉ TOTAL     ‚îÉ  10000 ‚îÉ                             ‚îÉ
	//‚îó‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îª‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îª‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îª‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îª‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îõ
	//Table with Borders Everywhere!
	//==========================================================================

	//==========================================================================
	// There is strength in Unity.
	//==========================================================================
	t.Style().Options.DrawBorder = false
	t.Style().Options.SeparateColumns = false
	t.Style().Options.SeparateFooter = false
	t.Style().Options.SeparateHeader = false
	t.Style().Options.SeparateRows = false
	t.SetCaption("(c) No one!")
	t.SetTitle("Unite!")
	fmt.Println(t.Render())
	fmt.Println()
	//   #  FIRST NAME  LAST NAME  SALARY
	//   1  Arya        Stark        3000
	//  20  Jon         Snow         2000  You know nothing, Jon Snow!
	// 300  Tyrion      Lannister    5000
	//                  TOTAL       10000
	//Table without Any Borders or Separators!
	//==========================================================================

	//==========================================================================
	// I want CSV.
	//==========================================================================
	for _, line := range strings.Split(t.RenderCSV(), "\n") {
		fmt.Printf("[CSV] %s\n", line)
	}
	fmt.Println()
	//[CSV] #,First Name,Last Name,Salary,
	//[CSV] 1,Arya,Stark,3000,
	//[CSV] 20,Jon,Snow,2000,"You know nothing\, Jon Snow!"
	//[CSV] 300,Tyrion,Lannister,5000,
	//[CSV] ,,Total,10000,
	//==========================================================================

	//==========================================================================
	// Nope. I want a HTML Table.
	//==========================================================================
	for _, line := range strings.Split(t.RenderHTML(), "\n") {
		fmt.Printf("[HTML] %s\n", line)
	}
	fmt.Println()
	//[HTML] <table class="go-pretty-table">
	//[HTML]   <thead>
	//[HTML]   <tr>
	//[HTML]     <th align="right">#</th>
	//[HTML]     <th>First Name</th>
	//[HTML]     <th>Last Name</th>
	//[HTML]     <th align="right">Salary</th>
	//[HTML]     <th>&nbsp;</th>
	//[HTML]   </tr>
	//[HTML]   </thead>
	//[HTML]   <tbody>
	//[HTML]   <tr>
	//[HTML]     <td align="right">1</td>
	//[HTML]     <td>Arya</td>
	//[HTML]     <td>Stark</td>
	//[HTML]     <td align="right">3000</td>
	//[HTML]     <td>&nbsp;</td>
	//[HTML]   </tr>
	//[HTML]   <tr>
	//[HTML]     <td align="right">20</td>
	//[HTML]     <td>Jon</td>
	//[HTML]     <td>Snow</td>
	//[HTML]     <td align="right">2000</td>
	//[HTML]     <td>You know nothing, Jon Snow!</td>
	//[HTML]   </tr>
	//[HTML]   <tr>
	//[HTML]     <td align="right">300</td>
	//[HTML]     <td>Tyrion</td>
	//[HTML]     <td>Lannister</td>
	//[HTML]     <td align="right">5000</td>
	//[HTML]     <td>&nbsp;</td>
	//[HTML]   </tr>
	//[HTML]   </tbody>
	//[HTML]   <tfoot>
	//[HTML]   <tr>
	//[HTML]     <td align="right">&nbsp;</td>
	//[HTML]     <td>&nbsp;</td>
	//[HTML]     <td>Total</td>
	//[HTML]     <td align="right">10000</td>
	//[HTML]     <td>&nbsp;</td>
	//[HTML]   </tr>
	//[HTML]   </tfoot>
	//[HTML] </table>
	//==========================================================================

	//==========================================================================
	// Nope. I want a Markdown Table now.
	//==========================================================================
	for _, line := range strings.Split(t.RenderMarkdown(), "\n") {
		fmt.Printf("[Markdown] %s\n", line)
	}
	fmt.Println()
	//[Markdown] | # | First Name | Last Name | Salary |  |
	//[Markdown] | ---:| --- | --- | ---:| --- |
	//[Markdown] | 1 | Arya | Stark | 3000 |  |
	//[Markdown] | 20 | Jon | Snow | 2000 | You know nothing, Jon Snow! |
	//[Markdown] | 300 | Tyrion | Lannister | 5000 |  |
	//[Markdown] |  |  | Total | 10000 |  |
	//==========================================================================

	//==========================================================================
	// That's it for today! New features will always find a place in this demo!
	//==========================================================================
}

func demoTableEmoji() {
	styles := []table.Style{
		table.StyleDefault,
		table.StyleLight,
		table.StyleColoredBright,
	}
	for _, style := range styles {
		tw := table.NewWriter()
		tw.AppendHeader(table.Row{"Key", "Value"})
		tw.AppendRows([]table.Row{
			{"Emoji 1 ü•∞", 1000},
			{"Emoji 2 ‚öîÔ∏è", 2000},
			{"Emoji 3 üéÅ", 3000},
			{"Emoji 4 „ÉÑ", 4000},
		})
		tw.AppendFooter(table.Row{"Total", 10000})
		tw.SetAutoIndex(true)
		tw.SetStyle(style)

		fmt.Println(tw.Render())
		fmt.Println()
	}
}

func main() {
	demoWhat := "features"
	if len(os.Args) > 1 {
		demoWhat = os.Args[1]
	}

	switch strings.ToLower(demoWhat) {
	case "colors":
		demoTableColors()
	case "emoji":
		demoTableEmoji()
	default:
		demoTableFeatures()
	}
}



package main

import (
	"fmt"
	"strings"

	"github.com/jedib0t/go-pretty/v6/list"
	"github.com/jedib0t/go-pretty/v6/text"
)

func demoPrint(title string, content string, prefix string) {
	fmt.Printf("%s:\n", title)
	fmt.Println(strings.Repeat("-", len(title)+1))
	for _, line := range strings.Split(content, "\n") {
		fmt.Printf("%s%s\n", prefix, line)
	}
	fmt.Println()
}

func main() {
	//==========================================================================
	// Initialization
	//==========================================================================
	l := list.NewWriter()
	// you can also instantiate the object directly
	lTemp := list.List{}
	lTemp.Render() // just to avoid the compile error of not using the object
	//==========================================================================

	//==========================================================================
	// A List needs Items.
	//==========================================================================
	l.AppendItem("Game Of Thrones")
	l.AppendItem("The Dark Tower")
	demoPrint("A Simple List", l.Render(), "")
	//A Simple List:
	//--------------
	//* Game Of Thrones
	//* The Dark Tower
	l.Reset()
	//==========================================================================

	//==========================================================================
	// I wanna Level Down!
	//==========================================================================
	l.AppendItem("Game Of Thrones")
	l.Indent()
	l.AppendItems([]interface{}{"Winter", "Is", "Coming"})
	l.Indent()
	l.AppendItems([]interface{}{"This", "Is", "Known"})
	l.UnIndent()
	l.UnIndent()
	l.AppendItem("The Dark Tower")
	l.Indent()
	l.AppendItem("The Gunslinger")
	demoPrint("A Multi-level List", l.Render(), "")
	//A Multi-level List:
	//-------------------
	//* Game Of Thrones
	//  * Winter
	//  * Is
	//  * Coming
	//    * This
	//    * Is
	//    * Known
	//* The Dark Tower
	//  * The Gunslinger
	//==========================================================================

	//==========================================================================
	// I am Fancy!
	//==========================================================================
	l.SetStyle(list.StyleBulletCircle)
	demoPrint("A List using the Style 'StyleBulletCircle'", l.Render(), "")
	//A List using the Style 'StyleBulletCircle':
	//-------------------------------------------
	//‚óè Game Of Thrones
	//  ‚óè Winter
	//  ‚óè Is
	//  ‚óè Coming
	//    ‚óè This
	//    ‚óè Is
	//    ‚óè Known
	//‚óè The Dark Tower
	//  ‚óè The Gunslinger
	l.SetStyle(list.StyleConnectedRounded)
	demoPrint("A List using the Style 'StyleConnectedRounded'", l.Render(), "")
	//A List using the Style 'StyleConnectedRounded':
	//-----------------------------------------------
	//‚ï≠‚îÄ Game Of Thrones
	//‚îú‚îÄ‚î¨‚îÄ Winter
	//‚îÇ ‚îú‚îÄ Is
	//‚îÇ ‚îú‚îÄ Coming
	//‚îÇ ‚ï∞‚îÄ‚î¨‚îÄ This
	//‚îÇ   ‚îú‚îÄ Is
	//‚îÇ   ‚ï∞‚îÄ Known
	//‚îú‚îÄ The Dark Tower
	//‚ï∞‚îÄ‚îÄ‚îÄ The Gunslinger
	//==========================================================================

	//==========================================================================
	// I want my own Style!
	//==========================================================================
	funkyStyle := list.Style{
		CharItemSingle:   "s",
		CharItemTop:      "t",
		CharItemFirst:    "f",
		CharItemMiddle:   "m",
		CharItemVertical: "|",
		CharItemBottom:   "b",
		CharNewline:      "\n",
		Format:           text.FormatUpper,
		LinePrefix:       "",
		Name:             "styleTest",
	}
	l.SetStyle(funkyStyle)
	demoPrint("A List using the Style 'funkyStyle'", l.Render(), "")
	//A List using the Style 'funkyStyle':
	//------------------------------------
	//t GAME OF THRONES
	//|f WINTER
	//|m IS
	//|b COMING
	//| f THIS
	//| m IS
	//| b KNOWN
	//b THE DARK TOWER
	// b THE GUNSLINGER
	//==========================================================================

	//==========================================================================
	// I want to use it in a HTML file!
	//==========================================================================
	demoPrint("A List in HTML format", l.RenderHTML(), "[HTML] ")
	//A List in HTML format:
	//----------------------
	//[HTML] <ul class="go-pretty-table">
	//[HTML]   <li>Game Of Thrones</li>
	//[HTML]   <ul class="go-pretty-table-1">
	//[HTML]     <li>Winter</li>
	//[HTML]     <li>Is</li>
	//[HTML]     <li>Coming</li>
	//[HTML]     <ul class="go-pretty-table-2">
	//[HTML]       <li>This</li>
	//[HTML]       <li>Is</li>
	//[HTML]       <li>Known</li>
	//[HTML]     </ul>
	//[HTML]   </ul>
	//[HTML]   <li>The Dark Tower</li>
	//[HTML]   <ul class="go-pretty-table-1">
	//[HTML]     <li>The Gunslinger</li>
	//[HTML]   </ul>
	//[HTML] </ul>
	//==========================================================================

	//==========================================================================
	// Can I get the list in Markdown format?
	//==========================================================================
	demoPrint("A List in Markdown format", l.RenderMarkdown(), "[Markdown] ")
	fmt.Println()
	//A List in Markdown format:
	//--------------------------
	//[Markdown]   * Game Of Thrones
	//[Markdown]     * Winter
	//[Markdown]     * Is
	//[Markdown]     * Coming
	//[Markdown]       * This
	//[Markdown]       * Is
	//[Markdown]       * Known
	//[Markdown]   * The Dark Tower
	//[Markdown]     * The Gunslinger
	//==========================================================================
}





















package endpointmetrics

import (
	"fmt"
	"github.com/prometheus/client_golang/prometheus/promhttp"
	"medium/m/v2/internal/observability/metrics/countermetrics"
	"medium/m/v2/internal/observability/metrics/histogrammetrics"
	"net/http"
)

const (
	// Labels
	endpoint            string = "endpoint"
	verb                string = "verb"
	pattern             string = "pattern"
	failed              string = "failed"
	error               string = "error"
	responseCode        string = "response_code"
	isAvailabilityError string = "is_availability_error"
	isReliabilityError  string = "is_reliability_error"

	// Names
	endpointRequestCounter string = "endpoint_request_counter"
	endpointRequestLatency string = "endpoint_request_latency"
)

type Metrics struct {
	// Metric
	Latency float64

	// Labels
	Endpoint             string
	Verb                 string
	Pattern              string
	ResponseCode         int
	Failed               bool
	Error                string
	HasAvailabilityError bool
	HasReliabilityError  bool
}

func Send(metrics Metrics) {
	labels := map[string]string{
		endpoint:            metrics.Endpoint,
		verb:                metrics.Verb,
		pattern:             metrics.Pattern,
		responseCode:        fmt.Sprintf("%d", metrics.ResponseCode),
		failed:              fmt.Sprintf("%v", metrics.Failed),
		error:               metrics.Error,
		isAvailabilityError: fmt.Sprintf("%v", metrics.HasAvailabilityError),
		isReliabilityError:  fmt.Sprintf("%v", metrics.HasReliabilityError),
	}

	countermetrics.Increment(countermetrics.Metric{
		Name:   endpointRequestCounter,
		Labels: labels,
	})

	histogrammetrics.Observe(histogrammetrics.Metric{
		Name:  endpointRequestLatency,
		Value: float64(metrics.Latency),
		Labels: map[string]string{
			endpoint: metrics.Endpoint,
		},
	})
}

func Start() {
	fmt.Println("starting prometheus")
	http.Handle("/metrics", promhttp.Handler())

	go func() {
		http.ListenAndServe(":2112", nil)
	}()
	fmt.Println("started prometheus")
}


---


package countermetrics

import (
	"github.com/prometheus/client_golang/prometheus"
	"github.com/prometheus/client_golang/prometheus/promauto"
	"medium/m/v2/internal/observability/metrics"
)

type Metric struct {
	Name   string
	Labels map[string]string
}

var createdMetrics = make(map[string]*prometheus.CounterVec)

func Increment(metric Metric) {
	go func() {
		labelsKey := metrics.GetLabelsKey(metric.Labels)

		opts := prometheus.CounterOpts{
			Name: metric.Name,
		}

		if createdMetrics[metric.Name] == nil {
			counter := promauto.NewCounterVec(opts, labelsKey)
			createdMetrics[metric.Name] = counter
		}

		counter := createdMetrics[metric.Name]
		counter.With(metric.Labels).Inc()
	}()
}



---


version: '3'

# ALTERA√á√ÉO 1 <<<<<<<<<<<<<<<<<<<<<<<<<
networks:
  metrics:
    driver: bridge
  transactional:
    driver: bridge

services:
  product-db:
    image: product-db
    container_name: product-db
    expose:
      - '3306'
    ports:
      - "3306:3306"
    environment:
      MYSQL_ROOT_PASSWORD: supersecret
      MYSQL_DATABASE: ProductDb
      MYSQL_USER: AdminUser
      MYSQL_PASSWORD: AdminPassword
    volumes:
      - ./productdb/mysql:/var/lib/mysql
    healthcheck:
      test: "exit 0"
    networks:
      - transactional

  product-api:
    image: product-api
    container_name: product-api
    expose:
      - '8081'
    ports:
      - "8081:8081"
    depends_on:
      product-db:
        condition: service_healthy
    networks:
      - metrics
      - transactional

# ALTERA√á√ÉO 2 <<<<<<<<<<<<<<<<<<<<<<<<<
  prometheus:
    image: prom/prometheus
    container_name: prometheus
    expose:
      - '9090'
    ports:
      - "9090:9090"
    volumes:
      - ./prometheus:/etc/prometheus
    networks:
      - metrics
	  
	  
	  
	  
type HttpHandler interface {
	Name() string
	Pattern() string
	Verb() string
	Handle(r *http.Request) (response apiresponse.ApiResponse, err apierror.ApiError)
}



package api

import (
	"medium/m/v2/internal/api/apierror"
	"medium/m/v2/internal/api/apiresponse"
	"net/http"
)

type createProduct struct {
	name    string
	verb    string
	pattern string
	service productservices.ProductService
}

func NewCreateProduct(service productservices.ProductService) *createProduct {
	return &createProduct{
		name:    "create_product",
		pattern: "/products",
		verb:    "POST",
		service: service,
	}
}

func (p *createProduct) Handle(r *http.Request) (apiresponse.ApiResponse, apierror.ApiError) {
	ctx := r.Context()

	productToCreate, err := productdecode.DecodeProductFromBody(r)
	if err != nil {
		return nil, apierror.New(err.Error(), http.StatusBadRequest)
	}

	product, err := p.service.Create(ctx, productToCreate)
	if err != nil {
		return nil, apierror.New(err.Error(), http.StatusBadRequest)
	}

	return apiresponse.New(product, http.StatusCreated), nil
}

func (p *createProduct) Name() string {
	return p.name
}

func (p *createProduct) Pattern() string {
	return p.pattern
}

func (p *createProduct) Verb() string {
	return p.verb
}



package api

import (
	"medium/m/v2/internal/api/apierror"
	"medium/m/v2/internal/api/apiresponse"
	"medium/m/v2/internal/encode"
	"medium/m/v2/internal/observability/metrics/endpointmetrics"
	"net/http"
	"time"
)

type HandlerAdapter interface {
	AdaptHandler() func(w http.ResponseWriter, r *http.Request)
}

type metricsHandlerAdapter struct {
	handler HttpHandler
}

func NewMetricsHandlerAdapter(handler HttpHandler) *metricsHandlerAdapter {
	return &metricsHandlerAdapter{
		handler: handler,
	}
}

func (m *metricsHandlerAdapter) AdaptHandler() func(w http.ResponseWriter, r *http.Request) {
	return func(w http.ResponseWriter, r *http.Request) {
		m.execute(w, r)
	}
}

func (m *metricsHandlerAdapter) execute(w http.ResponseWriter, r *http.Request) {
	start := time.Now()

	response, err := m.handler.Handle(r)

	latency := time.Since(start).Seconds()
	m.metrify(response, err, latency)

	if err != nil {
		http.Error(w, err.Name(), err.Code())
		return
	}

	encode.WriteJsonResponse(w, response.Object(), response.Code())
}

func (m *metricsHandlerAdapter) metrify(response apiresponse.ApiResponse, err apierror.ApiError, latencyInMs float64) {
	metrics := endpointmetrics.Metrics{
		Latency:  latencyInMs,
		Endpoint: m.handler.Name(),
		Verb:     m.handler.Verb(),
		Pattern:  m.handler.Pattern(),
	}

	if err != nil {
		metrics.Failed = true
		metrics.Error = err.Name()
		metrics.ResponseCode = err.Code()
		if err.Code() >= 500 {
			metrics.HasReliabilityError = false
			metrics.HasAvailabilityError = true
		} else {
			metrics.HasReliabilityError = true
			metrics.HasAvailabilityError = false
		}
	} else {
		metrics.Failed = false
		metrics.ResponseCode = response.Code()
	}

	endpointmetrics.Send(metrics)
}




package main

import (
	// ...
)

func main() {
	cfg, err := config.Load(os.Args)
	if err != nil {
		panic(err)
	}

	db, err := mysql.Start(cfg.Mysql.Url, cfg.Mysql.Db, cfg.Mysql.User, cfg.Mysql.Password)
	if err != nil {
		panic(err)
	}

	r := chi.NewRouter()
	r.Use(middleware.Logger)

	productRepository := productrepositories.New(db)
	productService := productservices.New(productRepository)

	handlers := []api.HttpHandler{}

	endpointmetrics.Start()

	getProductByIDHandler := producthandlers.NewGetProductByID(productService)
	handlers = append(handlers, getProductByIDHandler)

	searchProductsHandler := producthandlers.NewSearchProducts(productService)
	handlers = append(handlers, searchProductsHandler)

	createProductHandler := producthandlers.NewCreateProduct(productService)
	handlers = append(handlers, createProductHandler)

	updateProductHandler := producthandlers.NewUpdateProduct(productService)
	handlers = append(handlers, updateProductHandler)

	deleteProductHandler := producthandlers.NewDeleteProduct(productService)
	handlers = append(handlers, deleteProductHandler)

	for i, handler := range handlers {
		metricsAdapter := api.NewMetricsHandlerAdapter(handler)
		r.MethodFunc(handler.Verb(), handler.Pattern(), metricsAdapter.AdaptHandler())
	}

	http.ListenAndServe(":8081", r)
}




// Copyright 2015 The Prometheus Authors
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// A minimal example of how to include Prometheus instrumentation.
package main

import (
	"flag"
	"log"
	"net/http"

	"github.com/prometheus/client_golang/prometheus/collectors"

	"github.com/prometheus/client_golang/prometheus"
	"github.com/prometheus/client_golang/prometheus/promhttp"
)

var addr = flag.String("listen-address", ":8080", "The address to listen on for HTTP requests.")

func main() {
	flag.Parse()

	// Create non-global registry.
	reg := prometheus.NewRegistry()

	// Add go runtime metrics and process collectors.
	reg.MustRegister(
		collectors.NewGoCollector(),
		collectors.NewProcessCollector(collectors.ProcessCollectorOpts{}),
	)

	// Expose /metrics HTTP endpoint using the created custom registry.
	http.Handle("/metrics", promhttp.HandlerFor(reg, promhttp.HandlerOpts{Registry: reg}))
	log.Fatal(http.ListenAndServe(*addr, nil))
}




// Copyright 2022 The Prometheus Authors
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Simple example of auto-instrumentation by using an HTTP Middleware with relevant metrics.

package main

import (
	"log"
	"net/http"

	"github.com/prometheus/client_golang/examples/middleware/httpmiddleware"
	"github.com/prometheus/client_golang/prometheus"
	"github.com/prometheus/client_golang/prometheus/collectors"
	"github.com/prometheus/client_golang/prometheus/promhttp"
)

func main() {
	// Create non-global registry.
	registry := prometheus.NewRegistry()

	// Add go runtime metrics and process collectors.
	registry.MustRegister(
		collectors.NewGoCollector(),
		collectors.NewProcessCollector(collectors.ProcessCollectorOpts{}),
	)

	// Expose /metrics HTTP endpoint using the created custom registry.
	http.Handle(
		"/metrics",
		httpmiddleware.New(
			registry, nil).
			WrapHandler("/metrics", promhttp.HandlerFor(
				registry,
				promhttp.HandlerOpts{}),
			))

	log.Fatalln(http.ListenAndServe(":8080", nil))
}




// Copyright 2022 The Prometheus Authors
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package httpmiddleware is adapted from
// https://github.com/bwplotka/correlator/tree/main/examples/observability/ping/pkg/httpinstrumentation
package httpmiddleware

import (
	"net/http"

	"github.com/prometheus/client_golang/prometheus"
	"github.com/prometheus/client_golang/prometheus/promauto"
	"github.com/prometheus/client_golang/prometheus/promhttp"
)

type Middleware interface {
	// WrapHandler wraps the given HTTP handler for instrumentation.
	WrapHandler(handlerName string, handler http.Handler) http.HandlerFunc
}

type middleware struct {
	buckets  []float64
	registry prometheus.Registerer
}

// WrapHandler wraps the given HTTP handler for instrumentation:
// It registers four metric collectors (if not already done) and reports HTTP
// metrics to the (newly or already) registered collectors.
// Each has a constant label named "handler" with the provided handlerName as
// value.
func (m *middleware) WrapHandler(handlerName string, handler http.Handler) http.HandlerFunc {
	reg := prometheus.WrapRegistererWith(prometheus.Labels{"handler": handlerName}, m.registry)

	requestsTotal := promauto.With(reg).NewCounterVec(
		prometheus.CounterOpts{
			Name: "http_requests_total",
			Help: "Tracks the number of HTTP requests.",
		}, []string{"method", "code"},
	)
	requestDuration := promauto.With(reg).NewHistogramVec(
		prometheus.HistogramOpts{
			Name:    "http_request_duration_seconds",
			Help:    "Tracks the latencies for HTTP requests.",
			Buckets: m.buckets,
		},
		[]string{"method", "code"},
	)
	requestSize := promauto.With(reg).NewSummaryVec(
		prometheus.SummaryOpts{
			Name: "http_request_size_bytes",
			Help: "Tracks the size of HTTP requests.",
		},
		[]string{"method", "code"},
	)
	responseSize := promauto.With(reg).NewSummaryVec(
		prometheus.SummaryOpts{
			Name: "http_response_size_bytes",
			Help: "Tracks the size of HTTP responses.",
		},
		[]string{"method", "code"},
	)

	// Wraps the provided http.Handler to observe the request result with the provided metrics.
	base := promhttp.InstrumentHandlerCounter(
		requestsTotal,
		promhttp.InstrumentHandlerDuration(
			requestDuration,
			promhttp.InstrumentHandlerRequestSize(
				requestSize,
				promhttp.InstrumentHandlerResponseSize(
					responseSize,
					handler,
				),
			),
		),
	)

	return base.ServeHTTP
}

// New returns a Middleware interface.
func New(registry prometheus.Registerer, buckets []float64) Middleware {
	if buckets == nil {
		buckets = prometheus.ExponentialBuckets(0.1, 1.5, 5)
	}

	return &middleware{
		buckets:  buckets,
		registry: registry,
	}
}



// Copyright 2022 The Prometheus Authors
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

//go:build go1.17
// +build go1.17

// A minimal example of how to include Prometheus instrumentation.
package main

import (
	"flag"
	"fmt"
	"log"
	"net/http"
	"regexp"

	"github.com/prometheus/client_golang/prometheus"
	"github.com/prometheus/client_golang/prometheus/collectors"
	"github.com/prometheus/client_golang/prometheus/promhttp"
)

var addr = flag.String("listen-address", ":8080", "The address to listen on for HTTP requests.")

func main() {
	flag.Parse()

	// Create a new registry.
	reg := prometheus.NewRegistry()

	// Add Go module build info.
	reg.MustRegister(collectors.NewBuildInfoCollector())
	reg.MustRegister(collectors.NewGoCollector(
		collectors.WithGoCollectorRuntimeMetrics(collectors.GoRuntimeMetricsRule{Matcher: regexp.MustCompile("/.*")}),
	))

	// Expose the registered metrics via HTTP.
	http.Handle("/metrics", promhttp.HandlerFor(
		reg,
		promhttp.HandlerOpts{
			// Opt into OpenMetrics to support exemplars.
			EnableOpenMetrics: true,
		},
	))
	fmt.Println("Hello world from new Go Collector!")
	log.Fatal(http.ListenAndServe(*addr, nil))
}